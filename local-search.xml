<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编程语言C++-Skill-Tree</title>
    <link href="/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/"/>
    <url>/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="编程语言-C-x2F-C"><a href="#编程语言-C-x2F-C" class="headerlink" title="编程语言(C&#x2F;C++)"></a>编程语言(C&#x2F;C++)</h1><blockquote><p>都是语言，为什么英语比C++难这么多呢？</p></blockquote><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th></tr></thead><tbody><tr><td align="center"><a href="base">编程基础</a></td><td align="center"><a href="#oop">面向对象基础</a></td><td align="center"><a href="#stl">标准模板库</a></td><td align="center"><a href="#other">编译及调试</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a><span id = "base">编程基础</span></h2><p>C&#x2F;C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。</p><h3 id="1-变量声明和定义区别？"><a href="#1-变量声明和定义区别？" class="headerlink" title="1. 变量声明和定义区别？"></a>1. 变量声明和定义区别？</h3><pre><code class="hljs">- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 - 相同变量可以再多处声明（外部变量extern），但只能在一处定义。</code></pre><h3 id="2-“零值比较”？"><a href="#2-“零值比较”？" class="headerlink" title="2. “零值比较”？"></a>2. “零值比较”？</h3><pre><code class="hljs">- bool类型：if(flag)- int类型：if(flag == 0)- 指针类型：if(flag == null)- float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001))</code></pre><h3 id="3-strlen和sizeof区别？"><a href="#3-strlen和sizeof区别？" class="headerlink" title="3. strlen和sizeof区别？"></a>3. strlen和sizeof区别？</h3><pre><code class="hljs">- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是&#39;\0&#39;的字符串。- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**</code></pre><h3 id="4-同一不同对象可以互相赋值吗？"><a href="#4-同一不同对象可以互相赋值吗？" class="headerlink" title="4. 同一不同对象可以互相赋值吗？"></a>4. 同一不同对象可以互相赋值吗？</h3><pre><code class="hljs">- 可以，但含有指针成员时需要注意。- 对比类的对象赋值时深拷贝和浅拷贝。</code></pre><h3 id="5-结构体内存对齐问题？"><a href="#5-结构体内存对齐问题？" class="headerlink" title="5. 结构体内存对齐问题？"></a>5. 结构体内存对齐问题？</h3><pre><code class="hljs">- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</code></pre><h3 id="6-static作用是什么？在C和C-中有何区别？"><a href="#6-static作用是什么？在C和C-中有何区别？" class="headerlink" title="6. static作用是什么？在C和C++中有何区别？"></a>6. static作用是什么？在C和C++中有何区别？</h3><pre><code class="hljs">- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。- 未初始化时，static变量默认值为0。</code></pre><h3 id="7-结构体和类的区别？"><a href="#7-结构体和类的区别？" class="headerlink" title="7. 结构体和类的区别？"></a>7. 结构体和类的区别？</h3><pre><code class="hljs">- 结构体的默认限定符是public；类是private。</code></pre><ul><li><del>结构体不可以继承，类可以。</del> C++中结构体也可以继承。</li></ul><h3 id="8-malloc和new的区别？"><a href="#8-malloc和new的区别？" class="headerlink" title="8. malloc和new的区别？"></a>8. malloc和new的区别？</h3><pre><code class="hljs">- malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</code></pre><h3 id="9-指针和引用区别？"><a href="#9-指针和引用区别？" class="headerlink" title="9. 指针和引用区别？"></a>9. 指针和引用区别？</h3><ul><li><p>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</p><ul><li><p>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</p></li><li><p>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</p></li><li><p>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</p></li></ul></li></ul><h3 id="10-宏定义和函数有何区别？"><a href="#10-宏定义和函数有何区别？" class="headerlink" title="10. 宏定义和函数有何区别？"></a>10. 宏定义和函数有何区别？</h3><pre><code class="hljs">- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。- 宏函数不要在最后加分号。</code></pre><h3 id="11-宏定义和const区别？"><a href="#11-宏定义和const区别？" class="headerlink" title="11. 宏定义和const区别？"></a>11. 宏定义和const区别？</h3><pre><code class="hljs">- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。- 宏不检查类型；const会检查数据类型。- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</code></pre><h3 id="12-宏定义和typedef区别？"><a href="#12-宏定义和typedef区别？" class="headerlink" title="12. 宏定义和typedef区别？"></a>12. 宏定义和typedef区别？</h3><pre><code class="hljs">- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。- 宏不检查类型；typedef会检查数据类型。- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</code></pre><h3 id="13-宏定义和内联函数-inline-区别？"><a href="#13-宏定义和内联函数-inline-区别？" class="headerlink" title="13. 宏定义和内联函数(inline)区别？"></a>13. 宏定义和内联函数(inline)区别？</h3><pre><code class="hljs">- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。- 内联函数本身是函数，强调函数特性，具有重载等功能。- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</code></pre><h3 id="14-条件编译-ifdef-else-endif作用？"><a href="#14-条件编译-ifdef-else-endif作用？" class="headerlink" title="14. 条件编译#ifdef, #else, #endif作用？"></a>14. 条件编译#ifdef, #else, #endif作用？</h3><pre><code class="hljs">- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。- 用于子程序前加#define DEBUG用于程序调试。- 应对硬件的设置（机器类型等）。- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</code></pre><h3 id="15-区别以下几种变量？"><a href="#15-区别以下几种变量？" class="headerlink" title="15. 区别以下几种变量？"></a>15. 区别以下几种变量？</h3><pre><code class="hljs">    const int a;    int const a;    const int *a;    int *const a;- int const a和const int a均表示定义常量类型a。- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</code></pre><h3 id="16-volatile有什么作用？"><a href="#16-volatile有什么作用？" class="headerlink" title="16. volatile有什么作用？"></a>16. volatile有什么作用？</h3><pre><code class="hljs">- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。- 多线程中被几个任务共享的变量需要定义为volatile类型。</code></pre><h3 id="17-什么是常引用？"><a href="#17-什么是常引用？" class="headerlink" title="17. 什么是常引用？"></a>17. 什么是常引用？</h3><pre><code class="hljs">- 常引用可以理解为常量指针，形式为const typename &amp; refname = varname。- 常引用下，原变量值不会被别名所修改。- 原变量的值可以通过原名修改。- 常引用通常用作只读变量别名或是形参传递。</code></pre><h3 id="18-区别以下指针类型？"><a href="#18-区别以下指针类型？" class="headerlink" title="18. 区别以下指针类型？"></a>18. 区别以下指针类型？</h3><pre><code class="hljs">    int *p[10]    int (*p)[10]    int *p(int)    int (*p)(int)- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</code></pre><h3 id="19-常量指针和指针常量区别？"><a href="#19-常量指针和指针常量区别？" class="headerlink" title="19. 常量指针和指针常量区别？"></a>19. 常量指针和指针常量区别？</h3><pre><code class="hljs">- 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。- 指针常量是一个不能给改变指向的指针。如int *const p。</code></pre><h3 id="20-a和-amp-a有什么区别？"><a href="#20-a和-amp-a有什么区别？" class="headerlink" title="20. a和&amp;a有什么区别？"></a>20. a和&amp;a有什么区别？</h3><pre><code class="hljs">    假设数组int a[10];    int (*p)[10] = &amp;a;- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。- &amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</code></pre><h3 id="21-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="21. 数组名和指针（这里为指向数组首元素的指针）区别？"></a>21. 数组名和指针（这里为指向数组首元素的指针）区别？</h3><pre><code class="hljs">- 二者均可通过增减偏移量来访问数组中的元素。- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</code></pre><h3 id="22-野指针是什么？"><a href="#22-野指针是什么？" class="headerlink" title="22. 野指针是什么？"></a>22. 野指针是什么？</h3><pre><code class="hljs">- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。- 产生原因及解决办法：     - 指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。     - 指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</code></pre><h3 id="23-堆和栈的区别？"><a href="#23-堆和栈的区别？" class="headerlink" title="23. 堆和栈的区别？"></a>23. 堆和栈的区别？</h3><pre><code class="hljs">- 申请方式不同。    - 栈由系统自动分配。    - 堆由程序员手动分配。- 申请大小限制不同。    - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。    - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。- 申请效率不同。    - 栈由系统分配，速度快，不会有碎片。    - 堆由程序员分配，速度慢，且会有碎片。</code></pre><h3 id="24-delete和delete-区别？"><a href="#24-delete和delete-区别？" class="headerlink" title="24. delete和delete[]区别？"></a>24. delete和delete[]区别？</h3><pre><code class="hljs">- delete只会调用一次析构函数。- delete[]会调用数组中每个元素的析构函数。</code></pre><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a><span id = "oop">面向对象基础</span></h2><p>能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。</p><h3 id="1-面向对象三大特性？"><a href="#1-面向对象三大特性？" class="headerlink" title="1. 面向对象三大特性？"></a>1. 面向对象三大特性？</h3><pre><code class="hljs">- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。- 继承性：让某种类型对象获得另一个类型对象的属性和方法。- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</code></pre><h3 id="2-public-x2F-protected-x2F-private的区别？"><a href="#2-public-x2F-protected-x2F-private的区别？" class="headerlink" title="2. public&#x2F;protected&#x2F;private的区别？"></a>2. public&#x2F;protected&#x2F;private的区别？</h3><pre><code class="hljs">- public的变量和函数在类的内部外部都可以访问。- protected的变量和函数只能在类的内部和其派生类中访问。- private修饰的元素只能在类内访问。</code></pre><h3 id="3-对象存储空间？"><a href="#3-对象存储空间？" class="headerlink" title="3. 对象存储空间？"></a>3. 对象存储空间？</h3><pre><code class="hljs">- 非静态成员的数据类型大小之和。- 编译器加入的额外成员变量（如指向虚函数表的指针）。- 为了边缘对齐优化加入的padding。</code></pre><h3 id="4-C-空类有哪些成员函数"><a href="#4-C-空类有哪些成员函数" class="headerlink" title="4. C++空类有哪些成员函数?"></a>4. C++空类有哪些成员函数?</h3><pre><code class="hljs">- 首先，空类大小为1字节。- 默认函数有：    - 构造函数    - 析构函数    - 拷贝构造函数    - 赋值运算符</code></pre><h3 id="5-构造函数能否为虚函数，析构函数呢？"><a href="#5-构造函数能否为虚函数，析构函数呢？" class="headerlink" title="5. 构造函数能否为虚函数，析构函数呢？"></a>5. 构造函数能否为虚函数，析构函数呢？</h3><pre><code class="hljs">- 析构函数：    - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。    - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。    - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。- 构造函数：    - 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</code></pre><h3 id="6-构造函数调用顺序，析构函数呢？"><a href="#6-构造函数调用顺序，析构函数呢？" class="headerlink" title="6. 构造函数调用顺序，析构函数呢？"></a>6. 构造函数调用顺序，析构函数呢？</h3><pre><code class="hljs">- 调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。- 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。- 派生类的构造函数。- 析构函数与之相反。</code></pre><h3 id="7-拷贝构造函数中深拷贝和浅拷贝区别？"><a href="#7-拷贝构造函数中深拷贝和浅拷贝区别？" class="headerlink" title="7. 拷贝构造函数中深拷贝和浅拷贝区别？"></a>7. 拷贝构造函数中深拷贝和浅拷贝区别？</h3><pre><code class="hljs">- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。- 浅拷贝仅仅是拷贝指针字面值。- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</code></pre><h3 id="8-拷贝构造函数和赋值运算符重载的区别？"><a href="#8-拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="8. 拷贝构造函数和赋值运算符重载的区别？"></a>8. 拷贝构造函数和赋值运算符重载的区别？</h3><pre><code class="hljs">- 拷贝构造函数是函数，赋值运算符是运算符重载。- 拷贝构造函数会生成新的类对象，赋值运算符不能。- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现&quot;=&quot;的地方都是使用赋值运算符，如下：        Student s;        Student s1 = s;    // 调用拷贝构造函数        Student s2;        s2 = s;    // 赋值运算符操作**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**</code></pre><h3 id="9-虚函数和纯虚函数区别？"><a href="#9-虚函数和纯虚函数区别？" class="headerlink" title="9. 虚函数和纯虚函数区别？"></a>9. 虚函数和纯虚函数区别？</h3><pre><code class="hljs">- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</code></pre><h3 id="10-覆盖、重载和隐藏的区别？"><a href="#10-覆盖、重载和隐藏的区别？" class="headerlink" title="10. 覆盖、重载和隐藏的区别？"></a>10. 覆盖、重载和隐藏的区别？</h3><pre><code class="hljs"> - 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。 - 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。 - 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</code></pre><h3 id="11-在main执行之前执行的代码可能是什么？"><a href="#11-在main执行之前执行的代码可能是什么？" class="headerlink" title="11. 在main执行之前执行的代码可能是什么？"></a>11. 在main执行之前执行的代码可能是什么？</h3><pre><code class="hljs">- 全局对象的构造函数。</code></pre><h3 id="12-哪几种情况必须用到初始化成员列表？"><a href="#12-哪几种情况必须用到初始化成员列表？" class="headerlink" title="12. 哪几种情况必须用到初始化成员列表？"></a>12. 哪几种情况必须用到初始化成员列表？</h3><pre><code class="hljs">- 初始化一个const成员。- 初始化一个reference成员。- 调用一个基类的构造函数，而该函数有一组参数。- 调用一个数据成员对象的构造函数，而该函数有一组参数。</code></pre><h3 id="13-什么是虚指针？"><a href="#13-什么是虚指针？" class="headerlink" title="13. 什么是虚指针？"></a>13. 什么是虚指针？</h3><pre><code class="hljs">- 虚指针或虚函数指针是虚函数的实现细节。- 虚指针指向虚表结构。</code></pre><h3 id="14-重载和函数模板的区别？"><a href="#14-重载和函数模板的区别？" class="headerlink" title="14. 重载和函数模板的区别？"></a>14. 重载和函数模板的区别？</h3><pre><code class="hljs">- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。</code></pre><h3 id="15-this指针是什么？"><a href="#15-this指针是什么？" class="headerlink" title="15. this指针是什么？"></a>15. this指针是什么？</h3><pre><code class="hljs">- this指针是类的指针，指向对象的首地址。- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</code></pre><h3 id="16-类模板是什么？"><a href="#16-类模板是什么？" class="headerlink" title="16. 类模板是什么？"></a>16. 类模板是什么？</h3><pre><code class="hljs">- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</code></pre><h3 id="17-构造函数和析构函数调用时机？"><a href="#17-构造函数和析构函数调用时机？" class="headerlink" title="17. 构造函数和析构函数调用时机？"></a>17. 构造函数和析构函数调用时机？</h3><pre><code class="hljs">- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</code></pre><hr><h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a><span id = "stl">标准模板库</span></h2><p>STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：</p><ul><li><p>怎么用？</p><p>各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。</p></li><li><p>怎么实现？</p><p>本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。</p></li><li><p>如何避免错误？</p><p>在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。</p></li></ul><p><strong>string</strong></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        vector&lt;T&gt; vec;    插入元素：        vec.push_back(element);        vec.insert(iterator, element);    删除元素：        vec.pop_back();        vec.erase(iterator);    修改元素：        vec[position] = element;    遍历容器：        for(auto it = vec.begin(); it != vec.end(); ++it) &#123;......&#125;    其他：        vec.empty();    //判断是否空        vec.size();    // 实际元素        vec.capacity();    // 容器容量        vec.begin();    // 获得首迭代器        vec.end();    // 获得尾迭代器        vec.clear();    // 清空</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp">模拟Vector实现</a></p><ul><li><p>线性表，数组实现。</p><ul><li><p>支持随机访问。</p></li><li><p>插入删除操作需要大量移动数据。</p></li></ul></li><li><p>需要连续的物理存储空间。</p></li><li><p>每当大小不够时，重新分配内存（*2），并复制原内容。</p></li></ul><p>错误避免：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp">迭代器失效</a></p><ul><li><p>插入元素</p><ul><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ul></li><li><p>删除元素</p><ul><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ul></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        map&lt;T_key, T_value&gt; mymap;    插入元素：        mymap.insert(pair&lt;T_key, T_value&gt;(key, value));    // 同key不插入        mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value));    // 同key不插入        mymap[key] = value;    // 同key覆盖    删除元素：        mymap.erase(key);    // 按值删        mymap.erase(iterator);    // 按迭代器删    修改元素：        mymap[key] = new_value;    遍历容器：          for(auto it = mymap.begin(); it != mymap.end(); ++it) &#123;            cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;          &#125;</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/tree/master/code/RBTree">RBTree实现</a></p><ul><li><p>树状结构，RBTree实现。</p><ul><li><p>插入删除不需要数据复制。</p></li><li><p>操作复杂度仅跟树高有关。</p></li></ul></li><li><p>RBTree本身也是二叉排序树的一种，key值有序，且唯一。</p><ul><li>必须保证key可排序。</li></ul></li></ul><p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p><h3 id="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"><a href="#面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的" class="headerlink" title="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"></a><strong>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的</strong></h3><ol><li><p>它是二叉排序树（继承二叉排序树特显）：</p><ul><li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p></li></ul></li><li><p>它满足如下几点要求：</p><ul><li><p>树中所有节点非红即黑。</p></li><li><p>根节点必为黑节点。</p></li><li><p>红节点的子节点必为黑（黑节点子节点可为黑）。</p></li><li><p>从根到NULL的任何路径上黑结点数相同。</p></li></ul></li><li><p>查找时间一定可以控制在O(logn)。</p></li><li><p>红黑树的节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED = <span class="hljs-number">0</span>,<br>    BLACK = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span>*left, *right, *parent;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> data;<br>    Color color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p></li></ol><p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p><p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p><p><strong>set</strong></p><hr><h2 id="编译及调试"><a href="#编译及调试" class="headerlink" title="编译及调试"></a><span id = "other">编译及调试</span></h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h3><p>预处理</p><ul><li><p>展开所有的宏定义，完成字符常量替换。</p></li><li><p>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</p></li><li><p>处理#include指令，将被包含的文件插入到该指令所在位置。</p></li><li><p>过滤掉所有注释语句。</p></li><li><p>添加行号和文件名标识。</p></li><li><p>保留所有#pragma编译器指令。</p></li></ul><p>编译</p><ul><li><p>词法分析。</p></li><li><p>语法分析。</p></li><li><p>语义分析。</p></li><li><p>中间语言生成。</p></li><li><p>目标代码生成与优化。</p></li></ul><p>链接</p><p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p><ul><li><p>静态链接</p><p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。</p><p>既然静态链接是对目标文件的打包，这里介绍些打包命令。</p><pre><code class="hljs">gcc -c test1.c    // 生成test1.ogcc -c test2.c    // 生成test2.car cr libtest.a test1.o test2.o</code></pre><p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li><li><p>动态链接</p><p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p><p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p><pre><code class="hljs">gcc -fPIC -c test1.c gcc -fPIC -c test2.cgcc -shared test1.o test2.o -o libtest.so</code></pre><p>使用动态链接的用法也和静态链接相同。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li></ul><p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是&#x2F;usr&#x2F;lib，我们可以将库文件拷贝到那个目录下再链接。</p><p>比较静态库和动态库我们可以得到二者的优缺点。</p><ul><li><p>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</p></li><li><p>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</p></li><li><p>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</p></li></ul><p>makefile编写</p><p>对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。</p><ul><li><p>基本规则</p><pre><code class="hljs">A:B(tab)&lt;command&gt;</code></pre><p>其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。</p></li><li><p>变量</p><p>makefile的书写非常像shell脚本，可以在文件中定义”变量名 &#x3D; 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><p>符号解析</p><ul><li><p>可重定位目标文件</p><p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p></li><li><p>解析符号表</p><p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p></li></ul><p>重定位</p><ul><li><p>合并节</p><p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p></li><li><p>重定位符号引用</p><p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p></li></ul><p>可执行目标文件</p><ul><li><p>ELF头部</p><p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p></li><li><p>段头部表</p><p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p></li><li><p>其他段</p><p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p></li></ul><p>加载</p><ul><li><p>克隆</p><p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p></li><li><p>重新映射</p><p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p></li><li><p>虚页调入</p><p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux工具-Skill-Tree</title>
    <link href="/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/"/>
    <url>/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a><a href="http://man.linuxde.net/par/2">Linux工具</a></h1><blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C&#x2F;C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I&#x2F;O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#pro">开发及调试</a></td><td align="center"><a href="#file">文件处理</a></td><td align="center"><a href="#sysinfo">性能分析</a></td><td align="center"><a href="#net">网络工具</a></td><td align="center"><a href="#other">其他</a></td></tr></tbody></table><ul><li><p>开发及调试</p><ul><li>编辑器：vim</li><li>编译器：gcc&#x2F;g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li><p>文件处理</p><ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li><p>性能分析</p><ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li><p>网络工具</p><ul><li>网卡配置：ifconfig </li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li><p>其他</p><ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a><span id = "pro">开发及调试</span></h2><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><h3 id="1-编辑器：vim"><a href="#1-编辑器：vim" class="headerlink" title="1.  编辑器：vim"></a>1.  编辑器：vim</h3><pre><code class="hljs">- 服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。- [详见](http://coolshell.cn/articles/5426.html)</code></pre><h3 id="2-编译器：gcc-x2F-g"><a href="#2-编译器：gcc-x2F-g" class="headerlink" title="2. 编译器：gcc&#x2F;g++"></a>2. 编译器：gcc&#x2F;g++</h3><pre><code class="hljs">- C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。- [详见](http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html)</code></pre><h3 id="3-调试工具：gdb"><a href="#3-调试工具：gdb" class="headerlink" title="3. 调试工具：gdb"></a>3. 调试工具：gdb</h3><pre><code class="hljs">- 服务器端调试必备。- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)</code></pre><h3 id="4-查看依赖库：ldd"><a href="#4-查看依赖库：ldd" class="headerlink" title="4. 查看依赖库：ldd"></a>4. 查看依赖库：ldd</h3><pre><code class="hljs">- 程序依赖库查询<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ldd后接可执行文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><br>ldd a.out<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-二进制文件分析：objdump"><a href="#5-二进制文件分析：objdump" class="headerlink" title="5. 二进制文件分析：objdump"></a>5. 二进制文件分析：objdump</h3><pre><code class="hljs">- 反汇编，需要理解汇编语言- [详见](http://man.linuxde.net/objdump)</code></pre><h3 id="6-ELF文件格式分析：readelf"><a href="#6-ELF文件格式分析：readelf" class="headerlink" title="6. ELF文件格式分析：readelf"></a>6. ELF文件格式分析：readelf</h3><pre><code class="hljs">- 可以得到ELF文件各段内容，分析链接、符号表等需要用到- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html)</code></pre><h3 id="7-跟踪进程中系统调用：strace"><a href="#7-跟踪进程中系统调用：strace" class="headerlink" title="7. 跟踪进程中系统调用：strace"></a>7. 跟踪进程中系统调用：strace</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)</code></pre><h3 id="8-跟踪进程栈：pstack"><a href="#8-跟踪进程栈：pstack" class="headerlink" title="8. 跟踪进程栈：pstack"></a>8. 跟踪进程栈：pstack</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#)</code></pre><h3 id="9-进程内存映射：pmap"><a href="#9-进程内存映射：pmap" class="headerlink" title="9. 进程内存映射：pmap"></a>9. 进程内存映射：pmap</h3><pre><code class="hljs">- 显示进程内存映射<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-x显示扩展信息，后接进程pid</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Address: 内存开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示信息：</span><br>    Kbytes: 占用内存的字节数<br>    RSS: 保留内存的字节数<br>    Dirty: 脏页的字节数（包括共享和私有的）<br>    Mode: 内存的权限：read、write、execute、shared、private<br>    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）<br>    Device: 设备名 (major:minor)<br><br>pmap -x 12345<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a><span id = "file">文件处理</span></h2><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><h3 id="1-文件查找：find"><a href="#1-文件查找：find" class="headerlink" title="1. 文件查找：find"></a>1. 文件查找：find</h3><pre><code class="hljs">按名查找：- 查找具体文件（一般方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name *.cpp<br></code></pre></td></tr></table></figure>- 查找具体文件（正则方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-regex为正则查找，-iregex为忽略大小写的正则查找</span> <br>  <br>find -regex &quot;.*.cpp$&quot;<br></code></pre></td></tr></table></figure>定制查找：- 按类型查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">f(file)为文件，d(dictionary)为目录，l(<span class="hljs-built_in">link</span>)为链接</span><br>  <br>find . -type f<br></code></pre></td></tr></table></figure>- 按时间查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mtime为修改时间</span><br>  <br>find . -type f -atime -7<br></code></pre></td></tr></table></figure>- 按大小查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br>  <br>find . -type f -size -1k<br></code></pre></td></tr></table></figure>- 按权限查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-perm后接权限</span><br><br>find . -type -perm 644<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-文本搜索：grep"><a href="#2-文本搜索：grep" class="headerlink" title="2. 文本搜索：grep"></a>2. 文本搜索：grep</h3><pre><code class="hljs">- 模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容</span><br><br>grep &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 多个模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容</span><br><br>grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 输出信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><br>grep -n &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></code></pre><h3 id="3-排序：sort"><a href="#3-排序：sort" class="headerlink" title="3. 排序：sort"></a>3. 排序：sort</h3><pre><code class="hljs">- 文件内容行排序<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-k N表示按各行第N列进行排序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r(reverse)为逆序排序</span><br><br>sort -n -k 1 test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-转换：tr"><a href="#4-转换：tr" class="headerlink" title="4. 转换：tr"></a>4. 转换：tr</h3><pre><code class="hljs">- 字符替换<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将打开文件中所有目标字符替换</span><br><br>cat test | tr &#x27;1&#x27; &#x27;2&#x27;<br></code></pre></td></tr></table></figure>- 字符删除<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d删除(delete)</span><br><br>cat test | tr -d &#x27;1&#x27;<br></code></pre></td></tr></table></figure>- 字符压缩<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s位于后部</span><br><br>cat test | tr &#x27; &#x27; -s<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-按列切分文本：cut"><a href="#5-按列切分文本：cut" class="headerlink" title="5. 按列切分文本：cut"></a>5. 按列切分文本：cut</h3><pre><code class="hljs">- 截取特定列<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为具体列范围</span><br><br>cut -f 1,2 test<br></code></pre></td></tr></table></figure>- 指定界定符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d后接界定符</span><br><br>cut -f 2 -d &#x27;,&#x27; new<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-按列拼接文本：paste"><a href="#6-按列拼接文本：paste" class="headerlink" title="6. 按列拼接文本：paste"></a>6. 按列拼接文本：paste</h3><pre><code class="hljs">- 按列拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br><br>paste test1 test2<br></code></pre></td></tr></table></figure>- 指定界定符拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照-d之后给出的界定符拼接</span><br><br>paste test1 test2 -d &quot;,&quot;<br></code></pre></td></tr></table></figure></code></pre><h3 id="7-统计行和字符：wc"><a href="#7-统计行和字符：wc" class="headerlink" title="7. 统计行和字符：wc"></a>7. 统计行和字符：wc</h3><pre><code class="hljs"> - 基本统计 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><br>wc -l test<br></code></pre></td></tr></table></figure></code></pre><h3 id="8-文本替换：sed"><a href="#8-文本替换：sed" class="headerlink" title="8. 文本替换：sed"></a>8. 文本替换：sed</h3><pre><code class="hljs">- 区别于上面的命令，sed是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9104.html)</code></pre><h3 id="9-数据流处理：awk"><a href="#9-数据流处理：awk" class="headerlink" title="9. 数据流处理：awk"></a>9. 数据流处理：awk</h3><pre><code class="hljs">- 区别于上面的命令，awk是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9070.html)</code></pre><hr><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><span id = "sysinfo">系统信息</span></h2><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I&#x2F;O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><h3 id="1-进程查询：ps"><a href="#1-进程查询：ps" class="headerlink" title="1. 进程查询：ps"></a>1. 进程查询：ps</h3><pre><code class="hljs">- 查看正在运行进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><br>ps -ef<br></code></pre></td></tr></table></figure>- 以完整格式显示所有进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息</span><br><br>ps -ajx<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-进程监控：top"><a href="#2-进程监控：top" class="headerlink" title="2. 进程监控：top"></a>2. 进程监控：top</h3><pre><code class="hljs">- 显示实时进程信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%<span class="hljs-built_in">id</span>表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><br>top<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-打开文件查询：lsof"><a href="#3-打开文件查询：lsof" class="headerlink" title="3. 打开文件查询：lsof"></a>3. 打开文件查询：lsof</h3><ul><li>查看占用某端口的进程</li></ul><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br>   <br>lsof -i:53<br></code></pre></td></tr></table></figure>- 查看某用户打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-u(user)为用户，后接用户名</span><br>   <br>lsof -u inx<br></code></pre></td></tr></table></figure>- 查看指定进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(process)为进程，后接进程PID</span><br>   <br>lsof -p 12345<br></code></pre></td></tr></table></figure>- 查看指定目录下被进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>   <br>lsof +d /test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-内存使用量：free"><a href="#4-内存使用量：free" class="headerlink" title="4. 内存使用量：free"></a>4. 内存使用量：free</h3><pre><code class="hljs">- 内存使用量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><br>free<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-监控性能指标：sar"><a href="#5-监控性能指标：sar" class="headerlink" title="5. 监控性能指标：sar"></a>5. 监控性能指标：sar</h3><pre><code class="hljs">监控CPU- 监控CPU负载<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里<span class="hljs-string">&quot;1&quot;</span>表示采样时间间隔是1秒，这里<span class="hljs-string">&quot;2&quot;</span>表示采样次数为2</span><br><br>sar -q 1 2<br></code></pre></td></tr></table></figure>- 监控CPU使用率<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示CPU使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span><br><br>sar -u 1 2<br></code></pre></td></tr></table></figure>监控内存- 查询内存<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示内存使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span> <br><br>sar -r 1 2<br></code></pre></td></tr></table></figure>- 页面交换查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">参数意义同上</span><br><br>sar -W 1 2<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a><span id = "net">网络工具</span></h2><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><h3 id="1-网卡配置（链路层）：ifconfig"><a href="#1-网卡配置（链路层）：ifconfig" class="headerlink" title="1. 网卡配置（链路层）：ifconfig"></a>1. 网卡配置（链路层）：ifconfig</h3><pre><code class="hljs">- 显示设备信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示已激活的网络设备信息</span><br><br>ifconfig<br></code></pre></td></tr></table></figure>- 启动关闭指定网卡<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">up为打开，down为关闭</span><br><br>ifconfig eth0 up<br></code></pre></td></tr></table></figure>- 配置IP地址<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为配置的IP地址</span><br><br>ifconfig eth0 192.168.1.1<br></code></pre></td></tr></table></figure>- 设置最大传输单元<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">前一个参数为具体网卡，后面为MTU的大小<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置链路层MTU值，通常为1500</span><br><br>ifconfig eth0 mtu 1500<br></code></pre></td></tr></table></figure>- 启用和关闭ARP协议<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat"><a href="#2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat" class="headerlink" title="2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat"></a>2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat</h3><pre><code class="hljs">- 网络接口信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示网卡信息，可结合ifconfig学习</span><br><br>netstat -i<br></code></pre></td></tr></table></figure>- 列出端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-l(listening)表示正在监听的端口</span><br><br>netstat -at<br></code></pre></td></tr></table></figure>- 显示端口统计信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(status)显示各协议信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><br>netstat -s<br></code></pre></td></tr></table></figure>- 显示使用某协议的应用名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><br>netstat -pt<br></code></pre></td></tr></table></figure>- 查找指定进程、端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个操作可以用lsof替代</span><br><br>netstat -ap | grep ssh<br>netstat -an | grep &#x27;:80&#x27;<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-查看路由表（网络层IP协议）：route"><a href="#3-查看路由表（网络层IP协议）：route" class="headerlink" title="3. 查看路由表（网络层IP协议）：route"></a>3. 查看路由表（网络层IP协议）：route</h3><pre><code class="hljs">- 查看路由信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过netstat -r(route)得到同样的路由表</span><br><br>route<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-检查网络连通性（网络层ICMP协议）：ping"><a href="#4-检查网络连通性（网络层ICMP协议）：ping" class="headerlink" title="4. 检查网络连通性（网络层ICMP协议）：ping"></a>4. 检查网络连通性（网络层ICMP协议）：ping</h3><pre><code class="hljs">- 检查是否连通<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">主要功能是检测网络连通性</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><br>ping baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-转发路径（网络层ICMP协议）：traceroute"><a href="#5-转发路径（网络层ICMP协议）：traceroute" class="headerlink" title="5. 转发路径（网络层ICMP协议）：traceroute"></a>5. 转发路径（网络层ICMP协议）：traceroute</h3><pre><code class="hljs">- 文件包途径的IP<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span></span><br><br>traceroute baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-网络Debug分析（网络层-x2F-传输层）：nc"><a href="#6-网络Debug分析（网络层-x2F-传输层）：nc" class="headerlink" title="6. 网络Debug分析（网络层&#x2F;传输层）：nc"></a>6. 网络Debug分析（网络层&#x2F;传输层）：nc</h3><pre><code class="hljs">- 端口扫描<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">黑客很喜欢</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描某服务器端口使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v(view)显示指令执行过程，-w(<span class="hljs-built_in">wait</span>)设置超时时长</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为扫描的端口范围</span> <br><br>nc -v -w 1 baidu.com  -z 75-1000<br></code></pre></td></tr></table></figure>- [其他详见](https://www.oschina.net/translate/linux-netcat-command)</code></pre><h3 id="7-命令行抓包（网络层-x2F-传输层）：tcpdump"><a href="#7-命令行抓包（网络层-x2F-传输层）：tcpdump" class="headerlink" title="7. 命令行抓包（网络层&#x2F;传输层）：tcpdump"></a>7. 命令行抓包（网络层&#x2F;传输层）：tcpdump</h3><pre><code class="hljs">- 抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。- [详见](http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)</code></pre><h3 id="8-域名解析工具（应用层DNS协议）：dig"><a href="#8-域名解析工具（应用层DNS协议）：dig" class="headerlink" title="8. 域名解析工具（应用层DNS协议）：dig"></a>8. 域名解析工具（应用层DNS协议）：dig</h3><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">应用层，DNS</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析过程中涉及的各级DNS服务器地址</span><br><br>dig baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="9-网络请求（应用层）：curl"><a href="#9-网络请求（应用层）：curl" class="headerlink" title="9. 网络请求（应用层）：curl"></a>9. 网络请求（应用层）：curl</h3><pre><code class="hljs">- [详见](http://www.cnblogs.com/gbyukg/p/3326825.html)</code></pre><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><span id = "other">其他</span></h2><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><h3 id="1-终止进程：kill"><a href="#1-终止进程：kill" class="headerlink" title="1. 终止进程：kill"></a>1. 终止进程：kill</h3><pre><code class="hljs">- 杀死具体进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加具体进程PID</span><br><br>kill 12345<br></code></pre></td></tr></table></figure>- 杀死某进程相关进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上<span class="hljs-string">&quot;-9&quot;</span>杀死某进程相关进程</span><br><br>kill -9 12345<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-修改文件权限：chmod"><a href="#2-修改文件权限：chmod" class="headerlink" title="2. 修改文件权限：chmod"></a>2. 修改文件权限：chmod</h3><pre><code class="hljs">- 更改文件权限<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件可以有三种权限，r(<span class="hljs-built_in">read</span>)，w(write)，x(execute)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><br>chmod u+r file<br>chmod 777 file<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-创建链接：ln"><a href="#3-创建链接：ln" class="headerlink" title="3. 创建链接：ln"></a>3. 创建链接：ln</h3><pre><code class="hljs">- 创建硬链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><br>ln file1 file2<br></code></pre></td></tr></table></figure>- 创建软（符号链接）链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><br>ln -s file1 file2<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-显示文件尾：tail"><a href="#4-显示文件尾：tail" class="headerlink" title="4. 显示文件尾：tail"></a>4. 显示文件尾：tail</h3><pre><code class="hljs">- 查看文件尾部<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志时常用</span><br><br>tail -f test<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-版本控制：git"><a href="#5-版本控制：git" class="headerlink" title="5. 版本控制：git"></a>5. 版本控制：git</h3><pre><code class="hljs">- 版本控制最好用的软件，没有之一。至少要知道&quot;git init&quot;，&quot;git add&quot;，&quot;git commit&quot;，&quot;git pull&quot;，&quot;git push&quot;几个命令。- [详见](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/)</code></pre><h3 id="6-设置别名：alias"><a href="#6-设置别名：alias" class="headerlink" title="6. 设置别名：alias"></a>6. 设置别名：alias</h3><pre><code class="hljs">- 常用命令添加别名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;.bashrc&quot;</span>文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><br>alias rm=&#x27;rm -i&#x27;<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed">代码</a></p><h3 id="1-单步调试：gdb"><a href="#1-单步调试：gdb" class="headerlink" title="1. 单步调试：gdb"></a>1. 单步调试：gdb</h3><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><h3 id="2-动态库依赖：ldd"><a href="#2-动态库依赖：ldd" class="headerlink" title="2. 动态库依赖：ldd"></a>2. 动态库依赖：ldd</h3><ul><li><p>命令：ldd .&#x2F;server</p></li><li><p>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</p></li></ul><h3 id="3-性能分析：top"><a href="#3-性能分析：top" class="headerlink" title="3. 性能分析：top"></a>3. 性能分析：top</h3><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><h3 id="4-系统调用：strace"><a href="#4-系统调用：strace" class="headerlink" title="4. 系统调用：strace"></a>4. 系统调用：strace</h3><ul><li><p>命令：strace .&#x2F;server</p></li><li><p>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</p></li></ul><h3 id="5-打印进程：ps"><a href="#5-打印进程：ps" class="headerlink" title="5. 打印进程：ps"></a>5. 打印进程：ps</h3><ul><li><p>命令：ps -ejH</p></li><li><p>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</p></li></ul><h3 id="6-打开文件：lsof"><a href="#6-打开文件：lsof" class="headerlink" title="6. 打开文件：lsof"></a>6. 打开文件：lsof</h3><ul><li><p>lsof -i:3000</p></li><li><p>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</p></li></ul><h3 id="7-修改权限：chmod"><a href="#7-修改权限：chmod" class="headerlink" title="7. 修改权限：chmod"></a>7. 修改权限：chmod</h3><ul><li><p>chmod 000 .&#x2F;index.html</p></li><li><p>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000&#x2F;index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</p></li></ul><h3 id="8-网卡信息：ifconfig"><a href="#8-网卡信息：ifconfig" class="headerlink" title="8. 网卡信息：ifconfig"></a>8. 网卡信息：ifconfig</h3><ul><li><p>ifconfig</p></li><li><p>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</p></li></ul><h3 id="9-抓包分析：tcpdump"><a href="#9-抓包分析：tcpdump" class="headerlink" title="9. 抓包分析：tcpdump"></a>9. 抓包分析：tcpdump</h3><ul><li><p>tcpdump -i eth0 port 3000</p></li><li><p>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式-url</title>
    <link href="/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/"/>
    <url>/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希表和完美哈希"><a href="#哈希表和完美哈希" class="headerlink" title="哈希表和完美哈希"></a><a href="https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html#perfect_hashing">哈希表和完美哈希</a></h2><h2 id="布隆过滤器的原理与实现"><a href="#布隆过滤器的原理与实现" class="headerlink" title="布隆过滤器的原理与实现"></a><a href="https://blog.51cto.com/u_12824426/2555710">布隆过滤器的原理与实现</a></h2><h2 id="布隆过滤器-阿里云开发者社区"><a href="#布隆过滤器-阿里云开发者社区" class="headerlink" title="布隆过滤器-阿里云开发者社区"></a><a href="https://developer.aliyun.com/article/773205">布隆过滤器-阿里云开发者社区</a></h2><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a>分布式面试题</h1><h2 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h2><h2 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h2><h2 id="分布式面试题-1"><a href="#分布式面试题-1" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h2>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式</title>
    <link href="/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h1 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h1><h1 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h1><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h1>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-url</title>
    <link href="/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/"/>
    <url>/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手-x2F-四次挥手"><a href="#三次握手-x2F-四次挥手" class="headerlink" title="三次握手&#x2F;四次挥手"></a>三次握手&#x2F;四次挥手</h1><h2 id="TCP的三次握手四次挥手理解及面试题"><a href="#TCP的三次握手四次挥手理解及面试题" class="headerlink" title="TCP的三次握手四次挥手理解及面试题"></a><a href="https://www.cnblogs.com/xp1315458571/articles/11361140.html">TCP的三次握手四次挥手理解及面试题</a></h2><h2 id="三次握手-x2F-四次挥手中的丢失情况及处理机制"><a href="#三次握手-x2F-四次挥手中的丢失情况及处理机制" class="headerlink" title="三次握手&#x2F;四次挥手中的丢失情况及处理机制"></a><a href="https://blog.51cto.com/u_14888059/3812405#:~:text=%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%20SYN-ACK%20%E6%8A%A5%E6%96%87%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9B%9E%E4%B8%80%E4%B8%AA,ACK%20%E6%8A%A5%E6%96%87%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E5%85%A5%E5%88%B0%20ESTABLISH%20%E7%8A%B6%E6%80%81%E3%80%82">三次握手&#x2F;四次挥手中的丢失情况及处理机制</a></h2><h1 id="滑窗-x2F-流控-x2F-拥塞"><a href="#滑窗-x2F-流控-x2F-拥塞" class="headerlink" title="滑窗&#x2F;流控&#x2F;拥塞"></a>滑窗&#x2F;流控&#x2F;拥塞</h1><h2 id="关于TCP乱序和重传的问题"><a href="#关于TCP乱序和重传的问题" class="headerlink" title="关于TCP乱序和重传的问题"></a><a href="https://blog.csdn.net/cws1214/article/details/52430554">关于TCP乱序和重传的问题</a></h2><h2 id="HTTP-与TCP中Keep-Alive机制的区别"><a href="#HTTP-与TCP中Keep-Alive机制的区别" class="headerlink" title="HTTP 与TCP中Keep-Alive机制的区别"></a><a href="https://cloud.tencent.com/developer/article/1430022">HTTP 与TCP中Keep-Alive机制的区别</a></h2><h2 id="HTTP-keep-alive和TCP-keepalive的区别"><a href="#HTTP-keep-alive和TCP-keepalive的区别" class="headerlink" title="HTTP keep-alive和TCP keepalive的区别"></a><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别</a></h2><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-x2F-2协议“多路复用”实现原理"><a href="#HTTP-x2F-2协议“多路复用”实现原理" class="headerlink" title="HTTP&#x2F;2协议“多路复用”实现原理"></a><a href="https://segmentfault.com/a/1190000016975064">HTTP&#x2F;2协议“多路复用”实现原理</a></h2><h2 id="Http发展历程-多路复用"><a href="#Http发展历程-多路复用" class="headerlink" title="Http发展历程-多路复用"></a><a href="https://juejin.cn/post/6844903935648497678">Http发展历程-多路复用</a></h2><h2 id="WebSocket-是什么原理？为什么可以实现持久连接？"><a href="#WebSocket-是什么原理？为什么可以实现持久连接？" class="headerlink" title="WebSocket 是什么原理？为什么可以实现持久连接？"></a><a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理？为什么可以实现持久连接？</a></h2><h2 id="POST-PUT和PATCH的区别"><a href="#POST-PUT和PATCH的区别" class="headerlink" title="POST,PUT和PATCH的区别"></a><a href="https://www.jianshu.com/p/bee85cf4e33a">POST,PUT和PATCH的区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-url</title>
    <link href="/2022/05/07/Redis-url/"/>
    <url>/2022/05/07/Redis-url/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis面试题-笔经面经-牛客网"><a href="#Redis面试题-笔经面经-牛客网" class="headerlink" title="Redis面试题_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/837063?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis面试题_笔经面经_牛客网</a></h2><h2 id="Redis超高频面试题和参考答案汇总！-笔经面经-牛客网"><a href="#Redis超高频面试题和参考答案汇总！-笔经面经-牛客网" class="headerlink" title="Redis超高频面试题和参考答案汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/941154?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis超高频面试题和参考答案汇总！_笔经面经_牛客网</a></h2><h2 id="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"><a href="#最全面的Redis缓存雪崩、击穿、穿透问题解决方案" class="headerlink" title="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"></a><a href="https://segmentfault.com/a/1190000039300423">最全面的Redis缓存雪崩、击穿、穿透问题解决方案</a></h2><h2 id="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"><a href="#Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级" class="headerlink" title="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"></a><a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></h2><h2 id="Redis-主从、哨兵和集群-区别"><a href="#Redis-主从、哨兵和集群-区别" class="headerlink" title="Redis 主从、哨兵和集群 区别"></a><a href="https://blog.csdn.net/u014527619/article/details/88232178">Redis 主从、哨兵和集群 区别</a></h2><h2 id="Memcached与Redis有什么区别"><a href="#Memcached与Redis有什么区别" class="headerlink" title="Memcached与Redis有什么区别"></a><a href="https://segmentfault.com/a/1190000023217491">Memcached与Redis有什么区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-url</title>
    <link href="/2022/05/07/Mysql-url/"/>
    <url>/2022/05/07/Mysql-url/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><h2 id="MySQL超高频面试题汇总！-笔经面经-牛客网"><a href="#MySQL超高频面试题汇总！-笔经面经-牛客网" class="headerlink" title="MySQL超高频面试题汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/922991?type=post&order=jing&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1650335022589">MySQL超高频面试题汇总！_笔经面经_牛客网</a></h2><h2 id="B-树，B树，聚集索引，非聚集索引"><a href="#B-树，B树，聚集索引，非聚集索引" class="headerlink" title="B+树，B树，聚集索引，非聚集索引"></a><a href="https://blog.csdn.net/weixin_30565199/article/details/95851132">B+树，B树，聚集索引，非聚集索引</a></h2><h2 id="MySQL为什么用B-树存储索引？"><a href="#MySQL为什么用B-树存储索引？" class="headerlink" title="MySQL为什么用B+树存储索引？"></a><a href="https://blog.csdn.net/dl674756321/article/details/102987984">MySQL为什么用B+树存储索引？</a></h2><h2 id="高度为3的B-树能存多少行数据"><a href="#高度为3的B-树能存多少行数据" class="headerlink" title="高度为3的B+树能存多少行数据?"></a><a href="https://www.1024sou.com/article/40.html">高度为3的B+树能存多少行数据?</a></h2><h1 id="模糊查询与联合索引"><a href="#模糊查询与联合索引" class="headerlink" title="模糊查询与联合索引"></a>模糊查询与联合索引</h1><h2 id="LIKE-模糊查询概述"><a href="#LIKE-模糊查询概述" class="headerlink" title="LIKE%模糊查询概述"></a><a href="https://blog.csdn.net/weixin_34081595/article/details/93658047?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">LIKE%模糊查询概述</a></h2><h2 id="LIKE-开头的模糊查询的解决方法"><a href="#LIKE-开头的模糊查询的解决方法" class="headerlink" title="LIKE%开头的模糊查询的解决方法"></a><a href="https://blog.csdn.net/qq_42539533/article/details/93137526?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">LIKE%开头的模糊查询的解决方法</a></h2><h2 id="联合索引在B-树上的存储结构及数据查找方式"><a href="#联合索引在B-树上的存储结构及数据查找方式" class="headerlink" title="联合索引在B+树上的存储结构及数据查找方式"></a><a href="https://www.cnblogs.com/ibigboy/p/12373978.html">联合索引在B+树上的存储结构及数据查找方式</a></h2><h2 id="索引最左前缀匹配原则"><a href="#索引最左前缀匹配原则" class="headerlink" title="索引最左前缀匹配原则"></a><a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">索引最左前缀匹配原则</a></h2><h1 id="事务与MVCC机制"><a href="#事务与MVCC机制" class="headerlink" title="事务与MVCC机制"></a>事务与MVCC机制</h1><h2 id="MySql解决幻读-x2F-不可重复读以及MVCC机制"><a href="#MySql解决幻读-x2F-不可重复读以及MVCC机制" class="headerlink" title="MySql解决幻读&#x2F;不可重复读以及MVCC机制"></a><a href="https://blog.csdn.net/qq_42799615/article/details/110942949">MySql解决幻读&#x2F;不可重复读以及MVCC机制</a></h2><h2 id="MySQL-如何解决幻读（MVCC-原理分析）"><a href="#MySQL-如何解决幻读（MVCC-原理分析）" class="headerlink" title="MySQL 如何解决幻读（MVCC 原理分析）"></a><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析）</a></h2><h2 id="从ReadView深入理解MySql-MVCC原理"><a href="#从ReadView深入理解MySql-MVCC原理" class="headerlink" title="从ReadView深入理解MySql MVCC原理"></a><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></h2><h2 id="MySQL间隙锁、Next-Key-Lock主要知识点"><a href="#MySQL间隙锁、Next-Key-Lock主要知识点" class="headerlink" title="MySQL间隙锁、Next-Key Lock主要知识点"></a><a href="https://www.jianshu.com/p/d5c2613cbb81">MySQL间隙锁、Next-Key Lock主要知识点</a></h2><h1 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h1><h2 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a><a href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别（9个不同点）</a></h2><h2 id="Innodb-Purge简介"><a href="#Innodb-Purge简介" class="headerlink" title="Innodb Purge简介"></a><a href="https://juejin.cn/post/6844903686393561096">Innodb Purge简介</a></h2><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="我终于看懂了HBase"><a href="#我终于看懂了HBase" class="headerlink" title="我终于看懂了HBase"></a><a href="https://zhuanlan.zhihu.com/p/145551967">我终于看懂了HBase</a></h2><h2 id="入门HBase，看这一篇就够了"><a href="#入门HBase，看这一篇就够了" class="headerlink" title="入门HBase，看这一篇就够了"></a><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></h2>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++-url</title>
    <link href="/2022/05/07/C++-url/"/>
    <url>/2022/05/07/C++-url/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="C-多态与虚函数"><a href="#C-多态与虚函数" class="headerlink" title="C++多态与虚函数"></a><a href="http://c.biancheng.net/cplus/polymorphism/">C++多态与虚函数</a></h2><h1 id="C-高级特性"><a href="#C-高级特性" class="headerlink" title="C++高级特性"></a>C++高级特性</h1><h2 id="智能指针详解-博客园"><a href="#智能指针详解-博客园" class="headerlink" title="智能指针详解-博客园"></a><a href="https://www.cnblogs.com/linuxandmcu/p/10409723.html">智能指针详解-博客园</a></h2><h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a><a href="http://c.biancheng.net/view/7829.html">C++11右值引用</a></h2><h2 id="右值引用-amp-转移语义-amp-完美转发"><a href="#右值引用-amp-转移语义-amp-完美转发" class="headerlink" title="右值引用 &amp; 转移语义 &amp; 完美转发"></a><a href="https://www.irimsky.top/archives/296/">右值引用 &amp; 转移语义 &amp; 完美转发</a></h2><h1 id="STL原理"><a href="#STL原理" class="headerlink" title="STL原理"></a>STL原理</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="deque容器底层实现原理（深度剖析）"><a href="#deque容器底层实现原理（深度剖析）" class="headerlink" title="deque容器底层实现原理（深度剖析）"></a><a href="http://c.biancheng.net/view/6908.html">deque容器底层实现原理（深度剖析）</a></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-url</title>
    <link href="/2022/05/07/Linux-url/"/>
    <url>/2022/05/07/Linux-url/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h1><h2 id="WebServer项目概述-ZWiley的随记"><a href="#WebServer项目概述-ZWiley的随记" class="headerlink" title="WebServer项目概述 - ZWiley的随记"></a><a href="https://zwiley.github.io/mybook/webserver/0%20%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/">WebServer项目概述 - ZWiley的随记</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（一）"><a href="#WebServer服务器项目可能会被问到的问题（一）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（一）"></a><a href="https://www.nowcoder.com/discuss/934904">WebServer服务器项目可能会被问到的问题（一）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（二）"><a href="#WebServer服务器项目可能会被问到的问题（二）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（二）"></a><a href="https://www.nowcoder.com/discuss/939267?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题（二）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题-三-完结"><a href="#WebServer服务器项目可能会被问到的问题-三-完结" class="headerlink" title="WebServer服务器项目可能会被问到的问题(三)完结"></a><a href="https://www.nowcoder.com/discuss/945403?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题(三)完结</a></h2><h2 id="Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读"><a href="#Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读" class="headerlink" title="Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读"></a><a href="https://read.douban.com/reader/ebook/15233070/?dcs=bookshelf">Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读</a></h2><h2 id="qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器"><a href="#qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器" class="headerlink" title="qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器"></a><a href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器</a></h2><h2 id="彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云"><a href="#彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云" class="headerlink" title="彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云"></a><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云</a></h2><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金"><a href="#虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金" class="headerlink" title="虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金"></a><a href="https://juejin.cn/post/6990237426903957540">虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金</a></h2><h2 id="linux下进程和线程状态查看"><a href="#linux下进程和线程状态查看" class="headerlink" title="linux下进程和线程状态查看"></a><a href="https://blog.csdn.net/huangjin0507/article/details/77848386">linux下进程和线程状态查看</a></h2><h2 id="socket阻塞和非阻塞有哪些影响-CSDN"><a href="#socket阻塞和非阻塞有哪些影响-CSDN" class="headerlink" title="socket阻塞和非阻塞有哪些影响-CSDN"></a><a href="https://blog.csdn.net/mayue_web/article/details/82873115">socket阻塞和非阻塞有哪些影响-CSDN</a></h2><h2 id="句柄和文件描述符-简书"><a href="#句柄和文件描述符-简书" class="headerlink" title="句柄和文件描述符-简书"></a><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符-简书</a></h2><h2 id="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"><a href="#Linux文件存储结构，包括目录项、inode、数据块-C语言中文网" class="headerlink" title="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"></a><a href="http://c.biancheng.net/cpp/html/2780.html">Linux文件存储结构，包括目录项、inode、数据块-C语言中文网</a></h2><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令与shell-菜鸟教程"><a href="#Linux命令与shell-菜鸟教程" class="headerlink" title="Linux命令与shell- 菜鸟教程"></a><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令与shell- 菜鸟教程</a></h2><h2 id="Linux命令大全教程"><a href="#Linux命令大全教程" class="headerlink" title="Linux命令大全教程"></a><a href="https://www.yiibai.com/linux/lsof.html">Linux命令大全教程</a></h2><h2 id="shell脚本指南"><a href="#shell脚本指南" class="headerlink" title="shell脚本指南"></a><a href="http://c.biancheng.net/view/706.html">shell脚本指南</a></h2><h2 id="linux的top命令参数详解-博客园"><a href="#linux的top命令参数详解-博客园" class="headerlink" title="linux的top命令参数详解-博客园"></a><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html">linux的top命令参数详解-博客园</a></h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>校招面经-url</title>
    <link href="/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/"/>
    <url>/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="十道海量数据处理面试题与十个方法大总结"><a href="#十道海量数据处理面试题与十个方法大总结" class="headerlink" title="十道海量数据处理面试题与十个方法大总结"></a><a href="https://blog.csdn.net/v_JULY_v/article/details/6279498?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">十道海量数据处理面试题与十个方法大总结</a></h2><h2 id="面试题：从n个数中找出第K大的数"><a href="#面试题：从n个数中找出第K大的数" class="headerlink" title="面试题：从n个数中找出第K大的数"></a><a href="https://blog.csdn.net/orangefly0214/article/details/86527462">面试题：从n个数中找出第K大的数</a></h2><h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="互联网大厂最爱问的智力题总结（带详细答案）"><a href="#互联网大厂最爱问的智力题总结（带详细答案）" class="headerlink" title="互联网大厂最爱问的智力题总结（带详细答案）"></a><a href="https://www.nowcoder.com/discuss/754712?type=1&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack">互联网大厂最爱问的智力题总结（带详细答案）</a></h2><h1 id="常见排序方法实现"><a href="#常见排序方法实现" class="headerlink" title="常见排序方法实现"></a>常见排序方法实现</h1><h2 id="创建堆，堆排序的详细实现过程，C-完整代码"><a href="#创建堆，堆排序的详细实现过程，C-完整代码" class="headerlink" title="创建堆，堆排序的详细实现过程，C++完整代码"></a><a href="https://blog.csdn.net/ahfytao/article/details/47681221">创建堆，堆排序的详细实现过程，C++完整代码</a></h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bigsai/p/13396391.html">桶排序</a></h2><h1 id="C-面经"><a href="#C-面经" class="headerlink" title="C++面经"></a>C++面经</h1><h2 id="C-x2F-C-技术面试基础知识总结-huihut"><a href="#C-x2F-C-技术面试基础知识总结-huihut" class="headerlink" title="C&#x2F;C++ 技术面试基础知识总结-huihut"></a><a href="https://interview.huihut.com/#/">C&#x2F;C++ 技术面试基础知识总结-huihut</a></h2><h2 id="【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网"><a href="#【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网" class="headerlink" title="【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网"></a><a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网</a></h2><h2 id="牛客网收藏面经"><a href="#牛客网收藏面经" class="headerlink" title="牛客网收藏面经"></a><a href="https://www.nowcoder.com/profile/674401673/following-posts">牛客网收藏面经</a></h2><h2 id="GoGoCoder面经"><a href="#GoGoCoder面经" class="headerlink" title="GoGoCoder面经"></a><a href="https://gogocoder.com/face">GoGoCoder面经</a></h2><h2 id="C-工程师精选面经汇总-校招实习社招-牛客网-牛客网"><a href="#C-工程师精选面经汇总-校招实习社招-牛客网-牛客网" class="headerlink" title="C++工程师精选面经汇总_校招实习社招_牛客网_牛客网"></a><a href="https://www.nowcoder.com/discuss/experience?tagId=640">C++工程师精选面经汇总_校招实习社招_牛客网_牛客网</a></h2><h1 id="Java面经"><a href="#Java面经" class="headerlink" title="Java面经"></a>Java面经</h1><h2 id="Java-全栈知识体系"><a href="#Java-全栈知识体系" class="headerlink" title="Java 全栈知识体系"></a><a href="https://pdai.tech/">Java 全栈知识体系</a></h2>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大厂笔试参考资料-url</title>
    <link href="/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/"/>
    <url>/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/</url>
    
    <content type="html"><![CDATA[<h1 id="ACM输入输出"><a href="#ACM输入输出" class="headerlink" title="ACM输入输出"></a>ACM输入输出</h1><h2 id="ACM输入方式-C-代码先锋网"><a href="#ACM输入方式-C-代码先锋网" class="headerlink" title="ACM输入方式-C++ - 代码先锋网"></a><a href="https://www.codeleading.com/article/50865910043/">ACM输入方式-C++ - 代码先锋网</a></h2><h2 id="C-使用stringstream与getline-分割字符串"><a href="#C-使用stringstream与getline-分割字符串" class="headerlink" title="C++使用stringstream与getline()分割字符串"></a><a href="https://blog.csdn.net/qq_36743440/article/details/91999615">C++使用stringstream与getline()分割字符串</a></h2><h2 id="C-中的cin以及stringstream"><a href="#C-中的cin以及stringstream" class="headerlink" title="C++中的cin以及stringstream"></a><a href="https://blog.csdn.net/flow_specter/article/details/116503515">C++中的cin以及stringstream</a></h2><h2 id="ACM模式数组构建二叉树"><a href="#ACM模式数组构建二叉树" class="headerlink" title="ACM模式数组构建二叉树"></a><a href="https://blog.csdn.net/m0_47240785/article/details/123406393">ACM模式数组构建二叉树</a></h2><h2 id="完全二叉树的顺序储存结构（C-完整代码）"><a href="#完全二叉树的顺序储存结构（C-完整代码）" class="headerlink" title="完全二叉树的顺序储存结构（C++完整代码）"></a><a href="https://blog.csdn.net/qq_52284035/article/details/118025460">完全二叉树的顺序储存结构（C++完整代码）</a></h2><h1 id="STL基础及模板"><a href="#STL基础及模板" class="headerlink" title="STL基础及模板"></a>STL基础及模板</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="C-STL中Map的按Key排序和按Value排序"><a href="#C-STL中Map的按Key排序和按Value排序" class="headerlink" title="C++ STL中Map的按Key排序和按Value排序"></a><a href="https://blog.csdn.net/iicy266/article/details/11906189">C++ STL中Map的按Key排序和按Value排序</a></h2><h2 id="优先队列详解-ACM例题分析"><a href="#优先队列详解-ACM例题分析" class="headerlink" title="优先队列详解+ACM例题分析"></a><a href="https://blog.csdn.net/qq_38492462/article/details/78631091">优先队列详解+ACM例题分析</a></h2><h1 id="大厂笔试题解"><a href="#大厂笔试题解" class="headerlink" title="大厂笔试题解"></a>大厂笔试题解</h1><h2 id="4-6-华为笔试题解-笔经面经-牛客网"><a href="#4-6-华为笔试题解-笔经面经-牛客网" class="headerlink" title="4.6 华为笔试题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/924780">4.6 华为笔试题解_笔经面经_牛客网</a></h2><h2 id="腾讯2022实习生笔试情况与题解-笔经面经-牛客网"><a href="#腾讯2022实习生笔试情况与题解-笔经面经-牛客网" class="headerlink" title="腾讯2022实习生笔试情况与题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/940859">腾讯2022实习生笔试情况与题解_笔经面经_牛客网</a></h2><h2 id="拓扑排序-知乎"><a href="#拓扑排序-知乎" class="headerlink" title="拓扑排序 - 知乎"></a><a href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序 - 知乎</a></h2>]]></content>
    
    
    <categories>
      
      <category>大厂笔试参考资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件描述符及三种拷贝命令</title>
    <link href="/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-文件描述符概念"><a href="#一-文件描述符概念" class="headerlink" title="一. 文件描述符概念"></a>一. 文件描述符概念</h1><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符</p></blockquote><p><strong>关于文件描述符，Linux内核维护了3个数据结构</strong></p><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137792.png"><br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137233.gif"></p><ul><li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的</li><li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样(概率很低)</li><li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况</li></ul><hr><h1 id="二-Linux文件和目录"><a href="#二-Linux文件和目录" class="headerlink" title="二. Linux文件和目录"></a>二. Linux文件和目录</h1><p>Linux文件是树形结构，inode是平坦结构，通过inode-&gt;i_mode字段，即S_ISREG、S_ISDIR两个宏判断是哪个类型。</p><ul><li><p>普通文件：<strong>inode</strong>里面存储元数据，inode索引到block，block存储数据</p></li><li><p>目录文件：inode索引到block，block中存储许多dirent目录条目，即名字到inode number的映射表<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138975.webp"></p></li></ul><p>目录文件的block区域如下：<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138621.webp"></p><p>内存的树形结构：</p><ul><li>dentry 绑定到唯一一个 inode 结构体；</li><li>dentry 有父，子，兄弟的索引路径，有这个就足够在内存中构建一个树了，并且事实也确实如此；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>  *<span class="hljs-title">d_parent</span>;</span>   <span class="hljs-comment">/* 父节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span>     <span class="hljs-title">d_name</span>;</span>      <span class="hljs-comment">// 名字</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>   *<span class="hljs-title">d_inode</span>;</span>    <span class="hljs-comment">// inode 结构体</span><br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_child</span>;</span>     <span class="hljs-comment">/* 兄弟节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span>   <span class="hljs-comment">/* 子节点 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="三-ln命令"><a href="#三-ln命令" class="headerlink" title="三. ln命令"></a>三. ln命令</h1><ul><li><p>软链接：软链接文件是一个全新的文件，有独立的 inode，有自己的 block ，内容是一段 path 路径，这个路径直接指向源文件；</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139893.webp"></p></li><li><p>硬链接：</p><blockquote><p>硬链接文件其实并没有新建文件（也就是说，没有消耗 inode 和 文件所需的 block 块）；</p><p>硬链接其实是修改了当前目录所在的目录文件，加了一个 dirent 而已，这个 dirent 用一个新的 name 名字指向原来的 inode number；</p><p>由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：<strong>不能跨文件系统。因为，不同文件系统的 inode 管理都是独立的。</strong></p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139421.webp"></p><p>总结：<strong>硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化。新的 name 指向原来的 inode。</strong></p><hr><h1 id="四-mv命令"><a href="#四-mv命令" class="headerlink" title="四. mv命令"></a>四. mv命令</h1><ul><li>源文件和目标文件在同一文件系统下：</li></ul><blockquote><p>mv 命令的核心操作是系统调用 rename ，rename 从内核实现来说只涉及到元数据的操作，只涉及到 dirent 的增删；</p><p><strong>inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。</strong></p></blockquote><br><ul><li>源文件和目标文件不在同一文件系统下：</li></ul><blockquote><p> 系统调用 rename 的时候，如果<strong>源</strong>和<strong>目的</strong>不在同一文件系统时，会报告 EXDEV 的错误码，提示该调用不能跨文件系统。</p></blockquote><p><strong>这个时候操作分成两步走，先 copy ，后 remove：</strong></p><ol><li><p>走不了 rename ，那么就退化成 copy ，也就是真正的拷贝。读取源文件，写入目标位置，生成一个全新的目标文件副本；</p><blockquote><p>这里调用的 copy_reg 的函数封装；</p><p>ln，mv，cp 是在 coreutils 库里的命令，公用函数本身就是可以复用的；</p></blockquote></li><li><p>删除源文件，使用 rm 函数删除；</p></li></ol><hr><h1 id="五-cp命令"><a href="#五-cp命令" class="headerlink" title="五. cp命令"></a>五. cp命令</h1><p><a href="https://juejin.cn/post/6939328247922425869">深度剖析 Linux cp 的秘密-博客</a></p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h1><ol><li>目录文件是一种特殊的文件，可以理解成存储的是 dirent 列表。dirent 只是名字到 inode 的映射，这个是树形结构的基础；</li><li>常说目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；</li><li>ln -s 创建软链接文件，软链接文件是一个独立的新文件，有一个新的 inode ，有新的 dentry，文件类型为 link，文件内容就是<strong>一条指向源的路径</strong>，所以<strong>软链的创建可以无视文件系统，跨越山河；</strong></li><li>ln 默认创建硬连接，硬链接文件只在目录文件里添加了一个新 dirent 项 (新name:原inode)，文件 inode 还是和原文件同一个，<strong>所以硬链接不能跨文件系统（因为不同的文件系统是独立的一套 inode 管理方式，不同的文件系统实例对 inode number 的解释各有不同）；</strong></li><li>ln 命令貌似创建出了新文件，但其实不然，ln 只跟元数据相关，涉及到 dirent  的变动，<strong>不涉及到数据的拷贝</strong>，起不到数据备份的目的；</li><li>mv 其实是调用 rename 调用，<strong>在同一个文件系统中不涉及到数据拷贝，只涉及到元数据变更</strong>（ dirent 的增删 ），所以速度也很快。但如果 mv 的源和目的<strong>在不同的文件系统，那么就会退化成真正的 copy ，会涉及到数据拷贝</strong>，这个时候速度相对慢一些，慢成什么样子？就跟 cp 命令一样；</li><li>cp 命令才是真正的数据拷贝命令，速度可能相对慢一些，但是 cp 命令有 –spare 可以优化拷贝速度，针对空洞和全 0 数据，可以跳过，从而<strong>针对稀疏文件可以节省大量磁盘 IO</strong>；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
