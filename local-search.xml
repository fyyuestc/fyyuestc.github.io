<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spark-个人总结</title>
    <link href="/2022/07/31/Spark-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/31/Spark-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spark概述"><a href="#一、Spark概述" class="headerlink" title="一、Spark概述"></a>一、Spark概述</h1><h2 id="什么是-Spark"><a href="#什么是-Spark" class="headerlink" title="什么是 Spark"></a>什么是 Spark</h2><p><a href="https://spark.apache.org/">Apache Spark</a>是一个围绕速度、易用性和复杂分析构建的大数据处理框架。最初在 2009 年由加州大学伯克利分校的 AMPLab 开发，并于 2010 年成为 Apache 的开源项目之一。</p><p>与 Hadoop 和 Storm 等其他大数据和 MapReduce 技术相比，Spark 有如下优势。</p><ul><li>首先，Spark 为我们提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</li><li>Spark 可以将 Hadoop 集群中的应用在内存中的运行速度提升 100 倍，甚至能够将应用在磁盘上的运行速度提升 10 倍。</li><li>Spark 让开发者可以快速的用 Java、Scala 或 Python 编写程序。它本身自带了一个超过 80 个高阶操作符集合。而且还可以用它在 shell 中以交互式地查询数据。</li><li>除了 Map 和 Reduce 操作之外，它还支持 SQL 查询，流数据，机器学习和图表数据处理。开发者可以在一个数据管道用例中单独使用某一能力或者将这些能力结合在一起使用。</li></ul><h2 id="Hadoop-和-Spark"><a href="#Hadoop-和-Spark" class="headerlink" title="Hadoop 和 Spark"></a>Hadoop 和 Spark</h2><p>Hadoop 这项大数据处理技术大概已有十年历史，而且被看做是首选的大数据集合处理的解决方案。MapReduce 是一路计算的优秀解决方案，不过对于需要多路计算和算法的用例来说，并非十分高效。数据处理流程中的每一步都需要一个 Map 阶段和一个 Reduce 阶段，而且如果要利用这一解决方案，需要将所有用例都转换成 MapReduce 模式。</p><p>在下一步开始之前，上一步的作业输出数据必须要存储到分布式文件系统中。因此，复制和磁盘存储会导致这种方式速度变慢。另外 Hadoop 解决方案中通常会包含难以安装和管理的集群。而且为了处理不同的大数据用例，还需要集成多种不同的工具（如用于机器学习的 Mahout 和流数据处理的 Storm）。</p><p>如果想要完成比较复杂的工作，就必须将一系列的 MapReduce 作业串联起来然后顺序执行这些作业。每一个作业都是高时延的，而且只有在前一个作业完成之后下一个作业才能开始启动。</p><p>而 Spark 则允许程序开发者使用有向无环图（<a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>）开发复杂的多步数据管道。而且还支持跨有向无环图的内存数据共享，以便不同的作业可以共同处理同一个数据。</p><p>Spark 运行在现有的 Hadoop 分布式文件系统基础之上（<a href="http://wiki.apache.org/hadoop/HDFS">HDFS</a>）提供额外的增强功能。它支持<a href="http://databricks.com/blog/2014/01/21/Spark-and-Hadoop.html">将 Spark 应用部署到</a>现存的 Hadoop v1 集群（with SIMR – Spark-Inside-MapReduce）或 Hadoop v2 YARN 集群甚至是<a href="http://mesos.apache.org/">Apache Mesos</a>之中。</p><p>我们应该将 Spark 看作是 Hadoop MapReduce 的一个替代品而不是 Hadoop 的替代品。其意图并非是替代 Hadoop，而是为了提供一个管理不同的大数据用例和需求的全面且统一的解决方案。</p><h2 id="Spark特性"><a href="#Spark特性" class="headerlink" title="Spark特性"></a>Spark特性</h2><p>Spark 通过在数据处理过程中成本更低的洗牌（Shuffle）方式，将 MapReduce 提升到一个更高的层次。利用内存数据存储和接近实时的处理能力，Spark 比其他的大数据处理技术的性能要快很多倍。</p><p>Spark 还支持大数据查询的延迟计算，这可以帮助优化大数据处理流程中的处理步骤。Spark 还提供高级的 API 以提升开发者的生产力，除此之外还为大数据解决方案提供一致的体系架构模型。</p><p>Spark 将中间结果保存在内存中而不是将其写入磁盘，当需要多次处理同一数据集时，这一点特别实用。Spark 的设计初衷就是既可以在内存中又可以在磁盘上工作的执行引擎。当内存中的数据不适用时，Spark 操作符就会执行外部操作。Spark 可以用于处理大于集群内存容量总和的数据集。</p><p>Spark 会尝试在内存中存储尽可能多的数据然后将其写入磁盘。它可以将某个数据集的一部分存入内存而剩余部分存入磁盘。开发者需要根据数据和用例评估对内存的需求。Spark 的性能优势得益于这种内存中的数据存储。</p><p>Spark 的其他特性包括：</p><ul><li>支持比 Map 和 Reduce 更多的函数。</li><li>优化任意操作算子图（operator graphs）。</li><li>可以帮助优化整体数据处理流程的大数据查询的延迟计算。</li><li>提供简明、一致的 Scala，Java 和 Python API。</li><li>提供交互式 Scala 和 Python Shell。目前暂不支持 Java。</li></ul><p>Spark 是用<a href="http://www.scala-lang.org/">Scala 程序设计语言</a>编写而成，运行于 Java 虚拟机（JVM）环境之上。目前支持如下程序设计语言编写 Spark 应用：</p><ul><li>Scala</li><li>Java</li><li>Python</li><li>Clojure</li><li>R</li></ul><h2 id="Spark生态系统"><a href="#Spark生态系统" class="headerlink" title="Spark生态系统"></a>Spark生态系统</h2><p>除了 Spark 核心 API 之外，Spark 生态系统中还包括其他附加库，可以在大数据分析和机器学习领域提供更多的能力。</p><p>这些库包括：</p><ul><li>Spark Streaming:<ul><li><a href="https://spark.apache.org/streaming/">Spark Streaming</a>基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用 DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</li></ul></li><li>Spark SQL:<ul><li><a href="https://spark.apache.org/sql/">Spark SQL</a>可以通过 JDBC API 将 Spark 数据集暴露出去，而且还可以用传统的 BI 和可视化工具在 Spark 数据上执行类似 SQL 的查询。用户还可以用 Spark SQL 对不同格式的数据（如 JSON，Parquet 以及数据库等）执行 ETL，将其转化，然后暴露给特定的查询。</li></ul></li><li>Spark MLlib:<ul><li><a href="https://spark.apache.org/mllib/">MLlib</a>是一个可扩展的 Spark 机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</li></ul></li><li>Spark GraphX:<ul><li><a href="https://spark.apache.org/graphx/">GraphX</a>是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了 Spark RDD。为了支持图计算，GraphX 暴露了一个基础操作符集合（如 subgraph，joinVertices 和 aggregateMessages）和一个经过优化的 Pregel API 变体。此外，GraphX 还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</li></ul></li></ul><p>除了这些库以外，还有一些其他的库，如 BlinkDB 和 Tachyon。</p><p><a href="http://blinkdb.org/">BlinkDB</a>是一个近似查询引擎，用于在海量数据上执行交互式 SQL 查询。BlinkDB 可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</p><p><a href="http://tachyon-project.org/index.html">Tachyon</a>是一个以内存为中心的分布式文件系统，能够提供内存级别速度的跨集群框架（如 Spark 和 MapReduce）的可信文件共享。它将工作集文件缓存在内存中，从而避免到磁盘中加载需要经常读取的数据集。通过这一机制，不同的作业 &#x2F; 查询和框架可以以内存级的速度访问缓存的文件。</p><p>此外，还有一些用于与其他产品集成的适配器，如 Cassandra（<a href="http://www.datastax.com/dev/blog/accessing-cassandra-from-spark-in-java">Spark Cassandra 连接器</a>）和 R（SparkR）。Cassandra Connector 可用于访问存储在 Cassandra 数据库中的数据并在这些数据上执行数据分析。</p><p>下图展示了在 Spark 生态系统中，这些不同的库之间的相互关联。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311505375.png" alt="1"></p><h1 id="二、Spark体系架构"><a href="#二、Spark体系架构" class="headerlink" title="二、Spark体系架构"></a>二、Spark体系架构</h1><h2 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念:"></a>基本理念:</h2><p><strong>RDD（resillient distributed dataset</strong>）：弹性分布式数据集。</p><p><strong>Task</strong>：具体执行任务。Task分为ShuffleMapTask和ResultTask两种。ShuffleMapTask和ResultTask分别类似于Hadoop中的Map，Reduce。</p><p><strong>Job</strong>：用户提交的作业。一个Job可能由一到多个Task组成。</p><p><strong>Stage</strong>：Job分成的阶段。一个Job可能被划分为一到多个Stage。</p><p><strong>Partition</strong>：数据分区。即一个RDD的数据可以划分为多少个分区。</p><p><strong>NarrowDependency</strong>：窄依赖。即子RDD依赖于父RDD中固定的Partition。NarrowDependency分为OneToOneDependency和RangeDependency两种。</p><p><strong>ShuffleDependency</strong>：shuffle依赖，也称为宽依赖。即子RDD对父RDD中的所有Partition都有依赖。</p><p><strong>DAG</strong>（Directed Acycle graph）：有向无环图。用于反映各RDD之间的依赖关系。</p><h2 id="Spark适用场景："><a href="#Spark适用场景：" class="headerlink" title="Spark适用场景："></a>Spark适用场景：</h2><ol><li>Spark是基于内存的迭代计算框架，适用于需要多次操作特定数据集的应用场合。需要反复操作的次数越多，所需读取的数据量越大，受益越大，数据量小但是计算密集度较大的场合，受益就相对较小。</li><li>由于RDD的特性，Spark不适用那种异步细粒度更新状态的应用，例如web服务的存储或者是增量的web爬虫和索引。就是对于那种增量修改的应用模型不适合。</li><li>数据量不是特别大，但是要求近实时统计分析需求</li></ol><h2 id="Spark不适用场景："><a href="#Spark不适用场景：" class="headerlink" title="Spark不适用场景："></a>Spark不适用场景：</h2><ol><li>内存hold不住的场景，在内存不足的情况下，Spark会下放到磁盘，会降低应有的性能</li><li>有高实时性要求的流式计算业务，例如实时性要求毫秒级</li><li>由于RDD设计上的只读特点，所以Spark对于待分析数据频繁变动的情景很难做（并不是不可以），比如题主例子里的搜索，假设你的数据集在频繁变化（不停增删改），而且又需要结果具有很强的一致性（不一致时间窗口很小），那么就不合适了。</li><li>流线长或文件流量非常大的数据集不适合。你会发现你的内存不够用，集群压力大时一旦一个task失败会导致他前面一条线所有的前置任务全部重跑，然后恶性循环会导致更多的task失败，整个sparkapp效率极低。就不如MapReduce啦！</li></ol><h2 id="Spark编程模型"><a href="#Spark编程模型" class="headerlink" title="Spark编程模型"></a>Spark编程模型</h2><p>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：</p><ol><li><p>用户使用SparkContext提供的API（常用的有textFile、sequenceFile、runJob、stop等）编写Driver application程序。此外SQLContext、HiveContext及StreamingContext对SparkContext进行封装，并提供了SQL、Hive及流式计算相关的API。</p></li><li><p>使用SparkContext提交的用户应用程序，首先会使用BlockManager和BroadcastManager将任务的Hadoop配置进行广播。然后由DAGScheduler将任务转换为RDD并组织成DAG，DAG还将被划分为不同的Stage。最后由TaskScheduler借助ActorSystem将任务提交给集群管理器（Cluster Manager）。</p></li><li><p>集群管理器（ClusterManager）给任务分配资源，即将具体任务分配到Worker上，Worker创建Executor来处理任务的运行。Standalone、YARN、Mesos、EC2等都可以作为Spark的集群管理器。</p></li></ol><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311507030.png" alt="1"></p><h2 id="Spark计算模型："><a href="#Spark计算模型：" class="headerlink" title="Spark计算模型："></a>Spark计算模型：</h2><p>RDD可以看做是对各种数据计算模型的统一抽象，Spark的计算过程主要是RDD的迭代计算过程。RDD的迭代计算过程非常类似于管道。分区数量取决于partition数量的设定，每个分区的数据只会在一个Task中计算。所有分区可以在多个机器节点的Executor上并行执行。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311507655.png" alt="2"></p><h2 id="集群架构设计"><a href="#集群架构设计" class="headerlink" title="集群架构设计"></a>集群架构设计</h2><p>整个集群分为 Master 节点和 Worker 节点，相当于 Hadoop 的 Master 和 Slave 节点。 Master 节点上常驻 Master 守护进程，负责管理全部的 Worker 节点。 Worker 节点上常驻 Worker 守护进程，负责与 Master 节点通信并管理 executors。 Driver 官方解释是 “The process running the main() function of the application and creating the SparkContext”。Application 就是用户自己写的 Spark 程序（driver program。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311508163.png" alt="3"></p><h2 id="Spark-运行时架构"><a href="#Spark-运行时架构" class="headerlink" title="Spark 运行时架构"></a>Spark 运行时架构</h2><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311508496.png" alt="4"></p><p>在分布式环境下，Spark 集群采用的是<strong>主 &#x2F; 从</strong>结构。在一个 Spark 集群中，有一个节点负责中央协调，调度各个分布式工作节点。这个中央协调节点被称为<strong>驱动器（Driver）</strong>节点，与之对应的工作节点被称为<strong>执行器（executor）</strong>节点。驱动器节点可以和大量的执行器节点进行通信，它们也都作为独立的 Java 进程运行。驱动器节点和所有的执行器节点一起被称为一个 Spark 应用（application）。</p><p>Spark 应用通过一个叫作<strong>集群管理器（Cluster Manager）</strong>的外部服务在集群中的机器上启动。Spark 自带的集群管理器被称为独立集群管理器。Spark 也能运行在 Hadoop YARN 和 Apache Mesos 这两大开源集群管理器上。</p><h3 id="驱动器节点"><a href="#驱动器节点" class="headerlink" title="驱动器节点"></a>驱动器节点</h3><p>Spark 驱动器是执行你的程序中的 main() 方法的进程。它执行用户编写的用来创建 SparkContext、创建 RDD，以及进行 RDD 的转化操作和行动操作的代码。其实，当你启动 Spark shell 时，你就启动了一个 Spark 驱动器程序（相信你还记得，Spark shell 总是会预先加载一个叫作 sc 的 SparkContext 对象）。驱动器程序一旦终止，Spark 应用也就结束了。</p><p>驱动器程序在 Spark 应用中有下述两个职责。</p><ul><li><p>把用户程序转为任务</p><p>Spark 驱动器程序负责把用户程序转为多个物理执行的单元，这些单元也被称为任务（task）。从上层来看，所有的 Spark 程序都遵循同样的结构：程序从输入数据创建一系列 RDD，再使用转化操作派生出新的 RDD，最后使用行动操作收集或存储结果 RDD 中的数据。Spark 程序其实是隐式地创建出了一个由操作组成的逻辑上的有向无环图（Directed Acyclic Graph，简称 DAG）。当驱动器程序运行时，它会把这个逻辑图转为物理执行计划。</p><p>把用户程序转为任务 Spark 驱动器程序负责把用户程序转为多个物理执行的单元，这些单元也被称为任务（task）。从上层来看，所有的 Spark 程序都遵循同样的结构：程序从输入数据创建一系列 RDD，再使用转化操作派生出新的 RDD，最后使用行动操作收集或存储结果 RDD 中的数据。Spark 程序其实是隐式地创建出了一个由操作组成的逻辑上的有向无环图（Directed Acyclic Graph，简称 DAG）。当驱动器程序运行时，它会把这个逻辑图转为物理执行计划。</p></li><li><p>**为执行器节点调度任务<br>**有了物理执行计划之后，Spark 驱动器程序必须在各执行器进程间协调任务的调度。执行器进程启动后，会向驱动器进程注册自己。因此，驱动器进程始终对应用中所有的执行器节点有完整的记录。每个执行器节点代表一个能够处理任务和存储。<br>Spark 驱动器程序会根据当前的执行器节点集合，尝试把所有任务基于数据所在位置分配给合适的执行器进程。当任务执行时，执行器进程会把缓存数据存储起来，而驱动器进程同样会跟踪这些缓存数据的位置，并且利用这些位置信息来调度以后的任务，以尽量减少数据的网络传输。<br>驱动器程序会将一些 Spark 应用的运行时的信息通过网页界面呈现出来，默认在端口 4040 上。比如，在本地模式下，访问 <a href="http://localhost:4040/">http://localhost:4040</a> 就可以看到这个网页了。</p></li></ul><h3 id="执行器节点"><a href="#执行器节点" class="headerlink" title="执行器节点"></a>执行器节点</h3><p>Spark 执行器节点是一种工作进程，负责在 Spark 作业中运行任务，任务间相互独立。Spark 应用启动时，执行器节点就被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。如果有执行器节点发生了异常或崩溃，Spark 应用也可以继续执行。执行器进程有两大作用：第一，它们负责运行组成 Spark 应用的任务，并将结果返回给驱动器进程；第二，它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD提供内存式存储。RDD 是直接缓存在执行器进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p><h3 id="集群管理器"><a href="#集群管理器" class="headerlink" title="集群管理器"></a>集群管理器</h3><p>到目前为止，我们已经介绍了驱动器节点和执行器节点的抽象概念。那么，驱动器节点和执行器节点是如何启动的呢？ Spark 依赖于集群管理器来启动执行器节点，而在某些特殊情况下，也依赖集群管理器来启动驱动器节点。集群管理器是依赖于集群管理器来启动执行器节点，而在某些特殊情况下，也依赖集群管理器来启动驱动器节点。集群管理器是 Spark 中的可插拔式组件。这样，除了 Spark 自带的独立集群管理器，Spark 也可以运行在其他外部集群管理器上，比如 YARN 和 Mesos。</p><h2 id="RDD运行流程"><a href="#RDD运行流程" class="headerlink" title="RDD运行流程"></a>RDD运行流程</h2><p>RDD在Spark中运行大概分为以下三步：</p><ul><li>创建RDD对象</li><li>DAGScheduler模块介入运算，计算RDD之间的依赖关系，RDD之间的依赖关系就形成了DAG</li><li>每一个Job被分为多个Stage。划分Stage的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个Stage，避免多个Stage之间的消息传递开销</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311509631.png" alt="5"></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311510565.png" alt="6"></p><p>创建 RDD 上面的例子除去最后一个 collect 是个动作，不会创建 RDD 之外，前面四个转换都会创建出新的 RDD 。因此第一步就是创建好所有 RDD( 内部的五项信息 )？创建执行计划 Spark 会尽可能地管道化，并基于是否要重新组织数据来划分 阶段 (stage) ，例如本例中的 groupBy() 转换就会将整个执行计划划分成两阶段执行。最终会产生一个 DAG(directed acyclic graph ，有向无环图 ) 作为逻辑执行计划</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311510209.png" alt="7"></p><h2 id="独立集群运行模式"><a href="#独立集群运行模式" class="headerlink" title="独立集群运行模式"></a>独立集群运行模式</h2><ul><li>Standalone模式使用Spark自带的资源调度框架</li><li>采用Master&#x2F;Slaves的典型架构，选用ZooKeeper来实现Master的HA</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311510518.png" alt="8"></p><h2 id="YARN-Cluster运行模式"><a href="#YARN-Cluster运行模式" class="headerlink" title="YARN-Cluster运行模式"></a>YARN-Cluster运行模式</h2><p>当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序：</p><ul><li>第一个阶段是把Spark的Driver作为一个ApplicationMaster在YARN集群中先启动；</li><li>第二个阶段是由ApplicationMaster创建应用程序，然后为它向ResourceManager申请资源，并启动Executor来运行Task，同时监控它的整个运行过程，直到运行完成。</li></ul><p><strong>整体流程：</strong></p><ul><li>Spark Yarn Client向YARN中提交应用程序，包括ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等</li><li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，其中ApplicationMaster进行SparkContext等的初始化</li><li>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将采用轮询的方式通过RPC协议为各个任务申请资源，并监控它们的运行状态直到运行结束</li><li>一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中启动CoarseGrainedExecutorBackend，CoarseGrainedExecutorBackend启动后会向ApplicationMaster中的SparkContext注册并申请Task。这一点和Standalone模式一样，只不过SparkContext在Spark Application中初始化时，使用CoarseGrainedSchedulerBackend配合YarnClusterScheduler进行任务的调度，其中YarnClusterScheduler只是对TaskSchedulerImpl的一个简单包装，增加了对Executor的等待逻辑等</li><li>ApplicationMaster中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向ApplicationMaster汇报运行的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务</li><li>应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311511961.png" alt="9"></p><h1 id="三、Spark-RDD"><a href="#三、Spark-RDD" class="headerlink" title="三、Spark RDD"></a>三、Spark RDD</h1><h2 id="RDD基础"><a href="#RDD基础" class="headerlink" title="RDD基础"></a>RDD基础</h2><p>Spark 中的 RDD 就是一个不可变的分布式对象集合。每个 RDD 都被分为多个分区，这些分区运行在集群中的不同节点上。RDD 可以包含 Python、Java、Scala 中任意类型的对象，甚至可以包含用户自定义的对象。</p><p>用户可以使用两种方法创建 RDD：</p><ul><li>读取一个外部数据集，</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">JavaRDD&lt;String&gt; input <span class="hljs-operator">=</span> ctx.textFile(args[<span class="hljs-number">0</span>])<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>或在驱动器程序里分发驱动器程序中的对象集合（比如 list 和 set）</li></ul><p>创建出来后，RDD 支持两种类型的操作：<strong>转化操作（transformation）</strong> 和 <strong>行动操作（action）</strong>。</p><ul><li>转化操作会由一个 RDD 生成一个新的 RDD。</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">input.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">x</span> -&gt; <span class="hljs-keyword">x</span>.length() &gt; <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><ul><li>另一方面，行动操作会对 RDD 计算出一个结果，并把结果返回到驱动器程序中，或把结果存储到外部存储系统（如HDFS）中。first() 就是我们之前调用的一个行动操作，它会返回 RDD 的第一个元素。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.first</span>()<br></code></pre></td></tr></table></figure><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>转化操作和行动操作的区别在于 Spark 计算 RDD 的方式不同。虽然你可以在任何时候定义新的 RDD，但 Spark 只会惰性计算这些 RDD。它们只有第一次在一个行动操作中用到时，才会真正计算。这种策略刚开始看起来可能会显得有些奇怪，不过在大数据领域是很有道理的。比如我们以一个文本文件定义了数据，然后把其中包含 Python 的行筛选出来。如果 Spark 在我们运行lines &#x3D; sc.textFile(…) 时就把文件中所有的行都读取并存储起来，就会消耗很多存储空间，而我们马上就要筛选掉其中的很多数据。相反，一旦 Spark 了解了完整的转化操作链之后，它就可以只计算求结果时真正需要的数据。事实上，在行动操作 first() 中，Spark 只需要扫描文件直到找到第一个匹配的行为止，而不需要读取整个文件。章详细介绍。不过，我们已经接触了用来将文本文件读入为一个存储字符串的 RDD 的方法 SparkContext.textFile()。</p><h2 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h2><ul><li>通过parallelize生成</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">JavaRDD&lt;String&gt; lines = sc.parallelize(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">&quot;pandas&quot;</span>, <span class="hljs-string">&quot;i like pandas&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><ul><li>读取外部文件</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">JavaRDD&lt;String&gt; input <span class="hljs-operator">=</span> ctx.textFile(args[<span class="hljs-number">0</span>])<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h2><p>RDD 支持两种操作：<strong>转化操作</strong> 和 <strong>行动操作</strong>。RDD 的转化操作是返回一个新的 RDD 的操作，比如 map() 和 filter()，而行动操作则是向驱动器程序返回结果或把结果写入外部系统的操作，会触发实际的计算，比如 count() 和first()。Spark 对待转化操作和行动操作的方式很不一样，因此理解你正在进行的操作的类型是很重要的。如果对于一个特定的函数是属于转化操作还是行动操作感到困惑，你可以看看它的返回值类型：转化操作返回的是 RDD，而行动操作返回的是其他的数据类型。</p><h3 id="转化操作"><a href="#转化操作" class="headerlink" title="转化操作"></a>转化操作</h3><p>RDD 的转化操作是返回新 RDD 的操作。转化出来的 RDD 是惰性求值的，只有在行动操作中用到这些 RDD 时才会被计算。许多转化操作都是针对各个元素的，也就是说，这些转化操作每次只会操作 RDD 中的一个元素。不过并不是所有的转化操作都是这样的。</p><p>举个例子，假定我们有一个日志文件 log.txt，内含有若干消息，希望选出其中的错误消息。我们可以使用前面说过的转化操作 filter()。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">input.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">x</span> -&gt; <span class="hljs-keyword">x</span>.contains(<span class="hljs-string">&quot;error&quot;</span>))<br></code></pre></td></tr></table></figure><p>注意，filter() 操作不会改变已有的 inputRDD 中的数据。实际上，该操作会返回一个全新的 RDD。inputRDD 在后面的程序中还可以继续使用，比如我们还可以从中搜索别的单词。事实上，要再从 inputRDD 中找出所有包含单词 warning 的行。接下来，我们使用另一个转化操作 union() 来打印出包含 error 或 warning 的行数。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311513990.png" alt="1"></p><h3 id="常用转化操作："><a href="#常用转化操作：" class="headerlink" title="常用转化操作："></a>常用转化操作：</h3><p>map()</p><p>filter()</p><p>flatMap()</p><p>distinct()</p><h2 id="行动操作"><a href="#行动操作" class="headerlink" title="行动操作"></a>行动操作</h2><p>对数据集进行实际的计算。行动操作是第二种类型的 RDD 操作，它们会把最终求得的结果返回到驱动器程序，或者写入外部存储系统中。由于行动操作需要生成实际的输出，它们会强制执行那些求值必须用到的 RDD 的转化操作。 继续我们在前几章中用到的日志的例子，我们可能想输出关于 badLinesRDD 的一些信息。为此，需要使用两个行动操作来实现：用 count() 来返回计数结果，用 take() 来收集 RDD 中的一些元素。</p><p>RDD 还有一个 collect() 函数，可以用来获取整个 RDD 中的数据。如果你的程序把 RDD 筛选到一个很小的规模，并且你想在本地处理这些数据时，就可以使用它。记住，只有当你的整个数据集能在单台机器的内存中放得下时，才能使用 collect()，因此，collect() 不能用在大规模数据集上。 在大多数情况下，RDD 不能通过 collect() 收集到驱动器进程中，因为它们一般都很大。此时，我们通常要把数据写到诸如 HDFS 或 Amazon S3 这样的分布式的存储系统中。你可以使用 saveAsTextFile() 、 saveAsSequenceFile()，或者任意的其他行动操作来把 RDD 的数据内容以各种自带的格式保存起来。</p><h3 id="常见行动操作："><a href="#常见行动操作：" class="headerlink" title="常见行动操作："></a>常见行动操作：</h3><p>collect():返回所有元素</p><p>count():</p><p>countByValue():</p><p>take(num):</p><p>reduce()</p><h1 id="四、Spark-SQL"><a href="#四、Spark-SQL" class="headerlink" title="四、Spark SQL"></a>四、Spark SQL</h1><p>Apache Spark是一种闪电般快速的集群计算框架，专为快速计算而设计。 它是Apache Software Foundation中最成功的项目之一。 Spark SQL是Spark中的一个新模块，它将关系处理与Spark的函数式编程API集成在一起。 它支持通过SQL或Hive查询语言查询数据。</p><h2 id="为什么使用Spark-SQL"><a href="#为什么使用Spark-SQL" class="headerlink" title="为什么使用Spark SQL"></a>为什么使用Spark SQL</h2><p>Spark SQL起源于Apache Hive，可以在Spark上运行，现在可以与Spark堆栈集成。 Apache Hive有一些限制，如下所述。 构建Spark SQL是为了克服这些缺点并替换Apache Hive。</p><p><strong>Hive的局限性：</strong></p><ul><li>Hive在内部启动MapReduce作业以执行即席查询。 在分析中型数据集（10到200 GB）时，MapReduce的性能落后。</li><li>Hive没有恢复功能。 这意味着如果处理在工作流程中间死亡，则无法从卡住的位置恢复。</li><li>启用垃圾箱时，Hive无法以级联方式删除加密数据库，从而导致执行错误。 要解决此问题，用户必须使用“清除”选项来跳过垃圾而不是删除。</li></ul><p>这些缺点让Spark SQL诞生。</p><h2 id="Spark-SQL概述"><a href="#Spark-SQL概述" class="headerlink" title="Spark SQL概述"></a>Spark SQL概述</h2><p>Spark SQL将关系处理与Spark的函数式编程集成在一起。它为各种数据源提供支持，并且可以使用代码转换编织SQL查询，从而生成一个非常强大的工具。</p><p>让我们来探索Spark SQL提供的功能。 Spark SQL模糊了RDD和关系表之间的界限。它通过与Spark代码集成的声明性DataFrame API，在关系和程序处理之间提供更紧密的集成。它还提供更高的优化。 <strong>DataFrame API</strong>和<strong>Datasets API</strong>是与Spark SQL交互的方式。</p><p>使用Spark SQL，Apache Spark可供更多用户访问，并改进了当前版本的优化。 Spark SQL提供了DataFrame API，可以对外部数据源和Spark的内置分布式集合执行关系操作。它引入了名为Catalyst的可扩展优化器，因为它有助于支持大数据中的各种数据源和算法。</p><p>Spark在Windows和类UNIX系统（例如Linux，Microsoft，Mac OS）上运行。它很容易在一台机器上本地运行 - 您只需要在系统PATH上安装Java，或者指向Java安装的JAVA_HOME环境变量。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311515450.png" alt="1"></p><h2 id="Spark-SQL库"><a href="#Spark-SQL库" class="headerlink" title="Spark SQL库"></a>Spark SQL库</h2><p>Spark SQL具有以下四个库，用于与关系和过程处理进行交互：</p><h3 id="1-数据源API（应用程序编程接口）："><a href="#1-数据源API（应用程序编程接口）：" class="headerlink" title="1. 数据源API（应用程序编程接口）："></a>1. 数据源API（应用程序编程接口）：</h3><ul><li>它内置了对Hive，Avro，JSON，JDBC，Parquet等的支持。</li><li>通过Spark包支持第三方集成</li><li>支持智能源（smart source）。</li><li>它是适用于结构和半结构化数据的数据抽象和域特定语言（DSL）。</li><li>DataFrame API是以命名列和行的形式分布式数据集合。</li><li>它像Apache Spark Transformations一样被懒惰地评估，可以通过SQL Context和Hive Context访问。</li><li>它将单节点群集上的千字节大小到千兆字节的数据处理为多节点群集。</li><li>支持不同的数据格式（Avro，CSV，Elastic Search和Cassandra）和存储系统（HDFS，HIVE表，MySQL等）。</li><li>可以通过Spark-Core轻松集成所有大数据工具和框架。</li></ul><p>提供Python，Java，Scala和R编程的API。</p><h3 id="2-DataFrame-API"><a href="#2-DataFrame-API" class="headerlink" title="2. DataFrame API:"></a><strong>2. DataFrame API:</strong></h3><p>DataFrame是组织到命名列中的分布式数据集合。 它等同于SQL中用于将数据存储到表中的关系表。</p><h3 id="3-SQL解释器和优化器："><a href="#3-SQL解释器和优化器：" class="headerlink" title="3. SQL解释器和优化器："></a>3. SQL解释器和优化器：</h3><p>SQL Interpreter和Optimizer基于Scala构建的函数式编程。</p><ul><li>它是SparkSQL最新，技术最先进的组件。</li><li>它提供了转换树的一般框架，用于执行分析&#x2F;评估，优化，计划和运行时代码生成。</li><li>这支持基于成本的优化（运行时和资源利用率被称为成本）和基于规则的优化，使查询运行速度比RDD（弹性分布式数据集）对应物快得多。</li></ul><p>例如 Catalyst是一个模块化库，它是一个基于规则的系统。 框架中的每个规则都侧重于不同的优化。</p><h3 id="4-SQL服务："><a href="#4-SQL服务：" class="headerlink" title="4. SQL服务："></a>4. SQL服务：</h3><p>SQL Service是在Spark中使用结构化数据的入口点。 它允许创建DataFrame对象以及执行SQL查询。</p><h2 id="Spark-SQL的特性"><a href="#Spark-SQL的特性" class="headerlink" title="Spark SQL的特性"></a>Spark SQL的特性</h2><p>以下是Spark SQL的功能：</p><p><strong>1、与Spark集成</strong><br>Spark SQL查询与Spark程序集成在一起。 Spark SQL允许我们使用SQL或可以在Java，Scala，Python和R中使用的DataFrame API来查询Spark程序中的结构化数据。为了运行流计算，开发人员只需针对DataFrame &#x2F; Dataset API编写批量计算，并且Spark自动递增计算以流式方式运行它。这种强大的设计意味着开发人员无需手动管理状态，故障或使应用程序与批处理作业保持同步。相反，流式作业总是给出与同一数据上的批处理作业相同的答案。</p><p><strong>2、统一数据访问</strong><br>DataFrames和SQL支持访问各种数据源的常用方法，如Hive，Avro，Parquet，ORC，JSON和JDBC。这会跨这些来源加入数据。这对于将所有现有用户容纳到Spark SQL中非常有用。</p><p><strong>3、Hive兼容性</strong><br>Spark SQL对当前数据运行未修改的Hive查询。它重写了Hive前端和元存储，允许与当前的Hive数据，查询和UDF完全兼容。</p><p><strong>4、标准连接</strong><br>连接是通过JDBC或ODBC进行的。 JDBC和ODBC是商业智能工具连接的行业规范。</p><p><strong>5、性能和可扩展性</strong><br>Spark SQL结合了基于成本的优化器，代码生成和列式存储，使查询变得灵活，同时使用Spark引擎计算数千个节点，Spark引擎提供完整的中间查询容错。 Spark SQL提供的接口为Spark提供了有关数据结构和正在执行的计算的更多信息。在内部，Spark SQL使用此额外信息来执行额外的优化。 Spark SQL可以直接从多个源（文件，HDFS，JSON &#x2F; Parquet文件，现有RDD，Hive等）读取。它确保快速执行现有的Hive查询。</p><p>下图描述了与Hadoop相比时Spark SQL的性能。 Spark SQL执行速度比Hadoop快100倍。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311516919.png" alt="2"></p><p><strong>6、用户定义的功能（User Defined Function）</strong><br>Spark SQL具有语言集成的用户定义函数（UDF）。 UDF是Spark SQL的一项功能，用于定义新的基于列的函数，这些函数扩展了Spark SQL的DSL用于转换数据集的词汇表。 UDF在执行时是黑盒子。</p><h2 id="使用Spark-SQL查询"><a href="#使用Spark-SQL查询" class="headerlink" title="使用Spark SQL查询"></a>使用Spark SQL查询</h2><p>我们现在将开始使用Spark SQL进行查询。 请注意，实际的SQL查询与流行的SQL客户端中使用的查询类似。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">SparkConf conf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SparkConf()</span>.set<span class="hljs-constructor">Master(<span class="hljs-string">&quot;local&quot;</span>)</span><br>                .set<span class="hljs-constructor">AppName(<span class="hljs-string">&quot;Hello Spark&quot;</span>)</span>;<br>JavaSparkContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JavaSparkContext(<span class="hljs-params">conf</span>)</span>;<br><br>SQLContext sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SQLContext(<span class="hljs-params">ctx</span>)</span>;<br>Dataset&lt;Row&gt; rowDataset = sc.json<span class="hljs-constructor">File(<span class="hljs-string">&quot;hdfs://node-master:9000/input/emp.json&quot;</span>)</span>;<br><br>rowDataset.print<span class="hljs-constructor">Schema()</span>;<br>rowDataset.show<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h3 id="DataFrames"><a href="#DataFrames" class="headerlink" title="DataFrames"></a>DataFrames</h3><p>DataFrame是一个分布式的数据集合，该数据集合以命名列的方式进行整合。DataFrame可以理解为关系数据库中的一张表，也可以理解为R&#x2F;Python中的一个data frame。DataFrames可以通过多种数据构造，例如：结构化的数据文件、hive中的表、外部数据库、Spark计算过程中生成的RDD等。<br>DataFrame的API支持4种语言：Scala、Java、Python、R。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">Select</span> <span class="hljs-keyword">only</span> the &quot;name&quot; <span class="hljs-keyword">column</span><br>df.<span class="hljs-keyword">select</span>(&quot;name&quot;).<span class="hljs-keyword">show</span>();<br><br>df.<span class="hljs-keyword">select</span>(df.col(&quot;name&quot;), df.col(&quot;age&quot;).plus(<span class="hljs-number">1</span>)).<span class="hljs-keyword">show</span>();<br><br>// Count people <span class="hljs-keyword">by</span> age<br>df.groupBy(&quot;age&quot;).count().<span class="hljs-keyword">show</span>();<br><br>// <span class="hljs-keyword">Select</span> people older than <span class="hljs-number">21</span><br>df.<span class="hljs-keyword">filter</span>(df.col(&quot;age&quot;).gt(<span class="hljs-number">21</span>)).<span class="hljs-keyword">show</span>();<br></code></pre></td></tr></table></figure><h3 id="运行SQL查询程序"><a href="#运行SQL查询程序" class="headerlink" title="运行SQL查询程序"></a>运行SQL查询程序</h3><p>Spark Application可以使用SQLContext的sql()方法执行SQL查询操作，sql()方法返回的查询结果为DataFrame格式。代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#首先必须注册一个临时<span class="hljs-keyword">View</span><br>df.createOrReplaceTempView(&quot;employee&quot;);<br>Dataset&lt;<span class="hljs-keyword">Row</span>&gt; <span class="hljs-keyword">sql</span> = sc.<span class="hljs-keyword">sql</span>(&quot;SELECT * FROM employee&quot;);<br><span class="hljs-keyword">sql</span>.<span class="hljs-keyword">show</span>();<br></code></pre></td></tr></table></figure><h2 id="什么是DataFrame和DataSet"><a href="#什么是DataFrame和DataSet" class="headerlink" title="什么是DataFrame和DataSet?"></a>什么是DataFrame和DataSet?</h2><p>首先，最简单的理解我们可以认为DataFrame就是Spark中的数据表（类比传统数据库），DataFrame的结构如下：</p><p>DataFrame（表）&#x3D; Schema（表结构） + Data（表数据）</p><p>总结：DataFrame（表）是Spark SQL对结构化数据的抽象。可以将DataFrame看做RDD。</p><h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>DataFrame是组织成命名列的<strong>数据集</strong>。它在概念上等同于关系数据库中的<strong>表</strong>，但在底层具有更丰富的优化。DataFrames可以从各种来源构建，</p><p>例如：</p><ul><li>结构化数据文件(JSON)</li><li>外部数据库或现有RDDs</li></ul><p>DataFrame API支持的语言有Scala，Java，Python和R。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311517004.png" alt="3"></p><p><strong>从上图可以看出，DataFrame相比RDD多了数据的结构信息，即schema</strong>。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。</p><h4 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h4><p>Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。 Dataset API 支持Scala和Java。 Python不支持Dataset API。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop-个人总结</title>
    <link href="/2022/07/31/Hadoop-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/31/Hadoop-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Hadoop概念和特点"><a href="#一、Hadoop概念和特点" class="headerlink" title="一、Hadoop概念和特点"></a>一、Hadoop概念和特点</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Apache™Hadoop®项目为<strong>可靠</strong>的，<strong>可扩展</strong>的<strong>分布式计算</strong>开发开源软件。</p><p>Apache Hadoop软件库是一个框架，它允许使用简单的编程模型跨计算机群集分布式处理大型数据集。它旨在从单个服务器扩展到数千台机器，每台机器提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于在应用层检测和处理故障，从而在一组计算机之上提供高可用性服务，每个计算机都可能出现故障。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li><strong>Hadoop Common</strong>：支持其他Hadoop模块的常用工具。</li><li><strong>Hadoop分布式文件系统（HDFS™）</strong>：一种分布式文件系统，可提供对应用程序数据的高吞吐量访问。</li><li><strong>Hadoop YARN</strong>：作业调度和集群资源管理的框架。</li><li><strong>Hadoop MapReduce</strong>：一种用于并行处理大型数据集的基于YARN的系统。</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311428598.png" alt="image-20220731142820117"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>扩容能力（Scalable）</strong>：能可靠地（reliably）存储和处理千兆字节（PB）数据。</li><li><strong>成本低（Economical）</strong>：可以通过普通机器组成的服务器群来分发以及处理数据。这些服务器群总计可达数千个节点。</li><li><strong>高效率（Efficient）</strong>：通过分发数据，hadoop可以在数据所在的节点上并行地（parallel）处理它们，这使得处理非常的快速。</li><li><strong>可靠性（Reliable）</strong>：hadoop能自动地维护数据的多份复制，并且在任务失败后能自动地重新部署（redeploy）计算任务。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不适合低延迟数据访问</li><li>无法高效存储大量小文件</li><li>不支持多用户写入及任意修改文件</li></ul><h2 id="Hadoop编年史"><a href="#Hadoop编年史" class="headerlink" title="Hadoop编年史"></a>Hadoop编年史</h2><ul><li>2002 年 10 月，Doug Cutting 和 Mike Cafarella 创建了开源网页爬虫项目 Nutch。</li><li>2003 年 10 月，Google 发表 Google File System 论文。</li><li>2004 年 7 月，Doug Cutting 和 Mike Cafarella 在 Nutch 中实现了类似 GFS 的功能，即后来 HDFS 的前身。</li><li>2004 年 10 月，Google 发表了 MapReduce 论文。</li><li>2005 年 2 月，Mike Cafarella 在 Nutch 中实现了 MapReduce 的最初版本。</li><li>2005 年 12 月，开源搜索项目 Nutch 移植到新框架，使用 MapReduce 和 NDFS(Nutch Distributed File System ) 来运行，在 20 个节点稳定运行。</li><li>2006 年 1 月，Doug Cutting 加入雅虎，Yahoo! 提供一个专门的团队和资源将 Hadoop 发展成一个可在网络上运行的系统。</li><li><strong>2006年 2月，Apache Hadoop项目正式启动以支持 MapReduce和 HDFS*<em>*</em> 的独立发展。</strong></li><li>2006 年 2 月，Yahoo! 的网格计算团队采用 Hadoop。</li><li>2006 年 3 月，Yahoo! 建设了第一个 Hadoop 集群用于开发。</li><li>2006 年 4 月，第一个 Apache Hadoop 发布。</li><li>2006 年 4 月，在 188 个节点上（每个节点 10GB）运行排序测试集需要 47.9 个小时。</li><li>2006 年 5 月，Yahoo! 建立了一个 300 个节点的 Hadoop 研究集群。</li><li>2006 年 5 月，在 500 个节点上运行排序测试集需要 42 个小时（硬件配置比 4 月的更好）。</li><li>2006 年 11 月，研究集群增加到 600 个节点。</li><li>2006 年 11 月，Google 发表了 Bigtable 论文，这最终激发了 HBase 的创建。</li><li>2006 年 12 月，排序测试集在 20 个节点上运行 1.8 个小时，100 个节点上运行 3.3 小时，500 个节点上运行 5.2 小时，900 个节点上运行 7.8 个小时。</li><li>2007 年 1 月，研究集群增加到 900 个节点。</li><li>2007 年 4 月，研究集群增加到两个 1000 个节点的集群。</li><li><strong>2007年 10月，第一个 Hadoop*<em>*</em> 用户组会议召开，社区贡献开始急剧上升。</strong></li><li>2007 年，百度开始使用 Hadoop 做离线处理。</li><li>2007 年，中国移动开始在“大云”研究中使用 Hadoop 技术。</li><li>2008 年，淘宝开始投入研究基于 Hadoop 的系统——云梯，并将其用于处理电子商务相关数据。</li><li><strong>2008年 1月，Hadoop成为 Apache顶级项目。</strong></li><li>2008 年 2 月，Yahoo! 运行了世界上最大的 Hadoop 应用，宣布其搜索引擎产品部署在一个拥有 1 万个内核的 Hadoop 集群上。</li><li>2008 年 4 月，在 900 个节点上运行 1TB 排序测试集仅需 209 秒，成为世界最快。</li><li>2008 年 6 月，Hadoop 的第一个 SQL 框架——Hive 成为了 Hadoop 的子项目。</li><li>2008 年 7 月，Hadoop 打破 1TB 数据排序基准测试记录。Yahoo! 的一个 Hadoop 集群用 209 秒完成 1TB 数据的排序 ，比上一年的纪录保持者保持的 297 秒快了将近 90 秒。</li><li><strong>2008年 8月，第一个 Hadoop商业化公司 Cloudera成立。</strong></li><li>2008 年 10 月，研究集群每天装载 10TB 的数据。</li><li>2008 年 11 月，Apache Pig 的最初版本发布。</li><li>2009 年 3 月，17 个集群总共 24000 台机器。</li><li><strong>2009</strong> <strong>年 3月，Cloudera推出世界上首个 Hadoop发行版——CDH（Cloudera’s Distribution including Apache Hadoop****）平台，完全由开放源码软件组成。</strong></li><li>2009 年 4 月，赢得每分钟排序，59 秒内排序 500GB（在 1400 个节点上）和 173 分钟内排序 100TB 数据（在 3400 个节点上）。</li><li>2009 年 5 月，Yahoo 的团队使用 Hadoop 对 1 TB 的数据进行排序只花了 62 秒时间。</li><li>2009 年 6 月，Cloudera 的工程师 Tom White 编写的《Hadoop 权威指南》初版出版，后被誉为 Hadoop 圣经。</li><li>2009 年 7 月 ，Hadoop Core 项目更名为 Hadoop Common;</li><li>2009 年 7 月 ，MapReduce 和 Hadoop Distributed File System (HDFS) 成为 Hadoop 项目的独立子项目。</li><li>2009 年 7 月 ，Avro 和 Chukwa 成为 Hadoop 新的子项目。</li><li>2009 年 8 月，Hadoop 创始人 Doug Cutting 加入 Cloudera 担任首席架构师。</li><li>2009 年 10 月，首届 Hadoop World 大会在纽约召开。</li><li>2010 年 5 月 ，Avro 脱离 Hadoop 项目，成为 Apache 顶级项目。</li><li>2010 年 5 月 ，HBase 脱离 Hadoop 项目，成为 Apache 顶级项目。</li><li>2010 年 5 月，IBM 提供了基于 Hadoop 的大数据分析软件——InfoSphere BigInsights，包括基础版和企业版。</li><li>2010 年 9 月，Hive( Facebook) 脱离 Hadoop，成为 Apache 顶级项目。</li><li>2010 年 9 月，Pig 脱离 Hadoop，成为 Apache 顶级项目。</li><li><strong>2010年 -2011年，扩大的 Hadoop社区忙于建立大量的新组件（Crunch，Sqoop<strong><strong>，Flume</strong></strong>，Oozie</strong>等）来扩展 Hadoop<strong>的使用场景和可用性。</strong></li><li>2011 年 1 月，ZooKeeper 脱离 Hadoop，成为 Apache 顶级项目。</li><li>2011 年 3 月，Apache Hadoop 获得 Media Guardian Innovation Awards 。</li><li>2011 年 3 月， Platform Computing 宣布在它的 Symphony 软件中支持 Hadoop MapReduce API。</li><li><strong>2011年 5月，Mapr Technologies公司推出分布式文件系统和 MapReduce引擎——MapR Distribution for Apache Hadoop****。</strong></li><li>2011 年 5 月，HCatalog 1.0 发布。该项目由 Hortonworks 在 2010 年 3 月份提出，HCatalog 主要用于解决数据存储、元数据的问题，主要解决 HDFS 的瓶颈，它提供了一个地方来存储数据的状态信息，这使得 数据清理和归档工具可以很容易的进行处理。</li><li>2011 年 4 月，SGI（Silicon Graphics International）基于 SGI Rackable 和 CloudRack 服务器产品线提供 Hadoop 优化的解决方案。</li><li>2011 年 5 月，EMC 为客户推出一种新的基于开源 Hadoop 解决方案的数据中心设备——GreenPlum HD，以助其满足客户日益增长的数据分析需求并加快利用开源数据分析软件。Greenplum 是 EMC 在 2010 年 7 月收购的一家开源数据仓库公司。</li><li>2011 年 5 月，在收购了 Engenio 之后， NetApp 推出与 Hadoop 应用结合的产品 E5400 存储系统。</li><li>2011 年 6 月，Calxeda 公司发起了“开拓者行动”，一个由 10 家软件公司组成的团队将为基于 Calxeda 即将推出的 ARM 系统上芯片设计的服务器提供支持。并为 Hadoop 提供低功耗服务器技术。</li><li>2011 年 6 月，数据集成供应商 Informatica 发布了其旗舰产品，产品设计初衷是处理当今事务和社会媒体所产生的海量数据，同时支持 Hadoop。</li><li><strong>2011年 7月，Yahoo!和硅谷风险投资公司 Benchmark Capital创建了 Hortonworks</strong> <strong>公司，旨在让 Hadoop更加可靠，并让企业用户更容易安装、管理和使用 Hadoop。</strong></li><li>2011 年 8 月，Cloudera 公布了一项有益于合作伙伴生态系统的计划——创建一个生态系统，以便硬件供应商、软件供应商以及系统集成商可以一起探索如何使用 Hadoop 更好的洞察数据。</li><li>2011 年 8 月，Dell 与 Cloudera 联合推出 Hadoop 解决方案——Cloudera Enterprise。Cloudera Enterprise 基于 Dell PowerEdge C2100 机架服务器以及 Dell PowerConnect 6248 以太网交换机。</li><li>2012 年 3 月，企业必须的重要功能 HDFS NameNode HA 被加入 Hadoop 主版本。</li><li>2012 年 8 月，另外一个重要的企业适用功能 YARN 成为 Hadoop 子项目。</li><li>2012 年 10 月，第一个 Hadoop 原生 MPP 查询引擎 Impala 加入到了 Hadoop 生态圈。</li><li><strong>2014年 2月，Spark逐渐代替 MapReduce成为 Hadoop的缺省执行引擎，并成为 Apache基金会顶级项目。</strong></li><li>2015 年 2 月，Hortonworks 和 Pivotal 抱团提出“Open Data Platform”的倡议，受到传统企业如 Microsoft、IBM 等企业支持，但其它两大 Hadoop 厂商 Cloudera 和 MapR 拒绝参与。</li><li>2015 年 10 月，Cloudera 公布继 HBase 以后的第一个 Hadoop 原生存储替代方案——Kudu。</li><li>2015 年 12 月，Cloudera 发起的 Impala 和 Kudu 项目加入 Apache 孵化器。</li></ul><h1 id="二、Hadoop体系架构"><a href="#二、Hadoop体系架构" class="headerlink" title="二、Hadoop体系架构"></a>二、Hadoop体系架构</h1><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Hadoop Distributed File System(HDFS)是一个运行在商用硬件平台上的分布式文件系统。它和很多现存的分布式文件系统有很多相似之处。当然，和其他的分布式文件系统的区别也是很明显的。HDFS在廉价硬件平台上提供高可靠的文件服务，提供数据访问的高吞吐量，适合那些运行在大数据集上的应用。HDFS并不完全符合POSIX文件系统方面的标准，这是因为HDFS运行环境和POSIX filesystem适用的环境是不同。HDFS支持对文件系统数据的流式访问。HDFS最初是为Apache Nutch搜索引擎项目设计的。现在HDFS是Apache Hadoop的一个子项目。</p><h3 id="假定和目标"><a href="#假定和目标" class="headerlink" title="假定和目标"></a>假定和目标</h3><p><strong>Hardware Failure</strong></p><p>硬件失效是很普通的情况而不是什么异常。HDFS运行环境可能包含数百台服务器，每台机器存储着文件系统的部分数据。事实上这些服务器的数据已经很大了，而且每一台机器都有不小的可能性会失败，这就导致HDFS部件并不总是正常工作的。因此，检测失败并且能够迅速的恢复是HDFS的核心设计目标。</p><p><strong>Stream Data Access</strong></p><p>运行在HDFS上的应用需要流式的访问他们的数据集。HDFS应用不像 那些在通用的文件系统上操作的应用。HDFS是面向批处理操作而不是那些user交互操作。HDFS侧重于高吞吐量而不是低延迟。POSIX标准的一些需求并不适合面向HDFS的应用，因此为了达到高吞吐量而在某些方面违反了Posix 标准。</p><p><strong>Large Data Sets</strong></p><p>运行在HDFS上的应用操纵的都是大数据集。一个典型的HDFS文件的尺寸是GB~TB大小。因此，HDFS针对大文件进行了优化。通过把一个文件分散到集群内的数千个节点，来提供更高的数据带宽。HDFS应该能够支持千万级的文件数目。</p><p><strong>Append-writes and File Syncs</strong></p><p>大部分HDFS应用的文件操作模式是写一次读多次。HDFS提供了两个高级功能：hflush和append。hflush提供read一致性和数据持久性。使得文件的最后一块对文件的读用户都可见。Append提供了一种机制能够重新打开关闭的文件添加额外的数据。</p><p><strong>Move Computation is Cheaper than Moving Data</strong></p><p>当计算在数据保存的节点附近时，效率会更高，尤其当操作的数据非常大的时候。就近计算使得网络消耗和系统吞吐量都最小。根据这个原则，移动计算到数据的保存位置而不是把数据移动到计算节点。HDFS向应用提供了接口：移动计算到数据存放位置。</p><p><strong>Protability Across Heterogeneous Hardware and Software Platforms</strong></p><p>HDFS很容易的在不同平台移植。这个特性使得HDFS被很多应用采纳为平台。</p><h3 id="NameNode-and-DataNodes"><a href="#NameNode-and-DataNodes" class="headerlink" title="NameNode and DataNodes"></a>NameNode and DataNodes</h3><p>HDFS采用master&#x2F;slave体系结构。HDFS集群包含一个NameNode，用来管理文件系统的名空间以及管理Clients访问文件的权限。此外，HDFS还包括一定数目的DataNodes，用来管理所在机器的存储空间（通常每台机器只有一个DataNodes）。HDFS通过Namenode向用户提供一个 文件系统名空间，允许用户存储数据为HDFS files。在HDFS内部，一个文件则被分割成很多块，这些块被存储在多个DataNodes中。Namenode执行文件系统名空间操做如open, close, rename文件和目录，同时负责到DataNodes节点的块映射。DataNodes负责Client读写数据请求，DataNodes还会执行block的创建，删除以及在block的复制。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311417085.png" alt="img"></p><p>NameNode和DataNode是运行在普通机器上的软件，这些机器一般为GNU&#x2F;Linux操作系统。HDFS是用Java语言实现的，因此任何支持Java的机器都可以运行NameNode和DataNode软件。使用移植性很强的Java语言意味着HDFS的可部署范围非常之广。典型的部署是NameNode使用一个特定的机器，集群中的其他机器节点，每一个上面运行一个DataNode。虽然HDFS架构本身并不排斥一台机器运行多个DataNode，但是实际部署中很少这样用。</p><p>集群中仅有一个NameNode极大的简化了系统架构。NameNode是系统的仲裁者，负责HDFS所有的元数据。NameData不会经手任何user data。</p><h2 id="数据复制（Data-Replication）"><a href="#数据复制（Data-Replication）" class="headerlink" title="数据复制（Data Replication）"></a>数据复制（Data Replication）</h2><p>HDFS能可靠的存储非常大的文件到集群中的多个机器上。每个文件被分割为连续的block，除了最后一块，文件中的每个块尺寸相同。文件的block被复制多份提供容错能力。可以为每一个文件指定块尺寸和复制因子，复制因子可以在文件创建的时候指定也可以在稍候修改。HDFS中的文件在任何时候只能有一个writer</p><p>NameNode决定何时做block复制。它周期性的从集群的每个DataNode接收Heartbeat和Block report。从DataNode接收到Heartbeat意味着DataNode工作正常。Block report包含一个DataNode的所有blocks列表。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311421937.png" alt="img"></p><h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><p>Apache YARN（Yet Another Resource Negotiator的缩写）是Hadoop的集群资源管理系统。YARN被引入Hadoop 2，最初是为了改善Map Reduce的实现，但他具有足够的通用性，同样可以支持其他的分布式计算模式。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311422324.png" alt="img"></p><p>YARN 通过两类长期的守护进程提供自己的核心服务</p><ul><li>resource manager：管理集群上资源使用的资源管理器</li><li>node manager：运行在集群中所有节点上且能够启动和监控容器（container）的节点管理器。</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311422809.png" alt="img"></p><p>为了在YARN上运行一个应用。首先，客户端联系资源管理器，要求他运行一个application master进程。然后资源管理器找到一个能够在容器中启动application master的节点管理器（步骤2a和2b）。准确的说，application master一旦运行起来以后能做什么依赖于应用本身。有可能是所处容器中简单运行一个运算，然后将结果返回给客户端。或者向资源管理器请求更多的容器（步骤3），以用于运行一个分布式计算（步骤4a和4b）。</p><p>YARN的基本构想是将资源管理器和作业调度器&#x2F;监控器分开成两个单独的进程。这个想法是为了拥有一个全局的资源管理器（RM）和每一个应用都有一个应用控制器。应用可以是一个单独的作业也可以是一组作业。</p><p>ResourceManager和NodeManager构成数据计算框架。RM是最终的权威仲裁系统中的所有应用的资源分配。NodeManager是框架在每台机器中负责containers的代理，监控它们的资源使用（内存、CPU、磁盘和网络）和将其汇报给ResourceManager&#x2F;调度器。</p><p>每个应用程序的ApplicationMaster实际上是框架指定的库负责从RM谈判获取资源并和MM一起工作来执行和监控任务。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311422910.gif" alt="img"></p><p>ResourceManager有两个主要的组成部分：调度器(Scheduler)和应用管理器(ApplicationsManager)。</p><p>调度器负责给各个正在运行的拥有相似的约束如容量，队列等的应用分配资源。调度器是一个纯粹的调度器而不负责监控或者跟踪应用的状态。他也不负责恢复由于应用失效或者硬件失效而失败的任务。调度器根据应用的资源需求来执行它的调度。而不是根据一个抽象资源“容器”包含的元素例如内存、CPU、磁盘和网络等</p><p>调度器是一个可插拔的组件负责将资源分配给各种各样的队列、应用等。目前的容量调度器和公平调度器将成为一些插件的例子。</p><p>应用管理器负责接收作业的提交、选择第一个容器用来运行应用指定的应用控制器和提供当ApplicationMaster容器失效时的重启。每个应用的ApplicationMaster负责从调度器那里谈判获取合适的资源容器，跟踪他们的状态和监控过程。</p><p>hadoop-2.x中的MapReduce兼容前面稳定的版本（hadoop-1.x）。这就意味着所有的MapReduce作业只需要再编译一次无需做任何改变就可以运行在YARN上。</p><h1 id="三、常见大数据产品框架"><a href="#三、常见大数据产品框架" class="headerlink" title="三、常见大数据产品框架"></a>三、常见大数据产品框架</h1><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311429550.png" alt="Hadoop大数据应用生态中最主要的组件及其关系"></p><p><strong>HDFS（Hadoop分布式文件系统）</strong></p><p>源自于Google的GFS论文，发表于2003年10月，HDFS是GFS的实现版。HDFS是Hadoop体系中数据存储管理的基础，它是一个高度容错的系统，能检测和应对硬件故障，在低成本的通用硬件上运行。HDFS简化了文件的一致性模型，通过流式数据访问，提供高吞吐量应用程序数据访问功能，适合带有大型数据集的应用程序。HDFS提供一次写入多次读取的机制，数据以块的形式，同时分布存储在集群的不同物理机器上。</p><p><strong>MapReduce（分布式计算框架）</strong></p><p>源自于Google的MapReduce论文，发表于2004年12月，HadoopMapReduce是GoogleMapReduce克隆版。MapReduce是一种分布式计算模型，用以进行海量数据的计算。它屏蔽了分布式计算框架细节，将计算抽象成Map和Reduce两部分，其中Map对数据集上的独立元素进行指定的操作，生成键值对形式中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果。</p><p><strong>HBase（分布式列存数据库）</strong></p><p>源自Google的BigTable论文，发表于2006年11月，HBase是GoogleBigTable的实现。HBase是一个建立在HDFS之上，面向结构化数据的可伸缩、高可靠、高性能、分布式和面向列的动态模式数据库。HBase采用了BigTable的数据模型，即增强的稀疏排序映射表（Key&#x2F;Value），其中，键由行关键字、列关键字和时间戳构成。HBase提供了对大规模数据的随机、实时读写访问，同时，HBase中保存的数据可以使用MapReduce来处理，它将数据存储和并行计算完美地结合在一起。</p><p><strong>ZooKeeper（分布式协作服务）</strong></p><p>源自Google的Chubby论文，发表于2006年11月，ZooKeeper是Chubby实现版。ZooKeeper的主要目标是解决分布式环境下的数据管理问题，如统一命名、状态同步、集群管理、配置同步等。Hadoop的许多组件依赖于ZooKeeper，它运行在计算机集群上面，用于管理Hadoop操作。</p><p><strong>Hive（数据仓库）</strong></p><p>由Facebook开源，最初用于解决海量结构化的日志数据统计问题。Hive定义了一种类似SQL的查询语言（HQL），将SQL转化为MapReduce任务在Hadoop上执行，通常用于离线分析。HQL用于运行存储在Hadoop上的查询语句，Hive使不熟悉MapReduce开发人员也能编写数据查询语句，然后这些语句被翻译为Hadoop上面的MapReduce任务。</p><p><strong>Pig（adhoc脚本）</strong></p><p>由yahoo开源，其设计动机是提供一种基于MapReduce的adhoc（计算在query时发生）数据分析工具。Pig定义了一种数据流语言——PigLatin，它是MapReduce编程的复杂性的抽象，Pig平台包括运行环境和用于分析Hadoop数据集的脚本语言（PigLatin）。其编译器将PigLatin翻译成MapReduce程序序列，将脚本转换为MapReduce任务在Hadoop上执行，通常用于进行离线分析。</p><p><strong>Sqoop（数据ETL&#x2F;同步工具）</strong></p><p>是SQL to Hadoop的缩写，主要用于传统数据库和Hadoop之前传输数据。数据的导入和导出本质上是MapReduce程序，充分利用了MR的并行化和容错性。Sqoop利用数据库技术描述数据架构，用于在关系数据库、数据仓库和Hadoop之间转移数据。</p><p><strong>Flume（日志收集工具）</strong></p><p>是Cloudera开源的日志收集系统，具有分布式、高可靠、高容错、易于定制和扩展的特点。它将数据从产生、传输、处理并最终写入目标的路径的过程抽象为数据流，在具体的数据流中，数据源支持在Flume中定制数据发送方，从而支持收集各种不同协议数据。同时，Flume数据流提供对日志数据进行简单处理的能力，如过滤、格式转换等。此外，Flume还具有能够将日志写往各种数据目标（可定制）的能力。总的来说，Flume是一个可扩展、适合复杂环境的海量日志收集系统，当然也可以用于收集其他类型数据。</p><p><strong>Mahout（数据挖掘算法库）</strong></p><p>起源于2008年，最初是ApacheLucent的子项目，它在极短的时间内取得了长足的发展，现在是Apache的顶级项目。Mahout的主要目标是创建一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便、快捷地创建智能应用程序。Mahout现在已经包含了聚类、分类、推荐引擎（协同过滤）和频繁集挖掘等广泛使用的数据挖掘方法。除了算法，Mahout还包含数据的输入&#x2F;输出工具、与其他存储系统（如数据库、MongoDB或Cassandra）集成的数据挖掘支持架构。</p><p><strong>YARN（分布式资源管理器）</strong></p><p>是下一代MapReduce，即MRv2，是在第一代MapReduce基础上演变而来的，主要是为了解决原始Hadoop扩展性较差，不支持多计算框架而提出的。YARN是下一代Hadoop计算平台，是一个通用的运行时框架，用户可以编写自己的计算框架，在该运行环境中运行。</p><p><strong>Mesos（分布式资源管理器）</strong></p><p>是一个诞生于UCBerkeley的研究项目，现已成为Apache项目，当前有一些公司使用Mesos管理集群资源，如Twitter。与YARN类似，Mesos是一个资源统一管理和调度的平台，同样支持诸如MR、steaming等多种运算框架。</p><p><strong>Spark（内存DAG计算模型）</strong></p><p>是一个Apache项目，被标榜为“快如闪电的集群计算”，它拥有一个繁荣的开源社区，并且是目前最活跃的Apache项目。最早Spark是UCBerkeleyAMPLab所开源的类HadoopMapReduce的通用并行计算框架，Spark提供了一个更快、更通用的数据处理平台。和Hadoop相比，Spark可以让你的程序在内存中运行时速度提升100倍，或者在磁盘上运行时速度提升10倍。</p><p><strong>SparkGraphX</strong></p><p>最先是伯克利AMPLab的一个分布式图计算框架项目，目前整合在Spark运行框架中，为其提供BSP大规模并行图计算能力。</p><p><strong>SparkMLlib</strong></p><p>一个机器学习库，它提供了各种各样的算法，这些算法用来在集群上针对分类、回归、聚类、协同过滤等。</p><p><strong>Kafka</strong></p><p>Linkedin于2010年12月开源的消息系统，主要用于处理活跃的流式数据。活跃的流式数据在Web网站应用中非常常见，这些数据包括网站的PV（PageView），用户访问了什么内容，搜索了什么内容等。这些数据通常以日志的形式记录下来，然后每隔一段时间进行一次统计处理。</p><p><strong>ApachePhoenix</strong></p><p>HBase的SQL驱动（HBaseSQL接口）,Phoenix使得HBase支持通过JDBC的方式进行访问，并将你的SQL查询转换成HBase的扫描和相应的动作。</p><p><strong>ApacheAmbari</strong></p><p>安装部署配置管理工具，其作用就是创建、管理、监视Hadoop的集群，是为了让Hadoop以及相关的大数据软件更容易使用的一个Web工具。</p><h1 id="四、HDFS"><a href="#四、HDFS" class="headerlink" title="四、HDFS"></a>四、HDFS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HDFS即Hadoop分布式文件系统（Hadoop Distributed File System），它的设计目标是把超大数据集存储到网络中的多台普通商用计算机上，并提供高可靠性和高吞吐率的服务。分布式文件系统要比普通磁盘文件系统复杂，因为它要引入网络编程；分布式文件系统要容忍节点失效，这也是一个很大的挑战。</p><p><strong>HDFS的设计前提和目标如下。</strong></p><p>（1）专为存储超大文件而设计：HDFS应该能够支持GB级别大小的文件；它应该能够提供很大的数据带宽并且能够在集群中拓展到成百上千个节点；它的一个实例应该能够支持千万数量级别的文件。</p><p>（2）适用于流式的数据访问：HDFS适用于批处理的情况而不是交互式处理；它的重点是保证高吞吐量而不是低延迟的用户响应。</p><p>（3）容错性：完善的冗余备份机制。</p><p>（4）支持简单的一致性模型：HDFS需要支持一次写入多次读取的模型，而且写入过程文件不会经常变化。</p><p>（5）移动计算优于移动数据：HDFS提供了使应用计算移动到离它最近数据位置的接口。</p><p>（6）兼容各种硬件和软件平台。</p><p><strong>HDFS不适合的场景如下。</strong></p><p>（1）大量小文件：文件的元数据都存储在NameNode内存中，大量小文件意味着元数据的增加，会占用大量内存。</p><p>（2）低延迟数据访问：HDFS是专门针对高数据吞吐量而设计的。</p><p>（3）多用户写入：因为会导致一致性维护的困难。</p><h2 id="主要组件和架构"><a href="#主要组件和架构" class="headerlink" title="主要组件和架构"></a>主要组件和架构</h2><p>HDFS主要由3个组件构成，分别是Name Node、SecondaryNameNode和DataNode, HDFS是以Master&#x2F;Slave（主从）模式运行的，其中NameNode、SecondaryNameNode运行在Master节点，DataNode运行Slave节点上。NameNode和DataNode架构如图所示。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311432821.png" alt="img"></p><h2 id="HDFS架构分析"><a href="#HDFS架构分析" class="headerlink" title="HDFS架构分析"></a>HDFS架构分析</h2><h3 id="数据块（Block）"><a href="#数据块（Block）" class="headerlink" title="数据块（Block）"></a>数据块（Block）</h3><p>磁盘数据块是磁盘读写的基本单位，与普通文件系统类似，HDFS也会把文件分块来存储。HDFS默认数据块大小为128MB，而磁盘块一般为512B。HDFS块为何如此之大呢？块增大可以减少寻址时间与文件传输时间的比例，若寻址时间为10ms，磁盘传输速率为100MB&#x2F;s，那么寻址与传输比仅为1%。当然，磁盘块太大也不好，因为一个MapReduce通常以一个块作为输入，块过大会导致整体任务数量过小，降低作业处理速度。数据块是存储在DataNode中的，为了能够容错，数据块是以多个副本的形式分布在集群中的，副本数量默认为3，后面会专门介绍数据块的复制机制。HDFS按块存储还有如下好处。</p><ul><li>文件可以任意大，也不用担心单个节点磁盘容量小于文件的情况。</li><li>简化了文件子系统的设计，子系统只存储文件块数据，而文件元数据则交由其他系统（NameNode）管理。</li><li>有利于备份和提高系统可用性，这得益于以块为单位进行备份的设计，HDFS默认备份数量为3。</li><li>有利于负载均衡。</li></ul><h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><p>NameNode中的元信息当一个客户端请求一个文件或者存储一个文件时，它需要先知道具体到哪个DataNode上存取，获得这些信息后，客户端再直接和这个DataNode进行交互，而这些信息的维护者就是NameNode。NameNode管理着文件系统的命名空间，它维护文件系统树及树中的所有文件和目录。NameNode也负责维护所有这些文件或目录的打开、关闭、移动、重命名等操作。对于实际文件数据的保存与操作，都是由DataNode负责的。当一个客户端请求数据时，它仅仅是从NameNode中获取文件的元信息，而具体的数据传输不需要经过NameNode，是由客户端直接与相应的DataNode进行交互的。</p><p>NameNode保存元信息的种类有：</p><ul><li>文件名目录名及它们之间的层级关系；</li><li>文件目录的所有者及其权限；</li><li>每个文件块的名及文件有哪些块组成。</li></ul><p>需要注意的是，NameNode元信息并不包含每个块的位置信息，这些信息会在NameNode启动时从各个DataNode获取并保存在内存中，因为这些信息会在系统启动时由数据节点重建。把块位置信息放在内存中，在读取数据时会减少查询时间，增加读取效率。</p><p>NameNode也会实时通过心跳机制和DataNode进行交互，实时检查文件系统是否运行正常。不过NameNode元信息会保存各个块的名称及文件由哪些块组成。一般来说，一条元信息记录会占用200B内存空间。假设块大小为64MB，备份数量是3，那么一个1GB大小的文件将占用16×3&#x3D;48个文件块。如果现在有1000个1MB大小的文件，则会占用1000×3&#x3D;3000个文件块（多个文件不能放到一个块中）。我们可以发现，如果文件越小，存储同等大小文件所需要的元信息就越多，所以，Hadoop更喜欢大文件。</p><p>元信息的持久化在<strong>NameNode</strong>中存放元信息的文件是<strong>fsimage</strong>。在系统运行期间所有对元信息的操作都保存在内存中并被持久化到另一个文件<strong>edits</strong>中，并且edits文件和fsimage文件会被SecondaryNameNode周期性地合并（合并过程会在SecondaryNameNode中详细介绍）。运行NameNode会占用大量内存和I&#x2F;O资源，一般NameNode不会存储用户数据或执行MapReduce任务。为了简化系统的设计，Hadoop只有一个NameNode，这也就导致了Hadoop集群的单点故障问题。因此，对NameNode节点的容错尤其重要，Hadoop提供了如下两种机制来解决。</p><ul><li>将Hadoop元数据写入到本地文件系统的同时再实时同步到一个远程挂载的网络文件系统（NFS）。</li><li>运行一个SecondaryNameNode，它的作用是与NameNode进行交互，定期通过编辑日志文件合并命名空间镜像。当NameNode发生故障时，它会通过自己合并的命名空间镜像副本来恢复。需要注意的是SecondaryNameNode保存的状态总是滞后于NameNode，所以这种方式难免会导致丢失部分数据。</li></ul><h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p>DataNode是HDFS中的Worker节点，它负责存储数据块，也负责为系统客户端提供数据块的读写服务，同时还会根据NameNode的指示来进行创建、删除和复制等操作。此外，它还会通过心跳定期向NameNode发送所存储文件块列表信息。当对HDFS文件系统进行读写时，NameNode告知客户端每个数据驻留在哪个DataNode，客户端直接与DataNode进行通信，DataNode还会与其他DataNode通信，复制这些块以实现冗余。</p><h3 id="SecondaryNameNode"><a href="#SecondaryNameNode" class="headerlink" title="SecondaryNameNode"></a>SecondaryNameNode</h3><p>要注意，SecondaryNameNode并不是NameNode的备份。我们从前面的介绍已经知道，所有HDFS文件的元信息都保存在NameNode的内存中。在NameNode启动时，它首先会加载<strong>fsimage</strong>到内存中，在系统运行期间，所有对NameNode的操作也都保存在内存中，同时为了防止数据丢失，这些操作又会不断被持久化到本地<strong>edits</strong>文件中。edits文件的目的是为了提高系统的操作效率，NameNode在更新内存中的元信息之前都会先将操作写入edits文件。在NameNode重启的过程中，edits会和fsimage合并到一起，但是合并的过程会影响到Hadoop重启的速度，SecondaryNameNode就是为了解决这个问题而诞生的。SecondaryNameNode的角色就是定期合并edits和fsimage文件，我们来看一下合并的步骤。</p><p>（1）合并之前告知NameNode把所有的操作写到新的edites文件并将其命名为edits.new。</p><p>（2）SecondaryNameNode从NameNode请求fsimage和edits文件。</p><p>（3）SecondaryNameNode把fsimage和edits文件合并成新的fsimage文件。</p><p>（4）NameNode从SecondaryNameNode获取合并好的新的fsimage并将旧的替换掉，并把edits用（1）创建的edits.new文件替换掉。</p><p>（5）更新fstime文件中的检查点。</p><p>最后再总结一下整个过程中涉及NameNode中的相关文件。</p><ul><li>fsimage：保存的是上个检查点的HDFS的元信息。</li><li>edits：保存的是从上个检查点开始发生的HDFS元信息状态改变信息。</li><li>fstime：保存了最后一个检查点的时间戳。</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311434452.jpg" alt="img"></p><h2 id="文件操作流程"><a href="#文件操作流程" class="headerlink" title="文件操作流程"></a>文件操作流程</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>HDFS有一个文件系统实例，客户端通过调用这个实例的open（）方法就可以打开系统中希望读取的文件。HDFS通过RPC调用NameNode获取文件块的位置信息，对于文件的每一个块，NameNode会返回含有该块副本的DataNode的节点地址。另外，客户端还会根据网络拓扑来确定它与每一个DataNode的位置信息，从离它最近的那个DataNode获取数据块的副本，最理想的情况是数据块就存储在客户端所在的节点上。HDFS会返回一个FSDataInputStream对象，FSDataInputStream类转而封装成DFSDataInputStream对象，这个对象管理着与DataNode和NameNode的I&#x2F;O，具体过程是：</p><ul><li>客户端发起读请求。</li><li>客户端与NameNode得到文件的块及位置信息列表。</li><li>客户端直接和DataNode交互读取数据。</li><li>读取完成关闭连接。图42给出了上述读文件的过程示意。</li></ul><p>当FSDataInputStream与DataNode通信时遇到错误，它会选取另一个较近的DataNode，并为出故障的DataNode做标记以免重复向其读取数据。FSDataInputStream还会对读取的数据块进行校验和确认，发现块损坏时也会重新读取并通知NameNode。这样设计的巧妙之处有：</p><ul><li>让客户端直接联系DataNode检索数据，可以使HDFS扩展到大量的并发客户端，因为数据流就是分散在集群的每个节点上的，在运行MapReduce任务时，每个客户端就是一个DataNode节点。</li><li>NameNode仅需要相应块的位置信息请求（位置信息在内存中，速度极快），否则随着客户端的增加，NameNode会很快成为瓶颈。这里有必要理解Hadoop的网络拓扑。在海量数据处理过程中，主要限制因素是节点之间的带宽。衡量两个节点之间的带宽往往很难实现，在这里Hadoop采取了一个简单的方法，它把网络拓扑看成一棵树，两个节点的距离等于它们到最近共同祖先距离的总和，而树的层次可以这么划分：<ul><li>同一节点中的进程；</li><li>同一机架上的不同节点；</li><li>同一数据中心不同机架；</li><li>不同数据中心的节点。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311434829.png" alt="img"></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>HDFS有一个分布式文件系统（Distribute File System,DFS）实例，客户端通过调用这个实例的create（）方法就可以创建文件。DFS会发送给NameNode一个RPC调用，在文件系统的命名空间创建一个新文件，在创建文件前NameNode会做一些检查，看看文件是否存在，客户端是否有创建权限等。若检查通过，NameNode会为创建文件写一条记录到本地磁盘的EditLog；若不通过会向客户端抛出IOException。创建成功之后DFS会返回一个FSDataOutputStream对象，客户端由此开始写入数据。同读文件过程一样，</p><p>FSDataOutputStream类转而封装成DFSDataOutputStream对象，这个对象管理着与DataNode和NameNode的I&#x2F;O，具体过程是：</p><ul><li>客户端在向NameNode请求之前先写入文件数据到本地文件系统的一个临时文件。</li><li>待临时文件达到块大小时开始向NameNode请求DataNode信息。</li><li>NameNode在文件系统中创建文件并返回给客户端一个数据块及其对应DataNode的地址列表（列表中包含副本存放的地址）。</li><li>客户端通过上一步得到的信息把创建临时文件块Flush到列表中的第一个DataNode。</li><li>当文件关闭，NameNode会提交这次文件创建，此时文件在文件系统中可见。</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311435709.png" alt="img"></p><h2 id="HDFS命令"><a href="#HDFS命令" class="headerlink" title="HDFS命令"></a>HDFS命令</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>创建目录用<strong>mkdir</strong>命令。在Hadoop上创建目录与在Linux上创建目录类似，根目录用“&#x2F;”表示。下面是一些应用示例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> /test<br><span class="hljs-comment">#创建文件及其子目录</span><br>hadoop fs -<span class="hljs-built_in">mkdir</span> -p /dira/dirb<br></code></pre></td></tr></table></figure><h3 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h3><p>与Linux的ls命令类似，Hadoop也有一条查看文件列表的命令，其完整用法是hadoop fs ls ＜args＞，其中＜args＞表示可选参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#显示文件及其子目录</span><br>hadoop fs -<span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><h3 id="上传文件到HDFS"><a href="#上传文件到HDFS" class="headerlink" title="上传文件到HDFS"></a>上传文件到HDFS</h3><p>将文件从本地复制到HDFS集群称为文件上传。有两种命令可以使用，一种是“<strong>hadoop fs -put</strong>”，另一种是“<strong>hadoop fs -copyFromLocal</strong>”。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#将a.data上传到HDFS <span class="hljs-regexp">/test/i</span>nput目录下<br>hadoop fs -put <span class="hljs-regexp">/home/</span>a.data <span class="hljs-regexp">/test/i</span>nput<br></code></pre></td></tr></table></figure><h3 id="下载文件到本地"><a href="#下载文件到本地" class="headerlink" title="下载文件到本地"></a><strong>下载文件到本地</strong></h3><p>将文件从HDFS集群复制到本地称为文件下载。有两种命令可以使用，一种是“hadoop fs -get”，另一种是“hadoop fs -copyToLocal”。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#将HDFS上的<span class="hljs-regexp">/test/i</span>nput<span class="hljs-regexp">/a.data 下载到 /</span>home/hadoop目录下<br>Hadoop fs - get <span class="hljs-regexp">/test/i</span>nput<span class="hljs-regexp">/a.data /</span>home/hadoop<br></code></pre></td></tr></table></figure><h3 id="查看HDFS文件内容"><a href="#查看HDFS文件内容" class="headerlink" title="查看HDFS文件内容"></a><strong>查看HDFS文件内容</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop fs -text <span class="hljs-regexp">/input/</span>a.txt<br>hadoop fs -cat <span class="hljs-regexp">/input/</span>b.txt<br>hadoop fs -tail <span class="hljs-regexp">/input/</span>c.txt<br></code></pre></td></tr></table></figure><h3 id="删除HDFS文件"><a href="#删除HDFS文件" class="headerlink" title="删除HDFS文件"></a>删除HDFS文件</h3><p>可以用“hadoop fs -rm”删除HDFS集群中的文件。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">hadoop fs -<span class="hljs-keyword">rm</span> /<span class="hljs-keyword">test</span>/<span class="hljs-keyword">input</span>/a.txt<br></code></pre></td></tr></table></figure><h1 id="五、Hadoop计算"><a href="#五、Hadoop计算" class="headerlink" title="五、Hadoop计算"></a>五、Hadoop计算</h1><h2 id="MapReduce通俗解释"><a href="#MapReduce通俗解释" class="headerlink" title="MapReduce通俗解释"></a>MapReduce通俗解释</h2><p>图书馆要清点图书数量，有10个书架，管理员为了加快统计速度，找来了10个同学，每个同学负责统计一个书架的图书数量。</p><p>张同学统计 书架1</p><p>王同学统计 书架2</p><p>刘同学统计 书架3</p><p>……</p><p>过了一会儿，10个同学陆续到管理员这汇报自己的统计数字，管理员把各个数字加起来，就得到了图书总数。</p><p>这个过程就可以理解为MapReduce的工作过程。</p><p><strong>两个核心操作：</strong></p><ul><li>map。管理员分配哪个同学统计哪个书架，每个同学都进行相同的“统计”操作，这个过程就是map。</li><li>reduce。每个同学的结果进行汇总，这个过程是reduce。</li></ul><h2 id="过程拆解"><a href="#过程拆解" class="headerlink" title="过程拆解"></a>过程拆解</h2><p>下面通过一个景点案例（单词统计）看MapReduce是如何工作的。</p><p>有一个文本文件，被分成了4份，分别放到了4台服务器中存储</p><p>Text1：the weather is good</p><p>Text2：today is good</p><p>Text3：good weather is good</p><p>Text4：today has good weather</p><p>现在要统计出每个单词的出现次数。</p><h3 id="拆分单词（map）"><a href="#拆分单词（map）" class="headerlink" title="拆分单词（map）"></a>拆分单词（map）</h3><h1 id="六、项目-好友推荐"><a href="#六、项目-好友推荐" class="headerlink" title="六、项目-好友推荐"></a>六、项目-好友推荐</h1><h2 id="需求简介"><a href="#需求简介" class="headerlink" title="需求简介"></a>需求简介</h2><p>在现实生活中，如果你的好友A和B都有一个共同的好友C，那么C很可能是你的潜在好友。如果C在你的朋友的关系中出现的次数越多，这种概率越大。</p><p><strong>问题描述</strong></p><p>给出以下数据，为每个人推荐好友，按照共同好友的多少排序(最多10个)</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311446271.png" alt="1"></p><p><strong>测试数据</strong></p><p><strong>输出格式</strong></p><p>用户1 好友推荐1, 好友推荐2, 好友推荐3</p><p>用户2 好友推荐4,好友推荐5, 好友推荐6</p><p>按照推荐度排序，每个用户最多推荐10个。</p><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>社交网站上的各个用户以及用户之间的相互关注可以抽象为一个图。以下图为例：</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311447354.jpg" alt="2"></p><p>顶点A、B、C到I分别是社交网站的用户，两顶点之间的边表示两顶点代表的用户之间相互关注。那么如何根据用户之间相互关注所构成的图，来向每个用户推荐好友呢？</p><p>现在我们以上图为例，介绍下如何利用用户之间相互关注所构成的图，来向每个用户推荐好友。首先我们不得不假设的是如果两用户之间相互关注，那么我们认为他们认识或者说是现实中的好友，至少应该认识。假设我们现在需要向用户I推荐好友，我们发现用户I的好友有H、G、C。其中H的好友还有A，G的好友还有F，C的好友还有B、F。那么用户I、H、G、C、A、B、F极有可能是同一个圈子里的人。我们应该把用户A、B、F推荐给用户I认识。进一步的想，用户F跟两位I的好友C、G是好友，而用户A、B都分别只跟一位I的好友是好友，那么相对于A、B来说，F当然更应该推荐给用户I认识。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="数据清洗："><a href="#数据清洗：" class="headerlink" title="数据清洗："></a><strong>数据清洗：</strong></h3><p>在Map过程中过滤掉每行通过”\t”分割后长度不为2的数据。</p><h3 id="Map设计："><a href="#Map设计：" class="headerlink" title="Map设计："></a>Map设计：</h3><ol><li>从单行数据（0 1,3,4,5,7）入手。</li><li>得出1. 0和1是直接好友，1和3是间接好友。</li><li>依照直接或者间接关系,打上标签<ul><li>如0号和1号是直接好友,我们建立<strong>键值对</strong>,打上标签为(<strong>0 : 1,1</strong>)</li><li>如1号和3号暂时是间接好友,我们建立<strong>键值对</strong>,打上标签为(<strong>0 : 2,3</strong>)</li></ul></li></ol><p><strong>以此类推:</strong></p><ul><li>直接好友：首先对用户0号本身，将0与其好友打上标签。<br>结果为：(0: <strong>1</strong>,1) (0: <strong>1</strong>,3) (0: <strong>1</strong>,4) (0: <strong>1</strong>,5) (0: <strong>1</strong>,7)</li><li>间接好友：然后对于好友集合:笛卡尔乘积，互相打上标签2。1,3,4,5,7 X 1,3,4,5,7。(1: <strong>2</strong>,3) (3: <strong>2</strong>,1) (1: <strong>2</strong>,4) (4: <strong>2</strong>,1) 等…….</li></ul><p><strong>然后对于好友集合:笛卡尔乘积</strong></p><p>最终处理完成</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207311447502.png" alt="3"></p><h3 id="Reduce设计"><a href="#Reduce设计" class="headerlink" title="Reduce设计"></a>Reduce设计</h3><p>Reduce接收分三种情况：</p><ul><li><strong>第一种情况:(0,1,1),(0,1,3),(0,1,4)<br><strong>对于这情况(标签为1)-直接好友<br>如:(0: <strong>1</strong>,1) 告诉了我们</strong>0</strong>用户和<strong>1</strong>用户肯定是直接好友,所以我们不用把<strong>1</strong>用户推荐给<strong>0</strong>用户。</li><li><strong>第二种情况(标签为2)</strong><br><strong>说明是暂时的间接好友</strong><br><strong>如:(1: 2,4) 告诉了我们1用户和4用户暂时是间接好友关系,可以考虑进行推荐,我们的reduce过程便可以进行记录</strong></li><li><strong>第三种情况</strong>：如果又来了一个(1: <strong>2</strong>,4)呢?这说明了什么?<br><strong>说明1和4有两个共同好友</strong></li><li><strong>第四种情况</strong>：如果之后又出现(1: 1,4)呢?<br><strong>这说明1和4的好友关系被拆穿了,他们已经互相认识了,我们不再将4推荐给1了</strong></li></ul><p>实现：接收map传递的键值对,要求key为<strong>0</strong> 如 (0: <strong>2</strong>,3)</p><ol><li>创建一个容器进行记录(用HashMap**)(**<strong>用户id:共同好友数)</strong></li><li>如果标签为<strong>1</strong>,则置共同好友数为**-1,表示标记为黑名单**,因为他们本来就认识,之后一并移除</li><li>如果标签为<strong>2并且没在黑名单</strong>,便进行记录计数</li><li>如 map.put(3,1)表示3与之有一个共同好友,再来一个就是map.put(3,1+1)</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式面经-个人总结</title>
    <link href="/2022/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git面试题"><a href="#Git面试题" class="headerlink" title="Git面试题"></a>Git面试题</h1><h2 id="1-Git-中-merge-和-rebase-的区别"><a href="#1-Git-中-merge-和-rebase-的区别" class="headerlink" title="1.Git 中 merge 和 rebase 的区别"></a>1.Git 中 merge 和 rebase 的区别</h2><ul><li><p>git pull是<code>git fetch + git merge FETCH_HEAD</code>的缩写，所以默认情况下，<code>git pull</code>就是先fetch，然后执行merge操作，如果加-rebase参数，就是使用git rebase代替git merge更新本地仓库</p></li><li><p>merge 是合并的意思，rebase是复位基底的意思<br>现在我们有这样的两个分支,test和master，提交如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">     <span class="hljs-comment">D</span><span class="hljs-literal">---</span><span class="hljs-comment">E test</span><br>    <span class="hljs-comment">/</span><br><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">B</span><span class="hljs-literal">---</span><span class="hljs-comment">C</span><span class="hljs-literal">---</span><span class="hljs-comment">F master</span><br></code></pre></td></tr></table></figure><p>在master执行<code>git merge test</code>然后会得到如下结果：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">     <span class="hljs-comment">D</span><span class="hljs-literal">--------</span><span class="hljs-comment">E</span><br>    <span class="hljs-comment">/          \</span><br><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">B</span><span class="hljs-literal">---</span><span class="hljs-comment">C</span><span class="hljs-literal">---</span><span class="hljs-comment">F</span><span class="hljs-literal">---</span><span class="hljs-comment">G    test</span> <span class="hljs-string">,</span> <span class="hljs-comment">master</span><br></code></pre></td></tr></table></figure><p>在master执行<code>git rebase test</code>,然后得到如下结果：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">C</span><span class="hljs-literal">---</span><span class="hljs-comment">D</span><span class="hljs-literal">---</span><span class="hljs-comment">E</span><span class="hljs-literal">---</span><span class="hljs-comment">C `</span><span class="hljs-literal">---</span><span class="hljs-comment">F` test</span> <span class="hljs-string">,</span> <span class="hljs-comment">master</span><br></code></pre></td></tr></table></figure></li><li><p>可以看到merge操作会生成一个新的节点，之前提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的操作</p></li><li><p>通过上面可以看到，想要更好的提交树，使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点</p></li><li><p>在操作中。merge操作遇到冲突时候，当前merge不能继续下去。手动修改冲突内容后，add 修改，commit 就可以了<br>而rebase操作的话，会中断rebase，同时会提示去解决冲突。解决冲突后，将修改add后执行git rebase -continue继续操作，或者git rebase -skip忽略冲突</p></li></ul><h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><!-- GFM-TOC --><ul><li><a href="#git">Git</a><ul><li><a href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F">集中式与分布式</a></li><li><a href="#%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%99%A8">中心服务器</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81">工作流</a></li><li><a href="#%E5%88%86%E6%94%AF%E5%AE%9E%E7%8E%B0">分支实现</a></li><li><a href="#%E5%86%B2%E7%AA%81">冲突</a></li><li><a href="#fast-forward">Fast forward</a></li><li><a href="#%E5%82%A8%E8%97%8Fstashing">储藏（Stashing）</a></li><li><a href="#ssh-%E4%BC%A0%E8%BE%93%E8%AE%BE%E7%BD%AE">SSH 传输设置</a></li><li><a href="#gitignore-%E6%96%87%E4%BB%B6">.gitignore 文件</a></li><li><a href="#git-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88">Git 命令一览</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC --></li></ul></li></ul><h2 id="集中式与分布式"><a href="#集中式与分布式" class="headerlink" title="集中式与分布式"></a>集中式与分布式</h2><p>Git 属于分布式版本控制系统，而 SVN 属于集中式。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200656794.png"/> </div><br><p>集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。</p><p>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。</p><p>集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。</p><p>分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。</p><h2 id="中心服务器"><a href="#中心服务器" class="headerlink" title="中心服务器"></a>中心服务器</h2><p>中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。</p><p>Github 就是一个中心服务器。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。</p><p>Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208195941661.png"/> </div><br><ul><li>git add files 把文件的修改添加到暂存区</li><li>git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了</li><li>git reset – files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files</li><li>git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200014395.png"/> </div><br><p>可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。</p><ul><li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li><li>git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200543923.png"/> </div><br><h2 id="分支实现"><a href="#分支实现" class="headerlink" title="分支实现"></a>分支实现</h2><p>使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203219927.png"/> </div><br><p>新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203142527.png"/> </div><br><p>每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203112400.png"/> </div><br><p>合并分支也只需要改变指针即可。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203010540.png"/> </div><br><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203034705.png"/> </div><br><p>Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-section">=======</span><br>Creating a new branch is quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><h2 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast forward"></a>Fast forward</h2><p>“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。</p><p>可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git merge --<span class="hljs-keyword">no</span>-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev<br></code></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203639712.png"/> </div><br><h2 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h2><p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。</p><p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">$ git stash<br>Saved working directory and <span class="hljs-keyword">index</span> state \ <span class="hljs-string">&quot;WIP on master: 049d078 added the index file&quot;</span><br>HEAD <span class="hljs-keyword">is</span> now at <span class="hljs-number">049</span>d078 added the <span class="hljs-keyword">index</span> file (<span class="hljs-keyword">To</span> restore them <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;git stash apply&quot;</span>)<br></code></pre></td></tr></table></figure><p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。</p><h2 id="SSH-传输设置"><a href="#SSH-传输设置" class="headerlink" title="SSH 传输设置"></a>SSH 传输设置</h2><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p><p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。</p><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>忽略以下文件：</p><ul><li>操作系统自动生成的文件，比如缩略图；</li><li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li><li>自己的敏感信息，比如存放口令的配置文件。</li></ul><p>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 中进行查询。</p><h2 id="Git-命令一览"><a href="#Git-命令一览" class="headerlink" title="Git 命令一览"></a>Git 命令一览</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a29acce-f243-4914-9f00-f2988c528412.jpg" width=""> </div><br><p>比较详细的地址：<a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf">http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简明指南</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 : Git 教程</a></li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面经-个人总结</title>
    <link href="/2022/07/09/Redis%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/Redis%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据结构与对象"><a href="#一、数据结构与对象" class="headerlink" title="一、数据结构与对象"></a>一、数据结构与对象</h1><h2 id="1-Redis数据类型和应用场景"><a href="#1-Redis数据类型和应用场景" class="headerlink" title="1.Redis数据类型和应用场景"></a>1.Redis数据类型和应用场景</h2><p><strong>Redis五大数据类型，string，hash，list，set，zset</strong></p><ul><li><strong>string（字符串）</strong><ul><li><strong>一个字符串类型的值能存储最大容量是512M</strong></li><li>set&#x2F;get<ul><li>设置&#x2F;获取</li></ul></li><li>setex<ul><li>setex k4 10 v4</li><li>设置过期时间10s，然后给k4赋值为v4</li></ul></li><li>setnx<ul><li>setnx k1 v11</li><li>若k1存在，则不覆盖，否则，建立k1，并赋值v11</li></ul></li><li>mset&#x2F;get</li></ul></li><li><strong>hash（哈希）</strong></li><li><strong>list（列表）</strong><ul><li>lpush&#x2F;rpush<ul><li>从左边&#x2F;右边压入</li></ul></li><li>lrange<ul><li>指定范围，从左边获取</li></ul></li><li>lpop&#x2F;rpop<ul><li>从左边&#x2F;右边弹出</li></ul></li></ul></li><li><strong>set（集合）</strong></li><li><strong>zset（有序集合）</strong><ul><li>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构</li></ul></li></ul><h1 id="二、单机数据库的实现"><a href="#二、单机数据库的实现" class="headerlink" title="二、单机数据库的实现"></a>二、单机数据库的实现</h1><h2 id="1-Redis优缺点"><a href="#1-Redis优缺点" class="headerlink" title="1.Redis优缺点"></a>1.Redis优缺点</h2><ul><li><strong>CAP原理</strong><ul><li>C：Consistency 强一致性</li><li>A：Availability 可用性</li><li>P：Partition tolerance 分区容错性</li></ul></li><li><strong>分布式和集群</strong><ul><li><strong>分布式：</strong>不同的多台服务器上部署不同的服务器模块，它们之间通过RPC来通信和调用</li><li><strong>集群：</strong>不同的多台服务器上部署者相同的服务器模块，通过分布式调度软件统一调度</li></ul></li><li><strong>相对于memcache的不同</strong><ul><li>Redis支持数据持久化，可以将内存中的数据保存到磁盘中，重启时再次加载到内存中</li><li>Redis支持丰富的数据结构，list，set，hash，zset</li><li>Redis是单进程单线程，Memcached是单进程多线程</li></ul></li><li><strong>缺点</strong><ul><li>Redis主要消耗内存资源，数据库容量受到<strong>物理内存的限制</strong>，不能用作海量数据的高性能读写</li><li>因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上</li></ul></li></ul><h2 id="2-Redis线程模型"><a href="#2-Redis线程模型" class="headerlink" title="2.Redis线程模型"></a>2.Redis线程模型</h2><ul><li>单线程模型处理客户端请求</li><li>封装epoll函数实现读写事件的响应</li><li><strong>单线程效率高的原因</strong><ul><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题</li></ul></li></ul><h2 id="3-Redis持久化机制RDB和AOF"><a href="#3-Redis持久化机制RDB和AOF" class="headerlink" title="3.Redis持久化机制RDB和AOF"></a>3.Redis持久化机制RDB和AOF</h2><ul><li><p><strong>默认机制</strong></p><ul><li>默认是RDB持久</li><li>redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化，RDB是数据，AOF是写命令</li><li>同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整</li></ul></li><li><p><strong>RDB</strong><br>RDB（Redis Database）持久化机制，<strong>是对redis中的数据执行周期性的持久化</strong>，生成dump.rdb文件</p><ul><li><strong>snapshot快照</strong><ul><li>在指定时间间隔将内存的数据集快照写入磁盘，恢复时将快照直接读入内存</li><li>默认rdb参数，可以通过save 秒数 次数来修改rdb参数<ul><li>1分钟改1万次</li><li>5分钟改10次</li><li>15分钟改1次</li></ul></li></ul></li><li><strong>当执行save，bgsave，flushall，shutdown命令时，也会生成快照文件dump.rdb，其中flushall会生成空的dump文件</strong></li><li><strong>save和bgsave</strong><ul><li>save立即保存，不会等待RDB参数，另外save只保存，其他不管，因此会阻塞</li><li>bgsave下Redis会在后台异步进行快照操作，同时相应客户端请求</li></ul></li><li><strong>恢复</strong><ul><li>redis启动时，会自动加载dump.rdb文件，将快照加载到内存中</li></ul></li><li><strong>优点</strong><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备<ul><li>我们知道RDB每次生成的新dump文件都会覆盖旧文件，如果想保存每个时刻写入的快照文件，可以另外修改代码，按时间生成的dump文件，并传到备份机器</li></ul></li><li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>大规模数据比AOF快，直接将数据恢复到内存中，想对于AOF回放要快</li></ul></li><li><strong>缺点</strong><ul><li>一定时间间隔做一次持久化，若redis意外宕机，则会丢失最后一次快照的修改</li><li>每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</li></ul></li></ul></li><li><p><strong>AOF</strong><br>AOF（Append Only File）<strong>机制对每条写命令作为日志</strong>，以 append-only（追加） 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集，生成appendonly.aof文件</p><ul><li><strong>追加方式</strong><ul><li><strong>everysec</strong><ul><li>异步持久化，默认是每秒进行记录，最多丢失一秒的数据</li></ul></li><li><strong>always</strong><ul><li>同步持久化，每次修改都会同步，redis性能会大大降低</li></ul></li></ul></li><li><strong>恢复</strong><ul><li><strong>正常恢复</strong><ul><li>启动appendonly yes</li><li>将数据aof复制到对应目录</li><li>重新启动redis</li></ul></li><li><strong>异常恢复</strong><ul><li>redis-check-aof –fix appendonly.aof</li><li>dump也可以这样修复</li></ul></li></ul></li><li><strong>rewrite</strong><ul><li>AOF会越来越大，文件会越来越大，redis默认每个文件64M，当超过上一个文件大小一倍时，启动重写</li><li>在rewrite log的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来</li><li>在创建新日志文件的时候，老的日志文件还是照常写入</li><li>每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建</li><li>当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可</li></ul></li><li><strong>优点</strong><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据</li><li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合<strong>做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li></ul></li><li><strong>缺点</strong><ul><li>类似 AOF 这种较为复杂的基于命令日志 &#x2F; merge &#x2F; 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li></ul></li></ul></li></ul><h2 id="4-Redis过期策略和缓存淘汰策略"><a href="#4-Redis过期策略和缓存淘汰策略" class="headerlink" title="4.Redis过期策略和缓存淘汰策略"></a>4.Redis过期策略和缓存淘汰策略</h2><ul><li><strong>过期策略</strong><br><strong>redis 过期策略是：定期删除+惰性删除</strong><ul><li><strong>定期删除</strong><ul><li>redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</li></ul></li><li><strong>惰性删除</strong><ul><li>在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西</li></ul></li></ul></li><li><strong>淘汰策略</strong><ul><li><strong>noeviction：</strong>当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li><li><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，<strong>在键空间中</strong>，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random：</strong>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉</li><li><strong>volatile-lr：</strong>当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间中</strong>，移除最近最少使用的 key（这个一般不太合适）</li><li><strong>volatile-random：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</li><li><strong>volatile-ttl：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li></ul></li></ul><h1 id="三、多机数据库的实现"><a href="#三、多机数据库的实现" class="headerlink" title="三、多机数据库的实现"></a>三、多机数据库的实现</h1><h2 id="1-Redis主从复制-哨兵，如何保证redis的高并发和高可用？"><a href="#1-Redis主从复制-哨兵，如何保证redis的高并发和高可用？" class="headerlink" title="1.Redis主从复制+哨兵，如何保证redis的高并发和高可用？"></a>1.Redis主从复制+哨兵，如何保证redis的高并发和高可用？</h2><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS</p><h3 id="1-1主从架构"><a href="#1-1主从架构" class="headerlink" title="1.1主从架构"></a>1.1<strong>主从架构</strong></h3><p>单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong></p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221546516.png" alt="Redis-master-slave"></a></p><p>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><h4 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a><strong>Redis replication 的核心机制</strong></h4><ul><li><p>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量</p></li><li><p>一个 master node 是可以配置多个 slave node </p></li><li><p>slave node 也可以连接其他的 slave node</p></li><li><p>slave node 做复制的时候，不会 block master node 的正常工作</p></li><li><p>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</p></li><li><p>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量</p></li><li><p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了</p></li><li><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空</p></li></ul><h4 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave-replication.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221548702.png" alt="Redis-master-slave-replication"></a></p><ul><li><strong>主从复制的断点续传</strong></li></ul><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> </p><blockquote><p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分</p></blockquote><ul><li><strong>无磁盘化复制</strong></li></ul><p>master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">repl-<span class="hljs-keyword">diskless-sync </span>yes<br><br><span class="hljs-comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br>repl-<span class="hljs-keyword">diskless-sync-delay </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><ul><li><strong>过期 key 处理</strong></li></ul><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave</p><h4 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a><strong>复制的完整流程</strong></h4><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave-replication-detail.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221551991.png" alt="Redis-master-slave-replication-detail"></a></p><ul><li><p><strong>全量复制</strong></p><ul><li><p>master 执行 bgsave ，在本地生成一份 rdb 快照文件</p></li><li><p>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</p></li><li><p>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node</p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败</p></li><li><p>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时<strong>基于旧的数据版本</strong>对外提供服务</p></li><li><p>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF</p></li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">client</span>-output-buffer-limit slave <span class="hljs-number">256</span>MB <span class="hljs-number">64</span>MB <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>增量复制</strong></p><ul><li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制</p></li><li><p>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB</p></li><li><p>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的</p></li></ul></li><li><p><strong>heartbeat</strong></p><ul><li><p>主从节点互相都会发送 heartbeat 信息</p></li><li><p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat</p></li></ul></li><li><p><strong>异步复制</strong></p><ul><li>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node</li></ul></li></ul><h4 id="Redis-如何才能做到高可用"><a href="#Redis-如何才能做到高可用" class="headerlink" title="Redis 如何才能做到高可用"></a>Redis 如何才能做到高可用</h4><ul><li><p>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的</p></li><li><p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务</p></li><li><p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了</p></li><li><p>Redis 的高可用架构，叫做 <code>failover</code> <strong>故障转移</strong>，也可以叫做主备切换</p></li><li><p>master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用</p></li></ul><h3 id="1-2Redis哨兵集群实现高可用"><a href="#1-2Redis哨兵集群实现高可用" class="headerlink" title="1.2Redis哨兵集群实现高可用"></a>1.2Redis哨兵集群实现高可用</h3><h4 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h4><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li><strong>集群监控：</strong>负责监控 Redis master 和 slave 进程是否正常工作</li><li><strong>消息通知：</strong>如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li><strong>故障转移：</strong>如果 master node 挂掉了，会自动转移到 slave node 上</li><li><strong>配置中心：</strong>如果故障转移发生了，通知 client 客户端新的 master 地址</li></ul><p>哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p><ul><li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了</li></ul><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性</li><li>哨兵 + Redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 Redis 集群的高可用性</li><li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练</li></ul><p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum &#x3D; 1</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+         +----+<br>|<span class="hljs-string"> M1 </span>|<span class="hljs-string">---------</span>|<span class="hljs-string"> R1 </span>|<br>|<span class="hljs-string"> S1 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> S2 </span>|<br>+----+         +----+<br></code></pre></td></tr></table></figure><p>配置 <code>quorum=1</code> ，如果 master 宕机， s1 和 s2 中只要有 1 个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 majority，也就是大多数哨兵都是运行的</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2 个哨兵，<span class="hljs-attribute">majority</span>=2<br>3 个哨兵，<span class="hljs-attribute">majority</span>=2<br>4 个哨兵，<span class="hljs-attribute">majority</span>=2<br>5 个哨兵，<span class="hljs-attribute">majority</span>=3<br><span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><p>如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行</p><p>经典的 3 节点哨兵集群是这样的：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">       +----+<br>       |<span class="hljs-string"> M1 </span>|<br>       |<span class="hljs-string"> S1 </span>|<br>       +----+<br>          |<span class="hljs-string"></span><br><span class="hljs-string">+----+    </span>|<span class="hljs-string">    +----+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> R2 </span>|<span class="hljs-string">----+----</span>|<span class="hljs-string"> R3 </span>|<br>|<span class="hljs-string"> S2 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> S3 </span>|<br>+----+         +----+<br></code></pre></td></tr></table></figure><p>配置 <code>quorum=2</code> ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移</p><h4 id="Redis-哨兵主备切换的数据丢失问题"><a href="#Redis-哨兵主备切换的数据丢失问题" class="headerlink" title="Redis 哨兵主备切换的数据丢失问题"></a>Redis 哨兵主备切换的数据丢失问题</h4><p><strong>导致数据丢失的两种情况</strong></p><p>主备切换的过程，可能会导致数据丢失：</p><ul><li><strong>异步复制导致的数据丢失</strong></li></ul><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221611239.png" alt="image-20220722161104063"></p><ul><li><strong>脑裂导致的数据丢失</strong></li></ul><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong></p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221612054.png" alt="image-20220722161245020"></p><p><strong>数据丢失问题的解决方案</strong></p><p>进行如下配置：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了</p><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据</p><h4 id="sdown-和-odown-转换机制"><a href="#sdown-和-odown-转换机制" class="headerlink" title="sdown 和 odown 转换机制"></a>sdown 和 odown 转换机制</h4><ul><li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li><li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li></ul><p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了</p><h4 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h4><ul><li><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在</p></li><li><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置</p></li><li><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在</p></li><li><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步</p></li></ul><h4 id="slave-配置的自动纠正"><a href="#slave-配置的自动纠正" class="headerlink" title="slave 配置的自动纠正"></a>slave 配置的自动纠正</h4><ul><li>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上</li></ul><h4 id="slave-gt-master-选举算法"><a href="#slave-gt-master-选举算法" class="headerlink" title="slave-&gt;master 选举算法"></a>slave-&gt;master 选举算法</h4><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">(down-<span class="hljs-keyword">after</span>-<span class="hljs-built_in">milliseconds</span> * <span class="hljs-number">10</span>) + milliseconds_since_master_is_in_SDOWN_state<br></code></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave</li></ul><h4 id="quorum-和-majority"><a href="#quorum-和-majority" class="headerlink" title="quorum 和 majority"></a>quorum 和 majority</h4><ul><li><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换</p></li><li><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换</p></li><li><p>但是如果 quorum &gt;&#x3D; majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换</p></li></ul><h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><ul><li><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置</p></li><li><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的</p></li><li><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号</p></li></ul><h4 id="configuration-传播"><a href="#configuration-传播" class="headerlink" title="configuration 传播"></a>configuration 传播</h4><ul><li><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制</p></li><li><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的</p></li></ul><h2 id="2-Redis集群"><a href="#2-Redis集群" class="headerlink" title="2.Redis集群"></a>2.Redis集群</h2><h3 id="2-1Redis-cluster-介绍"><a href="#2-1Redis-cluster-介绍" class="headerlink" title="2.1Redis cluster 介绍"></a>2.1Redis cluster 介绍</h3><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p><h3 id="2-2节点间的内部通信机制"><a href="#2-2节点间的内部通信机制" class="headerlink" title="2.2节点间的内部通信机制"></a>2.2节点间的内部通信机制</h3><h4 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a><strong>基本通信原理</strong></h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/zookeeper-centralized-storage.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621765.png" alt="zookeeper-centralized-storage"></a></p><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-gossip.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621841.png" alt="Redis-gossip"></a></p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> </li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等</li></ul><h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a><strong>gossip 协议</strong></h4><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Redis-trib.rb add-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦</li></ul><h4 id="ping-消息深入"><a href="#ping-消息深入" class="headerlink" title="ping 消息深入"></a>ping 消息深入</h4><ul><li><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担</p></li><li><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率</p></li><li><p>每次 ping，会带上自己节点的信息，还有就是带上 1&#x2F;10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息</p></li></ul><h3 id="2-3分布式寻址算法"><a href="#2-3分布式寻址算法" class="headerlink" title="2.3分布式寻址算法"></a>2.3分布式寻址算法</h3><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/hash.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626574.png" alt="hash"></a></p><h4 id="一致性-hash-算法"><a href="#一致性-hash-算法" class="headerlink" title="一致性 hash 算法"></a>一致性 hash 算法</h4><ul><li><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置</p></li><li><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置</p></li><li><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理</p></li><li><p>然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡</p></li></ul><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/consistent-hashing-algorithm.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626821.png" alt="consistent-hashing-algorithm"></a></p><h4 id="Redis-cluster-的-hash-slot-算法"><a href="#Redis-cluster-的-hash-slot-算法" class="headerlink" title="Redis cluster 的 hash slot 算法"></a>Redis cluster 的 hash slot 算法</h4><ul><li><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot</p></li><li><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现</p></li><li><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器</p></li></ul><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/hash-slot.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221627969.png" alt="hash-slot"></a></p><h3 id="2-4Redis-cluster-的高可用与主备切换原理"><a href="#2-4Redis-cluster-的高可用与主备切换原理" class="headerlink" title="2.4Redis cluster 的高可用与主备切换原理"></a>2.4Redis cluster 的高可用与主备切换原理</h3><p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的</p><h4 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h4><ul><li><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code> ，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code> ，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown</p></li><li><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code> ，那么就被认为 <code>pfail</code> </p></li><li><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中， <code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code></p></li></ul><h4 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h4><ul><li><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node</p></li><li><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code> ，那么就<strong>没有资格</strong>切换成 <code>master</code></p></li></ul><h4 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h4><ul><li><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举</p></li><li><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node <code>（N/2 + 1）</code> 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master</p></li><li><p>从节点执行主备切换，从节点切换为主节点</p></li></ul><h4 id="与哨兵比较"><a href="#与哨兵比较" class="headerlink" title="与哨兵比较"></a>与哨兵比较</h4><ul><li>整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能</li></ul><h2 id="3-分布式算法一致性哈希"><a href="#3-分布式算法一致性哈希" class="headerlink" title="3.分布式算法一致性哈希"></a>3.分布式算法一致性哈希</h2><ul><li><strong>普通哈希</strong><ul><li>原始的做法是对缓存项的键进行哈希，将hash后的结果对<strong>缓存服务器的数量</strong>进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上</li><li><strong>缺点</strong><ul><li>当服务器数量发生变化的时候，所有缓存在一定时间内是失效的，重新哈希，跟服务器结点的数量有关</li><li>当应用无法从缓存中获取数据时，则会向后端服务器请求数据，造成了缓存的雪崩，整个系统很有可能被压垮</li></ul></li></ul></li><li><strong>一致性哈希</strong><ul><li><strong>环形hash空间的概念</strong><ul><li>通常hash算法都是将value映射在一个32位的key值当中，那么把数据首尾相接就会形成一个圆形，取值范围为0 ~ 2^32-1，这个圆环就是环形hash空间</li></ul></li><li><strong>一致性哈希步骤</strong><ul><li>首先求出服务器（节点）的哈希值，并将其配置到0～2^32-1的圆（continuum）上</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上</li><li>然后从数据映射到的位置开始<strong>顺时针查找</strong>，将数据保存到找到的第一个服务器上。如果超过232-1仍然找不到服务器，就会保存到第一台服务器上。(0和232重合，超过后就顺序找到第一台了)</li></ul></li><li><strong>当发生服务器结点变化</strong><ul><li>一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</li><li>一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</li></ul></li></ul></li><li><strong>虚拟结点</strong><br>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题<ul><li><strong>rehash实现虚拟结点进行平衡</strong><ul><li>对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点</li><li>数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上，这样就解决了服务节点少时数据倾斜的问题</li><li>在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布</li></ul></li></ul></li></ul><h2 id="4-Redis和Mysql缓存和数据库的双写一致性"><a href="#4-Redis和Mysql缓存和数据库的双写一致性" class="headerlink" title="4.Redis和Mysql缓存和数据库的双写一致性"></a>4.Redis和Mysql缓存和数据库的双写一致性</h2><ul><li><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去</p></li><li><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求</p></li></ul><h3 id="4-1Cache-Aside-Pattern"><a href="#4-1Cache-Aside-Pattern" class="headerlink" title="4.1Cache Aside Pattern"></a>4.1Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong></li></ul><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p><ul><li><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值</p></li><li><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的</p></li><li><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p></li><li><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。<strong>用到缓存才去算缓存</strong></p></li><li><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工</p></li></ul><h3 id="4-2最初级的缓存不一致问题及解决方案"><a href="#4-2最初级的缓存不一致问题及解决方案" class="headerlink" title="4.2最初级的缓存不一致问题及解决方案"></a>4.2最初级的缓存不一致问题及解决方案</h3><p><strong>问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致</strong></p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-junior-inconsistent.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221631030.png" alt="redis-junior-inconsistent"></a></p><ul><li><p>解决思路 1：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中</p></li><li><p>解决思路 2：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">public void <span class="hljs-built_in">set</span>(key, value) &#123;<br>    <span class="hljs-built_in">putToDb</span>(key, value);<br>    <span class="hljs-built_in">deleteFromRedis</span>(key);<br><br>    <span class="hljs-comment">// ... a few seconds later</span><br>    <span class="hljs-built_in">deleteFromRedis</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除的动作，可以有多种选择，比如：1. 使用 <code>DelayQueue</code>，会随着 JVM 进程的死亡，丢失更新的风险；2. 放在 <code>MQ</code>，但编码复杂度为增加。总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案</li></ul><h3 id="4-3比较复杂的数据不一致问题分析"><a href="#4-3比较复杂的数据不一致问题分析" class="headerlink" title="4.3比较复杂的数据不一致问题分析"></a>4.3比较复杂的数据不一致问题分析</h3><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong></p><p><strong>解决方案如下：</strong></p><ul><li><p>更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中</p></li><li><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成</p></li><li><p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可</p></li><li><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中</p></li><li><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</p></li><li><p><strong>高并发的场景下，该解决方案要注意的问题：</strong></p></li><li><p><strong>读请求长时阻塞</strong></p></li></ul><p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回</p><p>该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的</p><p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 &#x3D; 1000ms &#x3D; 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong></p><p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的</p><p><strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少</p><p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了</p><p>我们来<strong>实际粗略测算一下</strong></p><p>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了</p><p>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列</p><ul><li><strong>读请求并发量过高</strong></li></ul><p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大</p><ul><li><strong>多服务实例部署的请求路由</strong></li></ul><p>可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong></p><p>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等</p><ul><li><strong>热点商品的路由问题，导致请求的倾斜</strong></li></ul><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些</p><h2 id="5-缓存雪崩和缓存穿透及解决方案"><a href="#5-缓存雪崩和缓存穿透及解决方案" class="headerlink" title="5.缓存雪崩和缓存穿透及解决方案"></a>5.缓存雪崩和缓存穿透及解决方案</h2><ul><li><p><strong>缓存雪崩</strong><br>缓存宕机，此时所有请求落到数据库上，由于高并发的请求，导致数据库宕机，发生缓存血崩</p><ul><li><strong>解决方案</strong><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据</li></ul></li><li><strong>请求流程</strong><ul><li>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中</li><li>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次</li></ul></li><li><strong>好处</strong><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过</li><li>只要数据库不死，就是说，对用户来说，部分请求都是可以被处理的</li></ul></li></ul></li><li><p><strong>缓存穿透</strong><br>发来的请求或恶意攻击，此时的数据在缓存和数据库中都没有，因此全部在数据库中查询，导致缓存穿透；若每次都有大量穿透，直接查数据库，则数据库宕机</p><ul><li><strong>解决方案</strong><ul><li>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set key UNKNOWN</li><li>然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据</li></ul></li></ul></li><li><p><strong>缓存击穿</strong><br>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库</p><ul><li><strong>解决方案</strong><ul><li>将热点key设置为永不过期</li></ul></li></ul></li></ul><h2 id="6-Redis常见问题及解决方案"><a href="#6-Redis常见问题及解决方案" class="headerlink" title="6.Redis常见问题及解决方案"></a>6.Redis常见问题及解决方案</h2><ul><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变</li></ul><h1 id="四、独立功能的实现"><a href="#四、独立功能的实现" class="headerlink" title="四、独立功能的实现"></a>四、独立功能的实现</h1><h2 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1.Redis事务"></a>1.Redis事务</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>概念：</strong> 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</p><p><strong>Redis部分支持事务，不支持的是：强一致性</strong></p><p><strong>能干嘛：</strong> 一个队列中，一次性、顺序性、排他性的执行一系列命令</p><p><strong>常用命令：</strong></p><ul><li><code>MULTI</code>：开启一个事务，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中</li><li><code>EXEC</code>：执行队列中所有的命令</li><li><code>DISCARD</code>：清空事务队列,并放弃执行事务</li><li><code>UNWATCH</code>：取消 <code>WATCH</code> 命令对所有 key 的监视</li><li><code>WATCH key1 key2 ...</code>：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</li></ul><h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><ul><li><strong>正常执行：</strong></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221221742.awebp" alt="image"></p><ul><li><strong>放弃事务：</strong></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222039.awebp" alt="image"></p><ul><li><strong>全体连坐：</strong></li></ul><p>一个指令语法错误，EXEC执行报错</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222729.awebp" alt="image"></p><ul><li><p><strong>部分支持事务：</strong></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221223195.awebp" alt="image"></p></li><li><p><strong>WACTCH监控：先监控，后开启事务</strong></p><p>缓存的数据，谁都可以拿，可以改，所以必须打标记来监控行为。这里涉及到锁的问题：悲观锁&#x2F;乐观锁&#x2F;CAS(Check And Set)</p><ul><li><code>悲观锁(Pessimistic Lock)</code>： 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li><li><code>乐观锁(Optimistic Lock)</code>： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下，在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量</li><li>乐观锁策略（常用）：提交版本必须大于记录当前版本才能执行更新。这样既不影响并发性，有可以满足需求</li></ul></li><li><p><strong>案例演示</strong></p><ul><li><p>正常情况：无加塞篡改</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520828.awebp" alt="image"></p></li><li><p>有加塞篡改的情况</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520842.awebp" alt="image"></p></li></ul><p>在 WATCH 监控后，有人修改了balance，会导致事务会被打断，必须更新最新值，才能成功执行事务，类似于乐观锁的版本号机制</p></li></ul><h3 id="三、事务三阶段"><a href="#三、事务三阶段" class="headerlink" title="三、事务三阶段"></a>三、事务三阶段</h3><p>1、<strong>开启：</strong>以MULTI开始一个事务</p><p>2<strong>、入队：</strong>将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p><p>3、<strong>执行：</strong>由EXEC命令触发事务</p><h3 id="四、事务三特性"><a href="#四、事务三特性" class="headerlink" title="四、事务三特性"></a>四、事务三特性</h3><p>1、<strong>单独的隔离操作：</strong>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p><p>2、<strong>没有隔离级别的概念：</strong>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p><p>3、<strong>（重点）不保证原子性：</strong>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚，这也就是：<code>Redis</code>部分支持事务</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql面经-个人总结</title>
    <link href="/2022/07/09/Mysql%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/Mysql%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql基本概念"><a href="#一、Mysql基本概念" class="headerlink" title="一、Mysql基本概念"></a>一、Mysql基本概念</h1><h2 id="1-主键、外键、唯一键、自增主键"><a href="#1-主键、外键、唯一键、自增主键" class="headerlink" title="1.主键、外键、唯一键、自增主键"></a>1.主键、外键、唯一键、自增主键</h2><ul><li>主键 <strong>PRIMARY KEY</strong><ul><li>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）</li></ul></li><li>外键 <strong>FOREIGN KEY</strong><ul><li>在一个表中存在的另一个表的KEY(可以是另外一个表的主键或唯一键)称此表的外键</li></ul></li><li>唯一键 <strong>UNIQE</strong><ul><li>保证字段的唯一性，可以为空</li></ul></li><li>自增主键 <strong>AUTO_INCREMENT</strong><ul><li>自增列每增加一行自动增量，每个表只能有一个自增列</li><li>一般将主键设置为自增列，又叫自增主键</li><li>只能是数值型，delete删除自增列后，若再次插入，从断开处插入</li><li>truncate删除后，再次插入从1开始</li></ul></li></ul><h2 id="2-数据库范式"><a href="#2-数据库范式" class="headerlink" title="2.数据库范式"></a>2.数据库范式</h2><ul><li><strong>第一范式 1NF</strong><ul><li><strong>确保每列保持原子性，所有字段值都是不可分解的原子值</strong></li><li>比如，学生包括学号、姓名；地址包括省份，城市。若在使用中经常访问学号，城市等字段，则建表时，不能把学生、地址作为字段，若将其作为字段，则不满足第一范式</li><li>将学号、城市等作为字段，符合第一范式（相对来讲，因为城市还是可以可分的，只是平时访问的多，也不会访问城市以下的字段）</li></ul></li><li><strong>第二范式 2NF</strong><ul><li><strong>需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）；</strong>或者说每一个非主属性都完全函数依赖与任何一个主键</li><li>比如，学号，课程号，学院，成绩建一个数据库表。此时（学号，课程号）为主键，也称联合主键，此时只能当学号，课程号两者都确定的情况下，才能确定成绩。但学院只与学号有关，因此部分依赖与联合主键，这种情况不符合第二范式</li></ul></li><li><strong>第三范式 3NF</strong><ul><li><strong>数据表中的每一列数据都和主键直接相关，而不能间接相关；</strong>或每一个非主属性既不传递依赖主键，也不部分依赖主键</li><li>订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合3NF</li></ul></li></ul><h2 id="3-视图与游标"><a href="#3-视图与游标" class="headerlink" title="3.视图与游标"></a>3.视图与游标</h2><ul><li><strong>视图</strong><ul><li>一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询</li></ul></li><li><strong>游标</strong><ul><li>对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要</li></ul></li></ul><h2 id="4-二进制文件binlog"><a href="#4-二进制文件binlog" class="headerlink" title="4.二进制文件binlog"></a>4.二进制文件binlog</h2><p>用来记录对mysql数据更新或潜在发生更新的SQL语句，并以”事务”的形式保存在磁盘中</p><ul><li><strong>作用</strong><ul><li><strong>复制</strong><ul><li>用于主从复制，读写分离，Master把它的二进制日志传递给slaves并回放(在slave上执行一遍)来达到master-slave数据一致的目的</li></ul></li><li><strong>恢复</strong><ul><li>让mysql将保存在binlog日志中指定段落区间的sql语句逐个重新执行一次</li></ul></li></ul></li></ul><h2 id="5-drop、truncate、delete区别"><a href="#5-drop、truncate、delete区别" class="headerlink" title="5.drop、truncate、delete区别"></a>5.drop、truncate、delete区别</h2><ul><li><strong>drop</strong><ul><li>直接删除表</li></ul></li><li><strong>truncate</strong><ul><li>清空整个表数据，并不删除表</li><li>若删除自增列，再次插入从1开始</li></ul></li><li><strong>delete</strong><ul><li>可以通过where删除某一行的数据</li><li>删除自增列，再次插入从断点开始</li></ul></li></ul><h2 id="6-count-、count-1-、count-column-的区别"><a href="#6-count-、count-1-、count-column-的区别" class="headerlink" title="6.count(*)、count(1)、count(column)的区别"></a>6.count(*)、count(1)、count(column)的区别</h2><ul><li>count(*)对行的数目进行计算,包含NULL</li><li>count(1)这个用法和count(<em>)的结果是一样的，如果表没有主键,那么count(1)比count(</em>)快</li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值</li><li>任何时候count(*)都是最优选择</li></ul><h1 id="二、索引及优化"><a href="#二、索引及优化" class="headerlink" title="二、索引及优化"></a>二、索引及优化</h1><h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1.索引概述"></a>1.索引概述</h2><h3 id="1-1对索引的理解"><a href="#1-1对索引的理解" class="headerlink" title="1.1对索引的理解"></a>1.1对索引的理解</h3><ul><li>索引是对数据进行排序并快速查找的数据结构，主要功能是排序和查找</li><li>索引是存储引擎用于提高数据查询效率的一种数据结构，索引类似于字典里的目录。Mysql中的索引是在<strong>存储引擎层</strong>实现的，索引的数据结构和存储引擎有关，在MySQL中使用较多的索引有 Hash索引、B树索引和 B+ 树索引</li></ul><h3 id="1-2B树与B-树"><a href="#1-2B树与B-树" class="headerlink" title="1.2B树与B+树"></a>1.2B树与B+树</h3><p><strong>B&#x2F;B+树，hash索引，存储引擎MyISAM和InnoDB使用的B&#x2F;B+树；MEMORY&#x2F;Heap有hash和B&#x2F;B+，默认是hash</strong></p><ul><li><p><strong>为什么B+树比B树更适合文件系统索引</strong></p><ul><li><strong>B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的</strong>；而B树没有这样的链表，只能通过中序遍历来查找数据，不支持范围查询</li><li><strong>B+树的非叶子结点中只存放关键字的信息，没有存放关键字具体信息，因此结点更小。</strong>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了</li><li>由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；而B树在查到关键字后就停止查找了，效率不够稳定</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231522163.png" alt="图片"></p></li></ul><ul><li><strong>B&#x2F;B+树，hash索引，跳表的区别</strong><ul><li><p><strong>Hash索引(散列表)：</strong></p><ul><li>hash适用于等值查找的情况，不能进行范围查找；hash索引在任何时候都不能避免表扫描</li><li>hash当有大量重复键值的情况，由于hash冲突，性能并不一定就会比B-Tree索引高</li><li>不支持索引值的排序操作，不支持联合索引的最左匹配规则</li></ul></li><li><p><strong>平衡二叉树（红黑树）：</strong></p><ul><li>查询性能也好，时间复杂度O(logn)，中序遍历可以得到一个从小到大有序的数据序列，但不支持区间查找</li><li>由于是二叉树，当数据量很大时树的层数就会很高，从树的根结点向下寻找的过程，每读1个节点，都相当于一次IO操作，因此他的I&#x2F;O操作会比B+树多的多</li></ul></li><li><p><strong>跳表：</strong></p><ul><li>是一种链表加多层索引的结构，时间复杂度O(logn)，支持区间查找，而B+树是一种多叉树，可以让每个节点大小等于操作系统每次读取页的大小，从而使读取节点时只需要进行一次IO即可</li><li>而且同数量级的数据，跳表索引的高度会比 B+ 树的高，导致 IO 读取次数多，影响查询性能</li></ul></li></ul></li></ul><h3 id="1-3索引分类"><a href="#1-3索引分类" class="headerlink" title="1.3索引分类"></a>1.3索引分类</h3><ul><li><strong>单值索引</strong><ul><li>一个索引值包含单个列</li></ul></li><li><strong>复合索引</strong><ul><li>索引包含多个列</li></ul></li><li><strong>唯一索引</strong><ul><li>索引列必须唯一 ，一般只是为了防止重复</li><li>主键索引是唯一索引的特殊类型,主键自动建立索引，主键索引可以既防止重复，又提高访问速度</li></ul></li><li><strong>非唯一索引</strong><ul><li>普通索引，为了提高访问速度，索引中的值可重复</li></ul></li></ul><h3 id="1-4什么样的字段适合创建索引"><a href="#1-4什么样的字段适合创建索引" class="headerlink" title="1.4什么样的字段适合创建索引"></a>1.4什么样的字段适合创建索引</h3><ul><li>主键自动建立唯一索引</li><li>经常作查询选择的字段</li><li>经常作表连接的字段，比如外键</li><li>经常出现在order by, group by, distinct 后面排序或分组的字段</li></ul><h3 id="1-5哪些不适合建立索引"><a href="#1-5哪些不适合建立索引" class="headerlink" title="1.5哪些不适合建立索引"></a>1.5哪些不适合建立索引</h3><ul><li>数据记录太少的表 &lt;300w</li><li>经常增删改的表</li><li>数据重复且分布平均的表字段，如性别和国籍</li></ul><h3 id="1-6索引的优缺点"><a href="#1-6索引的优缺点" class="headerlink" title="1.6索引的优缺点"></a>1.6索引的优缺点</h3><ul><li>索引有<strong>三个优点：</strong><ul><li>①减少了服务器需要扫描的数据量</li><li>②帮助服务器避免排序</li><li>③将随机IO变为顺序IO，因为 B+ 树索引是有序的，它将相邻的数据都存储在一起</li></ul></li></ul><ul><li><strong>缺点：</strong><ul><li><strong>时间方面：</strong>创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li><li><strong>空间方面：</strong>索引需要占物理空间</li></ul></li></ul><h2 id="2-聚集索引和非聚集索引（辅助索引）"><a href="#2-聚集索引和非聚集索引（辅助索引）" class="headerlink" title="2.聚集索引和非聚集索引（辅助索引）"></a>2.聚集索引和非聚集索引（辅助索引）</h2><ul><li><p><strong>聚集索引</strong></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231538850.png" alt="主键索引 B+Tree"></p></li><li><p><strong>非聚集索引</strong></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231538785.png" alt="回表"></p></li><li><p><strong>区别：</strong></p><ul><li><p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。聚集索引的逻辑顺序和物理顺序相同，非聚集索引则不同</strong></p></li><li><p><strong>聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针</strong></p></li><li><p><strong>叶子结点存储的是主键整行数据的是聚簇索引；叶子结点存储的仅仅是主键，然后通过指针指向具体信息的是非聚簇索引</strong></p></li><li><p><strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong></p></li><li><p><strong>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引</strong></p></li><li><p>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表</p></li></ul></li><li><p><strong>Mysql中都是使用B+树结构，其中Myisam是非聚集索引，innodb是聚集索引</strong></p></li><li><p><strong>Myisam主键索引（B+树结构、非聚集索引）</strong></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231026793.png" alt="image-20220723102649765"></p></li></ul><ul><li><p><strong>Myisam辅助索引（B+树结构、非聚集索引）</strong></p><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。在Col2上建立一个辅助索引，则此索引的结构：</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231034269.png" alt="image-20220723103417818"></p></li><li><p><strong>innodb主键索引（B+树结构、聚集索引）</strong></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231028756.png" alt="image-20220723102843727"></p></li><li><p><strong>innodb辅助索引（B+树结构、聚集索引）</strong></p><p>InnoDB的所有辅助索引都引用主键作为data域，定义在Col3上的一个辅助索引：</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231036128.png" alt="image-20220723103652091"></p></li></ul><h2 id="3-Like以-开头的模糊查询导致索引失效"><a href="#3-Like以-开头的模糊查询导致索引失效" class="headerlink" title="3.Like以%开头的模糊查询导致索引失效"></a>3.Like以%开头的模糊查询导致索引失效</h2><ul><li><p><strong>解决方法</strong></p><ol><li><ul><li><p><strong>当需要两边都使用%来模糊查询时，模糊查询的条件字段以及所想要查询出来的数据字段（select后面的列）都在索引列上时，才能真正使用索引，否则，索引失效全表扫描（覆盖索引）</strong></p></li><li><p><strong>覆盖索引解决的本质：尽量避免SELECT * 而是一一罗列出所需要查询的字段</strong></p></li></ul></li><li><p><strong>使用虚拟列与reverse反转函数解决like%导致的索引失效问题</strong></p><ul><li><p>触发器更新</p><p><code>set new.mobile_reverse = REVERSE(new.mobile);</code></p></li><li><p>未改造前的模糊查询语句</p><p><code>select * from xxx where mobile like &#39;%5678&#39;;</code></p></li><li><p>改造后的查询语句</p><p><code>select * from xxx where mobile_reverse like reverse(&#39;%5678&#39;);</code></p></li></ul></li></ol></li></ul><h2 id="4-联合索引"><a href="#4-联合索引" class="headerlink" title="4.联合索引"></a>4.联合索引</h2><p>通过将多个字段组合成一个索引，该索引就被称为联合索引</p><p><code>CREATE INDEX index_product_no_name ON product(product_no, name);</code></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231707158.png" alt="联合索引"></p><ul><li><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较</p></li><li><p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配</p></li></ul><h3 id="4-1最左前缀原则"><a href="#4-1最左前缀原则" class="headerlink" title="4.1最左前缀原则"></a>4.1最左前缀原则</h3><ul><li><p><strong>概述</strong></p><ul><li><p>就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边</p></li><li><p>对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</p></li><li><p>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p></li></ul></li><li><p><strong>举例</strong></p><ul><li><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207231714620.png" alt="img"></p></li><li><p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行<code>where b = 2</code>这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong></p></li><li><p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行<code>where a = 2 and b = 7</code>是 a 和 b 字段能用到联合索引的，也就是联合索引生效了</p></li><li><p>但是，如果执行<code>where a &gt; 1 and b = 2</code>时，a 字段能用到联合索引，而 b 字段用不到联合索引。<strong>因为 a 的值此时是一个范围，不是固定的，在这个范围内 b 值不是有序的，因此 b 字段用不上联合索引</strong></p></li><li><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（&gt;、&lt;、between、like 包括like ‘林%’这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引</strong></p></li></ul></li></ul><h2 id="5-索引优化"><a href="#5-索引优化" class="headerlink" title="5.索引优化"></a>5.索引优化</h2><ul><li><strong>全值匹配我最爱</strong><ul><li>创建索引后，尽量在where筛选条件中使用索引列</li></ul></li><li><strong>最左前缀要遵守</strong><ul><li>建立索引，将最常用的放在最左侧</li></ul></li><li><strong>带头大哥不能死</strong><ul><li>查询从索引最左列开始 ，否则全部失效</li></ul></li><li><strong>中间兄弟不能断</strong><ul><li>不能跳过索引中的列，否则部分失效</li></ul></li><li><strong>索引列上少计算</strong><ul><li>不在索引列上做任何操作，比如计算或类型转换，有些VARCHAR不写引号，sql会默认转换，但索引失效</li></ul></li><li><strong>范围之后全失效</strong><ul><li>用&lt;或&gt;时，当前索引不失效，范围条件右边的列失效</li></ul></li><li><strong>LIKE百分写最右</strong><ul><li>LIKE百分号不要写在最左侧，否则索引失效</li></ul></li><li><strong>覆盖索引不写</strong>*<ul><li>当查询索引列时，select后面不写*，而是写索引列</li></ul></li><li><strong>不等空值还有or</strong><ul><li>尽量不使用！&#x3D;或&lt;&gt;符号，不使用is NULL或is not NULL，少用or，否则索引失效</li></ul></li><li><strong>VARCHAR引号不能丢</strong><ul><li>字符串不用单引号会失效，相当于索引列做自动类型转换</li></ul></li></ul><h2 id="6-查询优化"><a href="#6-查询优化" class="headerlink" title="6.查询优化"></a>6.查询优化</h2><ul><li><strong>慢查询步骤和过程</strong><ul><li><strong>开启慢查询</strong><ul><li>set slow_query_log &#x3D; 1慢查询开启状态</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</li></ul></li><li><strong>设置超时阈值，</strong>比如5s或10s，超时的sql语句会放在慢日志中<ul><li>long_query_time 查询超过多少秒才记录</li></ul></li><li><strong>cat查看慢日志</strong></li><li><strong>用explain分析慢sql语句</strong></li></ul></li><li><strong>explain优化</strong>，实际上模拟优化器执行sql语句，查看mysql如何执行你的sql语句<ul><li><strong>table：</strong>显示这一行的数据是关于哪张表的</li><li><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_ref、ref、range、index和ALL，一般来说到range不错，最好到ref<ul><li>all：full table scan；MySQL将遍历全表以找到匹配的行</li><li>index：index scan；index 和 all的区别在于index类型只遍历索引</li><li>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描</li><li>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量</li></ul></li><li><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</li><li><strong>key：</strong>实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</li><li><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</li><li><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</li><li><strong>Extra：</strong>关于MySQL如何解析查询的额外信息<ul><li>Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢</li><li>Using index表示不错的信息，使用了覆盖索引</li></ul></li></ul></li><li><strong>根据explain的结果，进行索引优化</strong></li></ul><h2 id="7-一颗高度为3的B-树能存多少行数据？"><a href="#7-一颗高度为3的B-树能存多少行数据？" class="headerlink" title="7.一颗高度为3的B+树能存多少行数据？"></a>7.一颗高度为3的B+树能存多少行数据？</h2><ul><li><p>InnoDB存储引擎的最小储存单元是 <code>页（Page）</code> ，一个页的大小是默认是 <code>16K</code> 。磁盘存储数据最小单元是 <code>扇区</code> ，一个扇区的大小是 <code>512字节</code> ， 而文件系统（例如XFS&#x2F;EXT4）它的最小单元是 <code>块</code> ，一个块的大小是 <code>4k</code> </p></li><li><p>因此InnoDB的所有数据文件（后缀为 <em>.ibd</em> 的文件），它的大小始终都是16384B（16k）的整数倍</p></li><li><p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？<strong>假设一行数据的大小是1k，那么一个页可以存放16行这样的数据</strong></p></li><li><p>但是除了有 <code>存放数据的页</code> 以外，还有 <code>存放键值+指针（索引）的页</code> ，即B+树中的非叶子节点，该页存放键值和指向数据页的指针，这样的页由N个（键值+指针）组成。当然它也是排好序的。 这样的数据组织形式，我们称为「索引组织表」。索引组织表通过非叶子节点的「二分查找法」以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据</p></li><li><p>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，没有子页节点，那么这棵B+树的存放总记录数为：<code>根节点指针数*单个叶子节点记录行数</code></p></li><li><p>那么现在我们需要计算出非叶子节点能存放多少指针，也就是存放多少索引？</p></li><li><p>我们假设主键ID为 <code>bigint</code> 类型，长度为8字节，而 <code>指针大小在InnoDB源码中设置为6字节</code> ，这样一共14字节</p></li><li><p>我们一个页中能存放多少这样的单元，其实就代表有多少指针，<strong>即 16384&#x2F;14&#x3D;1170。一个页能存放1170个索引</strong></p></li><li><p><strong>那么可以算出一棵高度为2的B+树，能存放1170*16&#x3D;18720条这样的数据记录</strong></p></li><li><p>根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170（根存的记录指针数据）?1170（下一级每个节点存的记录指针数据）?16（每个叶子阶段存的数据条数）&#x3D;21902400 条这样的记录，即2100w量级</p></li><li><p><strong>所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储</strong></p></li><li><p>在查找数据时一次页的查找代表一次 <code>IO</code> ，所以通过主键索引查询通常只需要1-3次 <code>IO</code> 操作即可查找到数据，即使一个是千万量级的表，也是很快的</p></li></ul><h1 id="三、数据库锁"><a href="#三、数据库锁" class="headerlink" title="三、数据库锁"></a>三、数据库锁</h1><h2 id="1-Mysql中的锁"><a href="#1-Mysql中的锁" class="headerlink" title="1.Mysql中的锁"></a>1.Mysql中的锁</h2><h3 id="1-1读写锁"><a href="#1-1读写锁" class="headerlink" title="1.1读写锁"></a>1.1读写锁</h3><ul><li>读锁会阻塞写，但不会阻塞读</li><li>写锁会阻塞读和写</li></ul><h3 id="1-2行页表锁"><a href="#1-2行页表锁" class="headerlink" title="1.2行页表锁"></a>1.2行页表锁</h3><ul><li>对表中的记录加锁，叫做记录锁，又称行锁，行锁只锁定一行，偏写</li><li>表锁会锁定整个表，偏读</li><li>页锁在行锁和表锁之间</li></ul><h3 id="1-3InnoDB加锁"><a href="#1-3InnoDB加锁" class="headerlink" title="1.3InnoDB加锁"></a>1.3InnoDB加锁</h3><ul><li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及及数据集加排他锁</li><li>对于普通SELECT语句，InnoDB不会加任何锁</li><li>事务可以通过以下语句显示给记录集加共享锁或排锁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">//共享锁（Ｓ）<br>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE<br>//排他锁（X）<br>SELECT * FROM table_name WHERE ... FOR UPDATE<br></code></pre></td></tr></table></figure><h2 id="2-乐观锁与悲观锁"><a href="#2-乐观锁与悲观锁" class="headerlink" title="2.乐观锁与悲观锁"></a>2.乐观锁与悲观锁</h2><ul><li><p><strong>悲观锁</strong><br>先获取锁，再进行业务操作，悲观的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。<code>select ... for update</code> 实现悲观锁</p></li><li><p><strong>乐观锁</strong><br>先进行业务操作，再获取锁，一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，提交更新时，时间戳或版本号必须大于当前版本才提交更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT data AS old_data, version AS old_version FROM …;<br>//根据获取的数据进行业务操作，得到new_data和new_version<br>UPDATE SET data = new_data, version = new_version WHERE version = old_version<br>if (updated row &gt; 0) &#123;<br>    // 乐观锁获取成功，操作完成<br>&#125; else &#123;<br>    // 乐观锁获取失败，回滚并重试<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>使用场景</strong><br>一般情况下，<strong>读多写少更适合用乐观锁，读少写多更适合用悲观锁</strong>。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li></ul><h2 id="3-行锁怎么实现"><a href="#3-行锁怎么实现" class="headerlink" title="3.行锁怎么实现"></a>3.行锁怎么实现</h2><ul><li>显示系统上行锁的争夺情况<code>show status like &#39;innodb_row_lock%&#39;;</code></li><li>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">//显式锁定<br>set auoto_commit = 0;<br>begin;<br>//加索引<br> ALTER TABLE account ADD INDEX index_user_id (user_id);<br>//检索索引<br>SELECT * FROM account WHERE user_id = 1 FOR UPDATE<br>commit;<br></code></pre></td></tr></table></figure><h2 id="4-间隙锁"><a href="#4-间隙锁" class="headerlink" title="4.间隙锁"></a>4.间隙锁</h2><ul><li><strong>概念</strong><ul><li>当我们使用范围条件而不是相等条件查询数据时，InnoDB会把符合条件的数据记录索引项都加锁，此时键值在条件范围内，但并不存在的数据记录称为间隙</li><li>比如检索1-3之间的数据，但表中并没有数据2，此时InnoDB会对这个间隙也加锁</li><li>若范围检索不提交，另一个对间隙进行操作（比如添加2）会被阻塞，无法插入数据，导致性能变差</li><li>在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待</li></ul></li><li><strong>作用</strong><ul><li>间隙锁的主要作用是为了防止出现幻读</li></ul></li><li><strong>解除间隙锁</strong><ul><li>修改系统参数innodb_locks_unsafe_for_binlog&#x3D;on就可以关闭改间隙锁机制，该值默认为off</li><li>修改事务隔离级别为read-committed也可以避免间隙锁</li></ul></li><li><strong>next-key lock加锁规则</strong><ul><li><strong>唯一索引等值查询</strong><ul><li>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」</li><li>当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」</li></ul></li><li><strong>非唯一索引等值查询</strong><ul><li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁</li><li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁</li></ul></li><li><strong>非唯一索引和主键索引的范围查询的加锁规则不同之处在于</strong><ul><li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁</li><li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁</li></ul></li></ul></li></ul><h1 id="四、事务与MVCC机制"><a href="#四、事务与MVCC机制" class="headerlink" title="四、事务与MVCC机制"></a>四、事务与MVCC机制</h1><h2 id="1-事务的四大特性ACID"><a href="#1-事务的四大特性ACID" class="headerlink" title="1.事务的四大特性ACID"></a>1.事务的四大特性ACID</h2><ul><li><p><strong>事务</strong><br>事务是用户自定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。在关系数据库中，事务可以是一条SQL语句，也可以是一组SQL语句</p></li><li><p><strong>四大特性ACID</strong><br>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID</p><ul><li><strong>原子性</strong><ul><li>事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚</li><li>事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响</li></ul></li><li><strong>一致性</strong><ul><li>事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>一个事务执行之前和执行之后都必须处于一致性状态</li></ul></li><li><strong>隔离性</strong><ul><li>并发执行的事务之间不能相互影响</li><li>当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰</li></ul></li><li><strong>持久性</strong><ul><li>指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的</li><li>即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</li></ul></li></ul></li></ul><ul><li><strong>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</strong><ul><li>持久性是通过 redo log （重做日志）来保证的</li><li>原子性是通过 undo log（回滚日志） 来保证的</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的</li><li>一致性则是通过持久性+原子性+隔离性来保证</li></ul></li></ul><h2 id="2-事务的并发"><a href="#2-事务的并发" class="headerlink" title="2.事务的并发"></a>2.事务的并发</h2><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行，这样会带来一些问题</p><ul><li><strong>脏读</strong><ul><li>一个事务读取了另一个事务未提交的数据</li><li>事务A读取事务B更新的数据，然后事务B回滚，此时事务A读到的是脏数据</li></ul></li><li><strong>不可重复读</strong><ul><li><strong>不可重复读的重点是修改</strong>，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改</li><li>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致</li></ul></li><li><strong>幻读</strong><ul><li><strong>幻读的重点在于新增或者删除</strong>，同样条件下两次读出来的记录数不一样</li><li>事务A统计表中的数据，此时事务B想表中添加或删除了数据，当事务A再次统计表中的数据时，发现两次的记录不一样</li></ul></li><li><strong>不可重复读和幻读的区别</strong><ul><li>不可重复读侧重于修改，幻读侧重于新增或删除</li><li>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</li></ul></li></ul><h2 id="3-事务的隔离等级"><a href="#3-事务的隔离等级" class="headerlink" title="3.事务的隔离等级"></a>3.事务的隔离等级</h2><ul><li><strong>读未提交：</strong><ul><li>指一个事务还没提交时，它做的变更就能被其他事务看到</li><li>最低的隔离级别，会产生脏读，不可重复读，幻读问题</li></ul></li><li><strong>读提交：</strong><ul><li>指一个事务提交之后，它做的变更才能被其他事务看到</li><li>会产生不可重复读，幻读问题</li></ul></li><li><strong>可重复读：</strong>会产生幻读问题（当前读）<ul><li>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</li><li><strong>可重复读的事务本身是会发生幻读，但MySQL中默认事务隔离级别是“可重复读”，不会发生脏读，不可重复读和幻读的情况，因为可以通过Next-Key进行控制，Next-Key锁是行锁和GAP（间隙锁）的合并</strong></li><li><strong>在可重复读隔离等级下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在当前读下才会出现</strong></li><li>快照读就是普通的读操作，而当前读包括了 <strong>加锁的读取</strong> 和 <strong>DML</strong>（DML只是对表内部的数据操作，不涉及表的定义，结构的修改。主要包括insert、update、deletet） 操作</li></ul></li><li><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样<ul><li>会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li><li>事务隔离级别为读未提交时，写数据只会锁住相应的行</li><li>事务隔离级别为可重复读时，写数据会锁住整张表</li><li>事务隔离级别为串行化时，读写数据都会锁住整张表</li></ul></li></ul><h2 id="4-Mysql中如何实现可重复读"><a href="#4-Mysql中如何实现可重复读" class="headerlink" title="4.Mysql中如何实现可重复读"></a>4.Mysql中如何实现可重复读</h2><p><strong>一、对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</strong></p><ul><li><p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong></p></li><li><p>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207241659935.png" alt="图片"></p></li></ul><p><strong>二、MVVC机制：</strong></p><ul><li>同一行数据平时发生读写请求时，会上锁阻塞住。但 MVCC 用更好的方式去处理读写请求，<strong>做到在发生读写请求冲突时不用加锁，只有写写之间相互阻塞(需要加锁)，提高了Mysql的并发性能</strong></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207232116840.png" alt="img"></p><ul><li><p><strong>每一个事务在启动时都会生成 Read View ，Read View 有四个重要的字段</strong>：</p><ul><li><p>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong></p></li><li><p>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值</p></li><li><p>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1</p></li><li><p>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong></p></li></ul></li><li><p><strong>Mysql中RC和RR隔离级别中ReadView的生成时机</strong></p><ul><li><p>在 READ COMMITTED 级别下每次<strong>读取数据前</strong>都生成一个 ReadView（不同的m_ids），因此可能会导致不可重复读的现象</p></li><li><p><strong>而当隔离级别为可重复读的时候，事务只在第一次 SELECT 的时候会获取一次 Read View，后面所有的 SELECT 都会复用这个 Read View（相同的_ids），这是解决不可重复读的核心，但依然可能会产生幻读现象</strong></p></li></ul></li><li><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p></li></ul><p><strong>三、undo日志</strong></p><p>undo log 主要用于记录数据被<code>修改之前</code>的日志，在表信息修改之前先会把数据拷贝到<code>undo log</code>里。当<code>事务</code>进行<code>回滚时</code>可以通过 undo log 里的日志进行<code>数据还原</code></p><ul><li><p><strong>Undo log 的用途</strong></p><ul><li><p>保证<code>事务</code>进行<code>rollback</code>时的<code>原子性和一致性</code>，当事务进行<code>回滚</code>的时候可以用undo log的数据进行<code>恢复</code></p></li><li><p>用于MVCC<code>快照读</code>的数据，在MVCC多版本控制中，通过读取<code>undo log</code>的<code>历史版本数据</code>可以实现<code>不同事务版本号</code>都拥有自己<code>独立的快照数据版本</code></p></li></ul></li><li><p><strong>undo log主要分为两种</strong></p><ul><li><p><code>insert undo log</code></p><p>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p><code>update undo log</code></p><p>事务在进行 update 或 delete 时产生的 undo log， 不仅在事务回滚时需要，在快照读时也需要。所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p></li></ul></li></ul><p><strong>四、改动的记录都存在在 undo 日志中，那如果一个日志需要查询行记录，需要读取哪个版本的行记录呢？</strong></p><ol><li><p>对于使用 <code>READ UNCOMMITTED</code> 隔离级别的事务来说，由于<strong>可以读到未提交事务修改过的记录</strong>，所以直接读取记录的最新版本就好了</p></li><li><p>对于使用 <code>SERIALIZABLE</code> 隔离级别的事务来说，InnoDB 使用<strong>加锁的方式来访问记录</strong>，不存在并发问题</p></li><li><p>而对于使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务来说，都<strong>必须保证读到</strong>已经<strong>提交</strong>了的事务修改过的记录，也就是说<strong>假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</strong></p></li></ol><p>核心问题就是： <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别在不可重复读和幻读上的区别在哪里？这两种隔离级别对应的<strong>不可重复读</strong>与<strong>幻读</strong>都是指<strong>同一个事务</strong>在两次读取记录时出现<strong>不一致</strong>的情况，这两种隔离级别关键是需要判断版本链中的哪个版本是当前事务可见的</p><p>ReadView 就是用来解决这个问题的，可以帮助我们解决可见性问题。 事务进行<strong>快照读</strong>操作的时候就会产生 Read View，它保存了<strong>当前事务开启时所有活跃的事务列表</strong>，注意：这里的活跃指的是<strong>未提交</strong>的事务</p><p><strong>五、一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</strong></p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong></li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong></li><li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong></li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207232136438.png" alt="img"></p><h2 id="5-幻读如何被解决"><a href="#5-幻读如何被解决" class="headerlink" title="5.幻读如何被解决"></a>5.幻读如何被解决</h2><ul><li><p><strong>产生原因</strong></p><ul><li>即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是数据库中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的</li><li>ReadView 并不能阻止事务 A 执行 UPDATE 或者 DELETE 语句来改动这个新插入的记录</li></ul></li><li><p><strong>解决方案：默认情况下，InnoDB 以 REPEATABLE READ 隔离级别运行。在这种情况下，InnoDB 使用 Next-Key Locks 锁进行搜索和索引扫描，这可以防止幻读的发生</strong></p><ul><li><p><strong>next-Key：就是记录锁和间隙锁的组合</strong></p><ul><li>记录锁：锁的是记录本身</li><li>间隙锁：锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象</li></ul></li><li><p>索引对间隙锁产生的影响</p><ul><li>对主键或唯一索引，如果当前读时，where 条件全部精确命中(&#x3D;或in)，这种场景本身就不会出现幻读，所以只会加行记录锁，也就是说<strong>间隙锁会退化为行锁</strong>（记录锁）</li><li>非唯一索引列，如果 where 条件部分命中(&gt;、&lt;、like等)或者全未命中，则会加附近间隙锁。例如，某表数据如下，非唯一索引<code>2,6,9,9,11,15</code>。如下语句要操作非唯一索引列 9 的数据，间隙锁将会锁定的列是(6,11]，该区间内无法插入数据</li><li>对于没有索引的列，当前读操作时，会加全表间隙锁，生产环境要注意</li></ul></li><li><p><strong>需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行数据加上了行锁，还给行两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁</strong></p></li></ul></li></ul><h1 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h1><h2 id="1-MyISAM和InnoDB区别"><a href="#1-MyISAM和InnoDB区别" class="headerlink" title="1.MyISAM和InnoDB区别"></a>1.MyISAM和InnoDB区别</h2><p>在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，之后的版本是InnoDB</p><ul><li><strong>InnoDB</strong><ul><li>支持事务</li><li>有行级锁定和外键约束</li><li>不支持FULLTEXT类型的索引</li><li>没有保存表的行数</li><li>叶子结点是聚集索引，索引的叶子结点就是数据文件</li></ul></li><li><strong>MyISAM</strong><ul><li>不支持事务</li><li>不支持行锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些</li><li>叶子结点是非聚集索引，索引的叶子结点是数据文件的指针</li></ul></li><li><strong>两者区别</strong><ul><li><strong>事务</strong><ul><li>InnoDB支持，MyISAM不支持</li></ul></li><li><strong>行数</strong><ul><li>InnoDB没有保存表的行数，MyISAM保存了表的行数，可以直接读取</li></ul></li><li><strong>索引存储</strong><ul><li>InnoDB是聚集索引，MyISAM是非聚集索引</li></ul></li><li><strong>外键</strong><ul><li>InnoDB支持，MyISAM不支持</li></ul></li><li><strong>锁</strong><ul><li>InnoDB支持行锁，表锁。行锁可以提高多用户并发操作，但InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</li><li>MyISAM支持表锁</li></ul></li><li><strong>全文索引</strong><ul><li><strong>Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高</strong></li><li><strong>5.7以后的InnoDB支持全文索引了</strong></li></ul></li><li><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</strong></li></ul></li></ul><h2 id="2-Mysql主从复制"><a href="#2-Mysql主从复制" class="headerlink" title="2.Mysql主从复制"></a>2.Mysql主从复制</h2><h3 id="2-1原理"><a href="#2-1原理" class="headerlink" title="2.1原理"></a>2.1原理</h3><ul><li><strong>主从复制需要三个线程来完成</strong><ul><li>主库中有一个binary-log dump线程，当从库连接主库时，主库会创建该线程，用于给从库发送二进制文件信息，其中读取二进制文件信息的时候会加锁</li><li>从库中有两个线程，一个是从节点I&#x2F;O线程，一个是SQL线程。其中从节点I&#x2F;O线程接收主节点线程发来的二进制文件信息，存入到中继日志文件（relay-log），SQL线程负责执行中继日志文件中的SQL操作</li></ul></li><li><strong>Master将数据改变记录到二进制日志(binary log)中</strong></li><li><strong>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容</strong></li><li><strong>Master接收到来自Slave的IO进程的请求</strong><ul><li>负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程</li><li>返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置</li></ul></li><li><strong>Slave的IO进程接收到信息后</strong>，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master从某个bin-log的哪个位置开始往后的日志内容</li><li><strong>Slave的Sql进程检测到relay-log中新增加了内容后</strong>，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行，从而实现主从数据的一致</li></ul><h3 id="2-2读写分离"><a href="#2-2读写分离" class="headerlink" title="2.2读写分离"></a>2.2读写分离</h3><p>基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去</p><h3 id="2-3三种复制方式"><a href="#2-3三种复制方式" class="headerlink" title="2.3三种复制方式"></a>2.3三种复制方式</h3><ul><li><strong>同步</strong><ul><li>master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间</li></ul></li><li><strong>异步</strong><ul><li>master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置，<strong>这样可能会丢失数据</strong></li></ul></li><li><strong>半同步</strong><ul><li>master一般至少有两个slave，主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了</li></ul></li><li><strong>注意</strong><ul><li>从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行<ul><li>由于从库从主库拷贝日志以及串行执行SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的</li><li>经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到</li></ul></li><li>解决思路<ul><li>从库中开启多线程并行操作</li></ul></li></ul></li></ul><h1 id="六、HBase"><a href="#六、HBase" class="headerlink" title="六、HBase"></a>六、HBase</h1>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面经-个人总结</title>
    <link href="/2022/07/09/C++-%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/C++-%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、C-基础"><a href="#一、C-基础" class="headerlink" title="一、C++基础"></a>一、C++基础</h1><h2 id="1-数组和指针的区别"><a href="#1-数组和指针的区别" class="headerlink" title="1.数组和指针的区别"></a>1.数组和指针的区别</h2><ul><li><strong>概念不同</strong> <ul><li>指针相当于一个变量，它存放的是数据在内存中的地址</li><li>数组是用于储存多个相同类型数据的集合</li></ul></li><li><strong>赋值不同</strong> <ul><li>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li></ul></li><li><strong>访问数据不同</strong> <ul><li>指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容</li><li>数组是直接访问</li></ul></li><li><strong>sizeof意义不同</strong> <ul><li>数组所占存储空间的内存：sizeof（数组名） ,数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） </li><li>在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li></ul></li><li><strong>指针和数组名异同</strong> <ul><li>指针和数组名都可以表示地址，但指针是变量，可以修改</li><li>数组名是常量，不可修改赋值</li></ul></li><li><strong>传参：</strong> 数组传参时会退化成指针 <ul><li>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。 </li><li>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</li></ul></li></ul><h2 id="2-指针数组和数组指针"><a href="#2-指针数组和数组指针" class="headerlink" title="2.指针数组和数组指针"></a>2.指针数组和数组指针</h2><ul><li><strong>指针数组：</strong>它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8]<ul><li><ol><li>优先级问题：[]的优先级比高 </li><li>说明arr是一个数组，而int*是数组里面的内容 </li><li>这句话的意思就是：arr是一个含有8和int*的数组</li></ol></li></ul></li><li><strong>数组指针：</strong>它实际上是一个指针，该指针指向一个数组。 int (*arr)[8]<ul><li><ol><li>由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来 </li><li>arr先和*结合，说明p是一个指针变量 </li><li>这句话的意思就是：指针arr指向一个大小为8个整型的数组</li></ol></li></ul></li></ul><h2 id="3-字符数组和字符串常量"><a href="#3-字符数组和字符串常量" class="headerlink" title="3.字符数组和字符串常量"></a>3.字符数组和字符串常量</h2><ul><li><strong>字符数组：</strong>char arr[] &#x3D; “hello”;<ul><li>此处的赋值是将常量区的字符串”hello”拷贝到了堆栈区的数arr的空间了</li><li>数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值</li><li>另外此时的数组名arr是堆栈区中的”hello”的首地址</li></ul></li><li><strong>字符串常量：</strong>char *arr2 &#x3D; “hello”;<ul><li>指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值</li></ul></li></ul><h2 id="4-引用和指针的区别"><a href="#4-引用和指针的区别" class="headerlink" title="4.引用和指针的区别"></a>4.引用和指针的区别</h2><ul><li><strong>指针有内存分配，而引用只是一个别名</strong> <ul><li>引用声明时必须初始化，从而指向一个已经存在的对象</li></ul></li><li><strong>引用可以看做常量指针，指针是一个存储地址的变量</strong> <ul><li>指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变</li><li>这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变</li></ul></li><li><strong>引用创建时必须初始化，且不为空，指针创建时可以为空</strong> <ul><li>不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高</li><li>因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空</li></ul></li><li><strong>指针和引用的自增运算符意义不同</strong> <ul><li>指针是对内存地址的自增，引用是对值的自增</li></ul></li><li><strong>sizeof的意义不同</strong> <ul><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小</li></ul></li><li><strong>没有引用常量，有指针常量</strong> <ul><li>没有int&amp; const p,有int* const p. 常量指针和常量引用是存在的，const int *p和cosnt int &amp;p，都表示指向的对象为常量常量引用形参的好处：<ul><li>（1）使用引用作为形参，不会产生新的变量，减少形参和实参传递的开销</li><li>（2）使用引用可能会导致实参随着形参的改变而改变。声明为const之后就会消除这种副作用</li></ul></li></ul></li><li><strong>参数传递</strong> <ul><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象</li></ul></li><li><strong>多级指针，一级引用</strong> <ul><li>指针可以有多级指针（**p），而引用只有一级</li></ul></li></ul><h2 id="5-函数指针与指针函数"><a href="#5-函数指针与指针函数" class="headerlink" title="5.函数指针与指针函数"></a>5.函数指针与指针函数</h2><ul><li>指针函数<code>int* f(int x, int y)</code>本质是函数，返回值为指针，函数指针<code>int (*f)(int x)</code>本质是指针，指向函数的指针</li><li>通常我们可以将指针指向某类型的变量，称为类型指针（如，整型指针）。若将一个指针指向函数，则称为函数指针</li><li>函数名代表函数的入口地址，同样的，我们可以通过根据该地址进行函数调用，而非直接调用函数名</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test001</span>()</span>&#123;<br>    printf(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br>    <span class="hljs-keyword">void</span>(*myfunc)() = test001;<span class="hljs-comment">//将函数写成函数指针</span><br>    myfunc(); <span class="hljs-comment">//调用函数指针 hello world</span><br>&#125;<br></code></pre></td></tr></table></figure><p>test001的函数名与myfunc函数指针都是一样的，即都是函数指针。test001函数名是一个函数指针常量，而myfunc是一个函数指针变量，这是它们的关系</p><ul><li>函数指针多用于回调函数，回调函数最大的优势在于灵活操作，可以实现用户定制的函数，降低耦合性，实现多样性，如STL中</li></ul><h2 id="6-C-中class和struct的区别"><a href="#6-C-中class和struct的区别" class="headerlink" title="6.C++中class和struct的区别"></a>6.C++中class和struct的区别</h2><ul><li><p>C中的strcut不能有函数，但C++中可以</p></li><li><p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它能包含<strong>成员函数，能继承与实现多态</strong></p></li><li><p><strong>默认的继承访问权限</strong> </p><ul><li>struct是public的，class是private的 class B : public A就是为了指明是public继承，而不是用默认的private继承，若class B : A则是private继承</li></ul></li><li><p><strong>定义模板参数</strong> </p><ul><li>class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数</li></ul></li></ul><h2 id="7-new-x2F-delete和malloc-x2F-free的区别"><a href="#7-new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="7.new&#x2F;delete和malloc&#x2F;free的区别"></a>7.new&#x2F;delete和malloc&#x2F;free的区别</h2><ul><li><p><strong>主要区别</strong></p><ul><li>calloc在返回指向内存的指针之前把它初始化为0，calloc的参数包括所需的元素的数量和每个元素的字节数</li></ul></li><li><p><strong>属性不同</strong> </p><ul><li>new&#x2F;delete是C++关键字，需要编译器支持。malloc&#x2F;free是库函数，需要头文件支持C</li></ul></li><li><p><strong>申请的内存所在位置</strong> </p><ul><li>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存</li></ul></li><li><p>自由存储区是C++的抽象概念，堆是操作系统中的术语，自由存储区可以是堆，也可以是静态存储区，取决于operator new的实现细节</p><ul><li>基本上所有的C++编译器默认用堆来实现自由存储区，即new运算符会按照malloc的方式来实现</li></ul></li><li><p><strong>返回类型安全性</strong> </p><ul><li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</li><li>malloc内存分配成功则是返回void*类型，需要通过强制类型转换将空类型指针转换成我们需要的类型</li></ul></li><li><p><strong>内存分配失败时的返回值</strong></p><ul><li>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL</li></ul></li><li><p><strong>是否需要指定内存大小</strong> </p><ul><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算<ul><li>int *pi&#x3D;new int;&#x2F;&#x2F;在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi</li><li>int *pi&#x3D;new int();&#x2F;&#x2F;对指针pi指向的地址的值进行了初始化为0 </li><li>int *pi&#x3D;new int(1024);&#x2F;&#x2F;初始化为1024</li></ul></li><li>malloc则需要显式地指出所需内存的大小<ul><li>int *p&#x3D;(int *)malloc(100);&#x2F;&#x2F;指向整型的指针p指向一个大小为100字节的内存的地址 </li><li>int *p&#x3D;(int *)malloc(25 * sizeof(int));&#x2F;&#x2F;指向整型的指针p指向一个25个int整型空间的地址</li></ul></li></ul></li><li><p><strong>数组分配内存（与前一个特点类似）</strong></p><ul><li>new中分配内存对于变量和数组不同，malloc分配内存则相同 </li><li>int *pi&#x3D;new int[];&#x2F;&#x2F;指针pi所指向的数组未初始化 </li><li>int *pi&#x3D;new int[n];&#x2F;&#x2F;指针pi指向长度为n的数组，未初始化 </li><li>int *pi&#x3D;new int;&#x2F;&#x2F;指针pi所指向的地址初始化为0</li></ul></li><li><p><strong>是否调用构造函数&#x2F;析构函数</strong> </p><ul><li>new会先调用operator_ new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_ delete函数释放内存（通常底层使用free实现）</li><li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作</li></ul></li><li><p><strong>能否重载</strong> </p><ul><li>opeartor_new&#x2F;operator_delete允许重载,malloc&#x2F;free不允许重载</li></ul></li><li><p><strong>已分配内存的扩充</strong> </p><ul><li>malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</li></ul></li><li><p><strong>能否相互调用</strong></p><ul><li>operator_new &#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new</li></ul></li></ul><h2 id="8-new-x2F-delete运算符的原理"><a href="#8-new-x2F-delete运算符的原理" class="headerlink" title="8.new&#x2F;delete运算符的原理"></a>8.new&#x2F;delete运算符的原理</h2><ul><li><strong>内存分配</strong><ul><li>调用相应的 operator new(size_t) 函数，动态分配内存</li><li>如果 operator new(size_t) 不能成功获得内存，则调用 new_handler()函数用于处理new失败问题</li><li>如果没有设置 new_handler() 函数或者 new_handler() 未能分配足够内存，则抛出 std::bad_alloc 异常</li></ul></li><li><strong>构造函数</strong><ul><li>在分配到的动态内存块上 初始化相应类型的对象（构造函数）并返回其首地址</li><li>如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void *, void *) 函数释放已经分配到的内存</li></ul></li><li><strong>delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同</strong></li></ul><h2 id="9-malloc的内存分配机制"><a href="#9-malloc的内存分配机制" class="headerlink" title="9.malloc的内存分配机制"></a>9.malloc的内存分配机制</h2><p><strong>malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存？</strong></p><ul><li>首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存</li><li>如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中</li></ul><h2 id="10-堆和栈的区别"><a href="#10-堆和栈的区别" class="headerlink" title="10.堆和栈的区别"></a>10.堆和栈的区别</h2><ul><li>管理方式不同<ul><li>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak</li></ul></li><li>空间大小不同<ul><li>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M</li></ul></li><li>能否产生碎片不同<ul><li>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</li><li>对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</li></ul></li><li>生长方向不同<ul><li>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长</li></ul></li></ul><h2 id="11-const关键字"><a href="#11-const关键字" class="headerlink" title="11.const关键字"></a>11.const关键字</h2><ul><li><strong>修饰变量：</strong>说明该变量不可以被改变</li><li><strong>修饰指针：</strong>分为指向常量的指针和指针常量；int *const p和const int *p</li><li><strong>常量引用：</strong>经常用于形参类型，即避免了拷贝，又避免了函数对值的修改</li><li><strong>修饰成员函数：</strong>说明该成员函数内不能修改成员变量，本质是const this指针</li></ul><h2 id="12-static关键字"><a href="#12-static关键字" class="headerlink" title="12.static关键字"></a>12.static关键字</h2><ul><li><strong>修饰普通变量：</strong> 修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0<ul><li><strong>全局变量作用域：</strong>全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾</li><li><strong>局部变量作用域：</strong>仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变</li></ul></li><li><strong>修饰普通函数：</strong>其只能在定义它的源文件中使用，不能在其他源文件中被引用</li><li><strong>修饰类成员变量和成员函数：</strong> 它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li></ul><h2 id="13-extern关键字"><a href="#13-extern关键字" class="headerlink" title="13.extern关键字"></a>13.extern关键字</h2><p>extern关键字主要修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用</p><ul><li><strong>修饰变量或函数</strong><ul><li>被 extern 限定的函数或变量是 extern 类型的</li></ul></li><li><strong>extern “C”</strong><ul><li>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题<ul><li><ol><li>在c头文件中通过#ifdef __cplusplus extern “C” { #endif来定义</li><li>在对应的c文件中实现 </li><li>在cpp文件中通过“extern “C” 函数名”调用，或者包含c头文件 </li><li><strong>注意：</strong> extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间，但若需要调用的函数太多，还是直接包含头文件吧</li></ol></li></ul></li></ul></li></ul><h2 id="14-volatile关键字"><a href="#14-volatile关键字" class="headerlink" title="14.volatile关键字"></a>14.volatile关键字</h2><ul><li><strong>不可优化性：</strong> volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化</li><li><strong>易变性：</strong> volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li></ul><h2 id="15-explicit关键字"><a href="#15-explicit关键字" class="headerlink" title="15.explicit关键字"></a>15.explicit关键字</h2><p>explicit关键字的作用就是<strong>防止对象间实现&#x3D;赋值</strong>，<strong>防止类构造函数的隐式自动转换</strong>，类构造函数默认情况下即声明为implicit(隐式)，另外<strong>explicit只用于单参数的构造函数</strong>，或者除了第一个参数以外的其他参数都有默认值</p><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换</li></ul><h2 id="16-C-从代码到可执行"><a href="#16-C-从代码到可执行" class="headerlink" title="16.C++从代码到可执行"></a>16.C++从代码到可执行</h2><p><strong>一、预编译</strong></p><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p><ol><li>删除所有的#define，展开所有的宏定义。</li><li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li><li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</li></ol><p><strong>二、编译</strong></p><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><ol><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li></ol><p><strong>三、汇编</strong></p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p><p><strong>四、链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ul><li><p><strong>静态链接</strong></p><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><ul><li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li><li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li><li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</li></ul></li><li><p><strong>动态链接</strong></p><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><ul><li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li><li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li><li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li></ul></li></ul><h2 id="17-hello-c程序的编译过程"><a href="#17-hello-c程序的编译过程" class="headerlink" title="17.hello.c程序的编译过程"></a>17.hello.c程序的编译过程</h2><p>以下是一个 hello.c 程序：</p><pre><code class="hljs">#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;hello, world\n&quot;);    return 0;&#125;</code></pre><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><pre><code class="hljs">    gcc -o hello hello.c</code></pre><p>这个过程大致如下：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png" alt="img"></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><p><strong>静态链接</strong><br>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png" alt="img"></p><p><strong>目标文件</strong></p><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><p><strong>动态链接</strong><br>静态库有以下两个问题：</p><ul><li><p>当静态库更新时那么整个程序都要重新进行链接；</p></li><li><p>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</p></li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png" alt="img"></p><p>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</p><ol><li><p>预处理<br>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。</p></li><li><p>编译阶段<br>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p></li><li><p>汇编过程<br>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p></li><li><p>链接阶段<br>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p></li></ol><h1 id="二、C-面向对象"><a href="#二、C-面向对象" class="headerlink" title="二、C++面向对象"></a>二、C++面向对象</h1><h2 id="1-内存字节对齐"><a href="#1-内存字节对齐" class="headerlink" title="1.内存字节对齐"></a>1.内存字节对齐</h2><ul><li><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">struct A&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">short</span> c;<br>&#125;;<br>- <span class="hljs-type">char</span>占一个字节，起始偏移为零，<span class="hljs-type">int</span>占四个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以应该偏移量为<span class="hljs-number">4</span>，所以应该在<span class="hljs-type">char</span>后面加上三个字节，不存放任何东西，<span class="hljs-type">short</span>占两个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>)=<span class="hljs-number">2</span>;所以偏移量是<span class="hljs-number">2</span>的倍数，而<span class="hljs-type">short</span>偏移量是<span class="hljs-number">8</span>，是<span class="hljs-number">2</span>的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为<span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span><br><br>- 此时一共占了<span class="hljs-number">10</span>个字节，但是还有结构体本身的对齐，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以总体应该是<span class="hljs-number">4</span>的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 <span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span>xx，一共占据了<span class="hljs-number">12</span>个字节<br></code></pre></td></tr></table></figure><ul><li><strong>内存对齐规则</strong><ul><li>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数</li><li>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)</li></ul></li><li><strong>需要对齐的原因</strong><ul><li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li><li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li></ul></li></ul><h2 id="2-双冒号、using和namespace"><a href="#2-双冒号、using和namespace" class="headerlink" title="2.双冒号、using和namespace"></a>2.双冒号、using和namespace</h2><ul><li><strong>namespace主要用来解决命名冲突的问题</strong><ul><li>必须在全局作用域下声明</li><li>命名空间下可以放函数，变量、结构体和类</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li></ul></li><li><strong>双冒号::作用域运算符</strong><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul></li><li><strong>using分为using声明和using编译指令</strong><ul><li><code>using std::cout; //声明</code></li><li><code>using namespace std; //编译指令</code></li><li>尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</li></ul></li></ul><h2 id="3-内联函数和函数重载"><a href="#3-内联函数和函数重载" class="headerlink" title="3.内联函数和函数重载"></a>3.内联函数和函数重载</h2><ul><li><strong>内联函数</strong><ul><li>相当于把内联函数里面的内容写在调用内联函数处</li><li>相当于不用执行进入函数的步骤，直接执行函数体</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性</li><li>不能包含循环、递归、switch 等复杂操作</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数</li></ul></li><li><strong>C++的函数名称可以重复，称为函数重载</strong><ul><li>其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中</li><li>可以根据函数参数的个数、类型（const也可以作为重载条件）、顺序不同进行函数重载，但<strong>不能用函数返回值进行重载</strong></li><li>当函数重载遇到函数默认参数时，要注意二义性</li></ul></li></ul><h2 id="4-虚函数可以是内联函数吗"><a href="#4-虚函数可以是内联函数吗" class="headerlink" title="4.虚函数可以是内联函数吗"></a>4.虚函数可以是内联函数吗</h2><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li><li>内联是在编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联</li><li><strong>inline virtual 唯一可以内联的时候是</strong>：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</li></ul><h2 id="5-构造函数和析构函数"><a href="#5-构造函数和析构函数" class="headerlink" title="5.构造函数和析构函数"></a>5.构造函数和析构函数</h2><ul><li>构造函数和析构函数，分别对应变量的初始化和清理，变量没有初始化，使用后果未知；没有清理，则会内存管理出现安全问题。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数</li></ul><blockquote><ul><li>构造函数：与类名相同，没有返回值，不写void，<strong>可以发生重载</strong>，可以有参数，编译器自动调用，只调用一次。</li><li>析构函数：~类名，没有返回值，不写void，<strong>不可以发生重载</strong>，不可以有参数，编译器自动调用，只调用一次。</li></ul></blockquote><ul><li>构造函数<ul><li>系统会默认给一个类提供三个函数：默认构造函数（无参，函数体为空）、默认拷贝构造和析构函数（无参，函数体为空），其中默认拷贝构造可以实现简单的值拷贝</li><li>提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数；若自己定义了有参构造，还想要无参构造函数，就必须再自定义无参构造函数</li></ul></li><li>析构函数<ul><li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏</li></ul></li></ul><h2 id="6-拷贝初始化和直接初始化"><a href="#6-拷贝初始化和直接初始化" class="headerlink" title="6.拷贝初始化和直接初始化"></a>6.拷贝初始化和直接初始化</h2><ul><li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;I am a string&quot;</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数   </span><br></code></pre></td></tr></table></figure><ul><li>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了（语句1和语句3等价），但是需要辨别两种情况。<ul><li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li><li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li></ul></li></ul><h2 id="6-初始化和赋值的区别"><a href="#6-初始化和赋值的区别" class="headerlink" title="6.初始化和赋值的区别"></a>6.初始化和赋值的区别</h2><ul><li>对于简单类型来说，初始化和赋值没什么区别</li><li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b)&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;;<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拷贝构造函数与赋值操作符的区别</strong></p><ul><li><strong>拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作</strong></li><li>一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</li><li><strong>实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值操作符则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）</strong></li><li>如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码</li></ul><h2 id="6-拷贝构造函数与深浅拷贝"><a href="#6-拷贝构造函数与深浅拷贝" class="headerlink" title="6.拷贝构造函数与深浅拷贝"></a>6.拷贝构造函数与深浅拷贝</h2><p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象</p><ul><li><strong>拷贝构造函数的使用时机</strong><ul><li>使用已经创建好的对象初始化新对象 <code>A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符</code></li><li>以值传递的方式来给函数参数传值</li><li>以值方式返回局部对象（不常用，一般不返回局部对象）</li></ul></li><li><strong>深拷贝和浅拷贝</strong>只有当对象的成员属性在堆区开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求<ul><li><strong>浅拷贝</strong>：使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉</li><li><strong>浅拷贝的问题</strong>：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。<strong>当数据成员中没有指针时，浅拷贝是可行的</strong>。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了所以，这时，必须采用深拷贝</li><li><strong>深拷贝</strong>：自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。<strong>需要注意自定义析构函数中应该释放掉申请的内存</strong></li></ul></li></ul><p>我们在定义类或者结构体，这些结构的时候，<strong>最后都重写拷贝函数，避免浅拷贝</strong>这类不易发现但后果严重的错误产生</p><h2 id="7-拷贝构造函数和移动构造函数的区别"><a href="#7-拷贝构造函数和移动构造函数的区别" class="headerlink" title="7.拷贝构造函数和移动构造函数的区别"></a>7.拷贝构造函数和移动构造函数的区别</h2><ul><li>拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间</li><li>移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间</li></ul><h2 id="7-什么情况下会调用拷贝构造函数"><a href="#7-什么情况下会调用拷贝构造函数" class="headerlink" title="7.什么情况下会调用拷贝构造函数"></a>7.什么情况下会调用拷贝构造函数</h2><ul><li>用类的一个实例化对象去初始化另一个对象的时候</li><li>函数的参数是类的对象时（非引用传递）</li><li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li></ul><p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p><h2 id="8-只在堆上-x2F-栈上创建对象"><a href="#8-只在堆上-x2F-栈上创建对象" class="headerlink" title="8.只在堆上&#x2F;栈上创建对象"></a>8.只在堆上&#x2F;栈上创建对象</h2><ul><li><p><strong>只能在堆上生成对象：将析构函数设置为私有</strong> </p><ul><li><strong>原因：</strong>C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象</li></ul></li><li><p><strong>只能在栈上生成对象：将new 和 delete 重载为私有</strong></p><ul><li><strong>原因：</strong>在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象</li></ul></li></ul><h2 id="9-this指针"><a href="#9-this指针" class="headerlink" title="9.this指针"></a>9.this指针</h2><ul><li><p><strong>为什么会有this指针</strong>：</p><ul><li>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针</li></ul></li><li><p><strong>this指针的作用：</strong></p><ul><li>this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。this指针指向被调用的成员函数所属的对象（谁调用成员函数，this指向谁），this表示对象本身，<strong>非静态成员函数中才有this，静态成员函数内部没有</strong></li></ul></li><li><p>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）</p><ul><li>对非静态成员函数默认添加了this指针，类型为classname *const this</li><li><strong>this指针只能在成员函数中使用，在全局函数、静态成员函数中不能使用this指针。因此，获得一个对象后，不能通过对象使用this指针，但在成员函数中，可以知道this指针位置，也可以直接使用它</strong></li></ul></li><li><p><strong>this指针使用：</strong></p><ul><li>当形参与成员变量名相同时，用this指针来区分</li><li>为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，&#x2F;*this表示对象本身</li></ul></li><li><p><strong>this指针在成员函数的开始执行前构造，在成员函数的执行结束后清除</strong></p></li><li><p><strong>this指针会因编译器不同而有不同的放置位置，可能是栈，也可能是寄存器，甚至全局变量</strong></p></li></ul><h2 id="10-delete-this合法吗？"><a href="#10-delete-this合法吗？" class="headerlink" title="10.delete this合法吗？"></a>10.delete this合法吗？</h2><p><strong>合法，但有前提：</strong></p><blockquote><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p></blockquote><ul><li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 delete this 后面没有调用 this 了</li><li>必须保证 delete this 后没有人使用了</li></ul><p><strong>在类的析构函数中调用delete this会发生什么？</strong></p><ul><li>会导致堆栈溢出</li><li>原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</li></ul><h2 id="11-静态成员变量和静态成员函数"><a href="#11-静态成员变量和静态成员函数" class="headerlink" title="11.静态成员变量和静态成员函数"></a>11.静态成员变量和静态成员函数</h2><p>若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。<strong>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区</strong></p><ul><li><strong>静态成员变量</strong><ul><li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）</li><li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限</li><li>非静态成员类外不能初始化</li><li>静态成员数据是共享的</li></ul></li><li><strong>静态成员函数</strong><ul><li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问</li><li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量</li><li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针</li></ul></li></ul><h2 id="12-初始化列表的好处和使用条件"><a href="#12-初始化列表的好处和使用条件" class="headerlink" title="12.初始化列表的好处和使用条件"></a>12.初始化列表的好处和使用条件</h2><ul><li><p><strong>初始化列表的使用条件</strong></p><ul><li>const类型的数据</li><li>引用类型的数据</li></ul></li><li><p><strong>好处</strong></p><ul><li>初始化是直接初始化成员</li><li>赋值是初始化再赋值</li></ul></li><li><p><strong>不能通过初始化列表初始化静态成员变量</strong>，静态成员变量最好类内声明，类外初始化.静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用域相同的情况下会导致重名的问题</p></li></ul><h2 id="13-运算符重载及-重载实现"><a href="#13-运算符重载及-重载实现" class="headerlink" title="13.运算符重载及++重载实现"></a>13.运算符重载及++重载实现</h2><ul><li><p><strong>运算符重载基本属性</strong></p><ul><li><p>运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型</p></li><li><p>运算符重载的实质是函数重载，可以重载为普通成员函数，也可以重载为成员函数</p></li><li><p>运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址</p></li></ul></li><li><p><strong>运算符重载总结</strong></p><ul><li><p>重载运算符()，[] ，-&gt;， &#x3D;的时候，运算符重载函数必须声明为类的成员函数</p></li><li><p>重载运算符&lt;&lt;，&gt;&gt;的时候，运算符只能通过全局函数配合友元函数进行重载</p></li><li><p>不要重载&amp;&amp;和||运算符，因为无法实现短路原则</p></li></ul></li><li><p><strong>i++和++i实现</strong></p><p>C++内置类型的后置++返回的是变量的拷贝，也就是不可修改的值；前置++返回的是变量的引用，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//++i</span><br><span class="hljs-type">int</span>&amp;  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    *<span class="hljs-keyword">this</span> +=<span class="hljs-number">1</span>；<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>；<br>&#125;<br><br><span class="hljs-comment">//i++，注意后置++有占位参数以区分跟前置++不同</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>    <span class="hljs-type">int</span> oldValue = *<span class="hljs-keyword">this</span>；<br>    ++（*<span class="hljs-keyword">this</span>）；<br>    <span class="hljs-keyword">return</span> oldValue；<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-继承方式、对象模型、同名处理"><a href="#14-继承方式、对象模型、同名处理" class="headerlink" title="14.继承方式、对象模型、同名处理"></a>14.继承方式、对象模型、同名处理</h2><p><strong>继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法</strong></p><ul><li><p><strong>继承方式</strong></p><ul><li><p>公有继承：保持父类中的访问属性</p></li><li><p>私有继承：将父类中的所有访问属性改为private</p></li><li><p>保护继承：除父类中的私有属性，其他改为保护属性</p></li></ul></li><li><p><strong>继承的对象模型</strong></p><ul><li><p>子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出</p></li><li><p>子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反</p><ul><li>由于继承中父类和子类的构造、析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造</li></ul></li><li><p>子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数</p></li></ul></li><li><p><strong>继承中的同名处理</strong></p><ul><li><p>父类和子类<strong>成员属性</strong>同名，用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域</p></li><li><p>父类和子类<strong>成员函数</strong>同名，子类函数不会覆盖父类的成员，只是隐藏起来，用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域</p></li><li><p>若子类中没有与父类同名的成员函数，子类声明对象后，可以直接调用父类成员函数</p></li></ul></li></ul><h2 id="15-多继承和菱形继承"><a href="#15-多继承和菱形继承" class="headerlink" title="15.多继承和菱形继承"></a>15.多继承和菱形继承</h2><ul><li><strong>多继承</strong></li></ul><blockquote><p>多继承会产生二义性的问题。如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类</p></blockquote><ul><li><strong>菱形继承</strong></li></ul><blockquote><p>两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼</p></blockquote><ul><li><p><strong>菱形继承会产生问题</strong></p><ul><li><strong>浪费空间：</strong>羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可</li></ul></li><li><p><strong>二义性：从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题</strong></p><ul><li>羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过carmel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致</li></ul></li><li><p><strong>解决菱形继承的问题</strong></p><p><strong>使用虚继承</strong>，在<strong>继承方式前加virtual</strong>，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age</span><br>&#125;<br>- 此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据<br>- Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）<br>- Sheep的虚指针指向下面Sheep的虚基类表<span class="hljs-symbol">vbtale@</span>Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为<span class="hljs-number">20</span>，即Sheep的虚指针地址偏移<span class="hljs-number">20</span>指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素<br>- Son中包含了两个指针和四个<span class="hljs-built_in">int</span>类型，所以大小为<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><ul><li><strong>虚继承</strong><ul><li><p>一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类</p></li><li><p><strong>每个虚继承的子类（虚基类本身没有）都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），虚基类指针属于对象，虚基类表属于类</strong></p></li><li><p>当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></li><li><p>虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址(虚基类指针)之间的偏移量,以此来访问虚基类数据</p></li><li><p>虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间</p></li><li><p>虚基类表本质是一个<strong>整型数组</strong></p></li><li><p><strong>虚函数属于对象，不属于类，而静态函数属于类</strong></p></li></ul></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,</span><br>&#125;<br>- 注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表<br></code></pre></td></tr></table></figure><h2 id="16-重载、覆盖、重写"><a href="#16-重载、覆盖、重写" class="headerlink" title="16.重载、覆盖、重写"></a>16.重载、覆盖、重写</h2><ul><li><strong>重载(overload)：</strong>是函数名相同，参数列表不同。重载只是在同一个类的内部存在，但是不能靠返回类型来判断</li><li><strong>覆盖(override)：</strong>子类重新定义父类中有相同名称和参数的虚函数。两者的函数特征相同<ul><li>被重写的函数不能是static的。必须是virtual的</li><li>重写函数必须有相同的类型，名称和参数列表</li><li>重写函数的访问权限可以不同。尽管virtual是private的，子类中重写改写为public,protected也是可以的</li></ul></li><li><strong>重写(overwrite)：</strong>也叫做隐藏。子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域</li></ul><h2 id="17-多态实现的基础"><a href="#17-多态实现的基础" class="headerlink" title="17.多态实现的基础"></a>17.多态实现的基础</h2><ul><li><strong>继承</strong></li><li><strong>虚函数覆盖</strong></li><li><strong>父类指针或引用指向子类对象访问虚函数</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Animal&#123;<br>public:<br>    virtual  void speak()&#123; <span class="hljs-regexp">//</span>在父类中声明虚函数，可以实现多态，动态联编<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">0</span>;<br>&#125;;<br><br>class Sheep :public Animal&#123;<br>public:<br>    void speak()&#123; <span class="hljs-regexp">//</span>发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sheep speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">1</span>;<br>&#125;;<br><br>void doSpeak(Animal &amp;animal)&#123;<br>    animal.speak();<br>&#125;<br><br>void test01()&#123;<br>    <span class="hljs-regexp">//</span>传入子类对象调用子类成员函数<br>    Sheep sheep;<br>    doSpeak(sheep); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接调用子类成员函数<br>    sheep.speak();  <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象通过作用域调用父类成员函数<br>    sheep.Animal::speak();  <span class="hljs-regexp">//</span>animal speak;<br><br>    <span class="hljs-regexp">//</span>基类成员不能转换为子类成员，即不能向下转换<br>    <span class="hljs-regexp">//</span>Animal *animal0 = new Animal();<br>    <span class="hljs-regexp">//</span>Sheep * sheep0 = animal0;<br>    <span class="hljs-regexp">//</span>sheep0-&gt;speak();<br><br>    <span class="hljs-regexp">//</span>同样不能向下转换<br>    <span class="hljs-regexp">//</span>Animal animal0;<br>    <span class="hljs-regexp">//</span>Sheep sheep0 = animal0;<br><br>    <span class="hljs-regexp">//</span>父类指针指向子类对象<br>    Sheep *sheep1 = new Sheep();<br>    Animal *animal1 = sheep1;<br>    animal1-&gt;speak(); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>父类引用指向子类对象<br>    Sheep sheep2;<br>    Animal &amp;animal2 = sheep2;<br>    animal2.speak();    <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则<br>    Sheep sheep0;<br>    Animal animal0 = sheep0;<br>    animal0.speak();    <span class="hljs-regexp">//</span>animal speak;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态多态（运算符重载、函数重载）</strong></li><li><strong>动态多态（继承、虚函数）</strong></li></ul><blockquote><p>两者主要的区别：函数地址是早绑定（静态联编）还是晚绑定（动态联编）。即，在编译阶段确定好地址还是在运行时才确定地址</p></blockquote><h2 id="18-虚函数指针和虚函数表"><a href="#18-虚函数指针和虚函数表" class="headerlink" title="18.虚函数指针和虚函数表"></a>18.虚函数指针和虚函数表</h2><ul><li>前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，然后对虚函数重写</li><li>虚函数重写（覆盖）的实质就是重写父类虚函数表中的父类虚函数地址</li><li><strong>实现多态的流程：虚函数指针-&gt;虚函数表-&gt;函数指针-&gt;入口地址，虚函数表（vftable）属于类，或者说这个类的所有对象共享一个虚函数表；而虚函数指针（vfptr）属于单个对象</strong></li><li>在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表</li><li><strong>虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序</strong></li><li>编译器根本不会去区别，传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数<ul><li>如果是虚函数，就根据不同对象的vptr指针找属于自己的函数：父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数</li><li>即：vptr-&gt;虚函数表-&gt;函数的入口弟子，从而实现了迟绑定（在运行的时候，才会去判断）</li></ul></li></ul><h2 id="19-构造函数能否实现多态-x2F-虚函数指针什么时候初始化"><a href="#19-构造函数能否实现多态-x2F-虚函数指针什么时候初始化" class="headerlink" title="19.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化"></a>19.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化</h2><p><strong>两个问题本质是一样的，构造函数不能实现多态</strong></p><ul><li>对象在创建时,由编译器对VPTR指针进行初始化，只有当对象的构造完全结束后VPTR的指向才最终确定</li><li>子类中虚函数指针的初始化过程 当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时Vptr又被赋值指向子类的虚函数表</li><li><strong>构造函数不能是虚函数，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针</strong></li></ul><h2 id="20-抽象类和纯虚函数"><a href="#20-抽象类和纯虚函数" class="headerlink" title="20.抽象类和纯虚函数"></a>20.抽象类和纯虚函数</h2><p>在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求</p><ul><li><strong>纯虚函数的语法格式：<code>virtual 返回值类型 函数名 () = 0;</code>只需要将函数体完全替换为 &#x3D;0即可，纯虚函数必须在子类中进行实现，在子类外实现是无效的</strong></li><li>注意<ul><li>如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象</li><li><strong>如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象但纯虚析构函数例外，因为子类不会继承父类的析构函数</strong></li><li><strong>由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址</strong></li></ul></li></ul><h2 id="21-虚析构和纯虚析构"><a href="#21-虚析构和纯虚析构" class="headerlink" title="21.虚析构和纯虚析构"></a>21.虚析构和纯虚析构</h2><ul><li><p><strong>内存泄漏：当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</strong></p><ul><li>仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数-&gt;子类构造函数-&gt;子类析构函数-&gt;父类析构函数</li><li>当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，如果父类的析构函数不被声明为虚函数，则编译器实施的是静态绑定。销毁的调用流程为：父类构造函数-&gt;子类构造函数-&gt;父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题</li></ul></li><li><p><strong>内存泄漏的解决方法</strong></p><ul><li><strong>将父类中的析构函数设置为虚函数，设置后会先调用子类析构函数，再调用父类析构函数</strong></li></ul></li><li><p><strong>纯虚析构</strong></p><ul><li>纯虚析构需要类内声明，类外实现</li><li>纯虚析构也是虚函数，该类也为抽象类</li><li><strong>子类不会继承父类的析构函数，当父类纯虚析构没有实现时，子类不是抽象类，可以创建创建对象</strong></li><li><strong>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</strong><br><strong>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数</strong></li></ul></li><li><p><strong>C++默认的析构函数不是虚函数：因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存</strong></p></li></ul><h2 id="22-哪些函数不能是虚函数"><a href="#22-哪些函数不能是虚函数" class="headerlink" title="22.哪些函数不能是虚函数"></a>22.哪些函数不能是虚函数</h2><ol><li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化</p></li><li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数</p></li><li><p>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义</p></li><li><p>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法</p></li><li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数</p></li></ol><h2 id="22-类模版和函数模版"><a href="#22-类模版和函数模版" class="headerlink" title="22.类模版和函数模版"></a>22.类模版和函数模版</h2><p><strong>通过template或template实现，主要用于数据的类型参数化，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的</strong></p><ul><li><p>类模板和函数模板定义</p><ul><li><p>template声明下面是函数定义，则为函数模板，否则为类模板</p></li><li><p>注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板(类模板同理)</p></li></ul></li><li><p>类模板与函数模板的区别</p><ul><li>类模板不支持自动类型推导</li><li>数据类型可以有默认参数</li></ul></li></ul><h1 id="三、C-高级特性"><a href="#三、C-高级特性" class="headerlink" title="三、C++高级特性"></a>三、C++高级特性</h1><h2 id="1-构造函数可以抛出异常吗，有什么问题？"><a href="#1-构造函数可以抛出异常吗，有什么问题？" class="headerlink" title="1.构造函数可以抛出异常吗，有什么问题？"></a>1.构造函数可以抛出异常吗，有什么问题？</h2><p><strong>构造函数中应该避免抛出异常</strong></p><ul><li><p>构造函数中抛出异常后，对象的析构函数将不会被执行</p></li><li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露</p></li><li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构</p></li></ul><h2 id="2-初始化列表的异常怎么捕获？"><a href="#2-初始化列表的异常怎么捕获？" class="headerlink" title="2.初始化列表的异常怎么捕获？"></a>2.初始化列表的异常怎么捕获？</h2><ul><li>初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题</li><li>函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常</li></ul><h2 id="3-析构函数可以抛出异常吗，有什么问题？"><a href="#3-析构函数可以抛出异常吗，有什么问题？" class="headerlink" title="3.析构函数可以抛出异常吗，有什么问题？"></a>3.析构函数可以抛出异常吗，有什么问题？</h2><p><strong>析构函数不应该抛出异常</strong></p><ul><li><p><strong>其他正常，仅析构函数异常</strong>。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题</p></li><li><p><strong>其他异常，且析构函数异常</strong>。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题</p></li></ul><h2 id="4-析构函数如何处理异常"><a href="#4-析构函数如何处理异常" class="headerlink" title="4.析构函数如何处理异常"></a>4.析构函数如何处理异常</h2><ul><li>若析构函数抛出异常，调用std::abort()来终止程序</li><li>在析构函数中catch捕获异常并作处理，吞下异常</li><li>如果客户需要对某个操作函数运次期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中</li></ul><h2 id="10-CPP11新特性"><a href="#10-CPP11新特性" class="headerlink" title="10.CPP11新特性"></a>10.CPP11新特性</h2><ul><li><strong>nullptr常量</strong><ul><li>C++中NULL仅仅是define NULL 0 的一个宏定义，因此，有时候会产生歧义<ul><li>比如f（char*）和f（int），参数传NULL的话到底该调用哪个？</li><li>事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题</li></ul></li><li>nullptr是一个空指针，可以被转换成其他任意指针的类型</li></ul></li><li><strong>auto类型指示符</strong><ul><li>让编译器替我们去分析表达式所属的类型，直接推导</li><li>尤其是STL中map的迭代器这种很长的类型，适合用auto</li></ul></li><li><strong>decltype类型指示符</strong><ul><li>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关</li><li><code>delctype (f()) sum = x;</code> 并不实际调用函数f()，只是使用f()的返回值当做sum的类型</li><li><code>delctype (i) sum = x;</code>和<code>delctype ((i)) sum = x;</code> 其中i为int类型，前面的为int类型，后面的为int&amp;引用</li></ul></li><li><strong>范围for语句</strong><ul><li>多与auto配合使用</li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">string <span class="hljs-built_in">str</span>(&quot;somthing&quot;);<br><span class="hljs-built_in">for</span>(auto i:str) <span class="hljs-comment">//对于str中的每个字符，i类型为char</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">for</span>(auto &amp;i:str) <span class="hljs-comment">//对于若要改变每个字符的值，需要加引用</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>定义双层vector</strong><ul><li><code>vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0))</code> 创建m行n列的二维数组，全部初始化为0</li></ul></li><li><strong>lambda表达式</strong><ul><li>用于实现匿名函数，匿名函数只有函数体，没有函数名</li></ul></li></ul><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">[capture list] (params list) <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">exception</span><span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//1</span><br>[capture list] (params list) <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//省略mutable，表示const不可修改</span><br>[capture list] (params list) &#123;<span class="hljs-keyword">function</span> body&#125;;       <span class="hljs-comment">//省略返回类型，按照函数体返回值决定返回类型</span><br>[capture list] &#123;<span class="hljs-keyword">function</span> body&#125;;     <span class="hljs-comment">//省略参数列表，无参函数</span><br>参数capture list：捕获外部变量列表 <br>params list：形参列表 <br><span class="hljs-keyword">mutable</span>指示符：用来说用是否可以修改捕获的变量 <br><span class="hljs-keyword">exception</span>：异常设定 <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>：返回类型 <br><span class="hljs-keyword">function</span> body：函数体<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//示例</span><br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">(vec.begin()</span></span>, vec<span class="hljs-selector-class">.end</span>(), <span class="hljs-selector-attr">[]</span>(int <span class="hljs-selector-tag">a</span>, int b)-&gt;bool&#123;return <span class="hljs-selector-tag">a</span> &lt; b&#125;)<br></code></pre></td></tr></table></figure><ul><li><strong>智能指针</strong><ul><li>shared_ptr</li><li>weak_ptr</li><li>unique_ptr</li></ul></li><li><strong>右值引用</strong><ul><li>左值引用，必须引用左值 <code>int a = 0; int &amp;b = a</code></li><li>右值引用可以引用结果 <code>int &amp;&amp; i = 0</code></li></ul></li></ul><h2 id="5-auto、decltype的用法"><a href="#5-auto、decltype的用法" class="headerlink" title="5.auto、decltype的用法"></a>5.auto、decltype的用法</h2><p><strong>1）auto</strong></p><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p><p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p><p>举个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//普通；类型</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">auto</span> c = a + b;<span class="hljs-comment">// c为int型</span><br><br><span class="hljs-comment">//const类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">auto</span> j = i; <span class="hljs-comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="hljs-built_in">auto</span> k = &amp;i; <span class="hljs-comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">auto</span> l = i; <span class="hljs-comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><br><span class="hljs-comment">//引用和指针类型</span><br><span class="hljs-built_in">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span>&amp; y = x;<br><span class="hljs-built_in">auto</span> z = y; <span class="hljs-comment">//z是int型不是int&amp; 型</span><br><span class="hljs-built_in">auto</span>&amp; p1 = y; <span class="hljs-comment">//p1是int&amp;型</span><br><span class="hljs-built_in">auto</span> p2 = &amp;x; <span class="hljs-comment">//p2是指针类型int*</span><br></code></pre></td></tr></table></figure><p>2）decltype</p><p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">int <span class="hljs-keyword">func</span>() &#123;return <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-regexp">//</span>普通类型<br>decltype(<span class="hljs-keyword">func</span>()) sum = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> sum的类型是函数<span class="hljs-keyword">func</span>()的返回值的类型int, 但是这时不会实际调用函数<span class="hljs-keyword">func</span>()<br>int a = <span class="hljs-number">0</span>;<br>decltype(a) b = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span> a的类型是int, 所以b的类型也是int<br><br><span class="hljs-regexp">//</span>不论是顶层const还是底层const, decltype都会保留   <br>const int c = <span class="hljs-number">3</span>;<br>decltype(c) d = c; <span class="hljs-regexp">//</span> d的类型和c是一样的, 都是顶层const<br>int e = <span class="hljs-number">4</span>;<br>const int* f = &amp;e; <span class="hljs-regexp">//</span> f是底层const<br>decltype(f) g = f; <span class="hljs-regexp">//</span> g也是底层const<br><br><span class="hljs-regexp">//</span>引用与指针类型<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 如果表达式是引用类型, 那么decltype的类型也是引用<br>const int i = <span class="hljs-number">3</span>, &amp;j = i;<br>decltype(j) k = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> k的类型是 const int&amp;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:<br>int i = <span class="hljs-number">3</span>, &amp;r = i;<br>decltype(r + <span class="hljs-number">0</span>) t = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> 此时是int类型<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>. 对指针的解引用操作返回的是引用类型<br>int i = <span class="hljs-number">3</span>, j = <span class="hljs-number">6</span>, *p = &amp;i;<br>decltype(*p) c = j; <span class="hljs-regexp">//</span> c是int&amp;类型, c和j绑定在一起<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了<br>int i = <span class="hljs-number">3</span>;<br>decltype((i)) j = i; <span class="hljs-regexp">//</span> 此时j的类型是int&amp;类型, j和i绑定在了一起<br></code></pre></td></tr></table></figure><h2 id="6-C-中NULL和nullptr的区别"><a href="#6-C-中NULL和nullptr的区别" class="headerlink" title="6.C++中NULL和nullptr的区别"></a>6.C++中NULL和nullptr的区别</h2><ul><li><strong>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void)0,而在C++语言中，NULL则被定义为整数0</strong></li><li><strong>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误</strong></li></ul><h2 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5.智能指针"></a>5.智能指针</h2><ul><li><p><strong>原始指针在引入了异常机制后容易发生内存泄漏、二次释放等问题</strong></p></li><li><p>C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针</p></li><li><p><strong>shared_ptr共享的智能指针</strong></p><ul><li><p>share_ptr的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure></li><li><p><strong>shared_ptr常用操作</strong></p><ul><li>&#96;&#96;&#96;<br>make_shared<T>(args) &#x2F;&#x2F; 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象<br>shared_ptr<T> p(q) &#x2F;&#x2F; p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*<br>p &#x3D; q &#x2F;&#x2F; p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放<br>p.unique() &#x2F;&#x2F; 若p.use_count()为1，返回true；否则返回false<br>p.use_count() &#x2F;&#x2F; 返回与p共享对象的智能指针数量；可能很慢，主要用于调试<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- **shared_ptr的其他方法**<br><br>  - ```<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span> () //若<span class="hljs-selector-tag">p</span>是唯一指向其对象的shared_ptr，reset会释放此对象。<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>) //若传递了可选的参数内置指针<span class="hljs-selector-tag">q</span>，会令<span class="hljs-selector-tag">P</span>指向<span class="hljs-selector-tag">q</span>，否则会将<span class="hljs-selector-tag">P</span>置为空。<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>, d) //若还传递了参数d,将会调用d而不是delete 来释放<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>weak_ptr弱引用的智能指针</strong></p><ul><li><p><code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏</p></li><li><p>要想解决上面循环引用的问题，只能引入新的智能指针<code>std::weak_ptr</code>。<code>std::weak_ptr</code>有什么特点呢？与<code>std::shared_ptr</code>最大的差别是在赋值的时候，不会引起智能指针计数增加</p><ul><li><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作，可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加</li><li>同样，在<code>weak_ptr</code>析构时也不会导致引用计数的减少，它只是一个静静地观察者。<code>weak_ptr</code>没有重载<code>operator*</code>和<code>-&gt;</code>，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因</li><li>如要操作资源，则必须使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象，从而操作资源</li></ul></li><li><p>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它：</p><ul><li>&#96;&#96;&#96;<br>auto p &#x3D; make_shared<int>(42);<br>weak_ptr<int> wp(p); &#x2F;&#x2F; wp弱共享p; p的引用计数未改变<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- **weak_ptr常用操作**<br><br>  - ```<br>    weak_ptr&lt;T&gt; w;<span class="hljs-regexp">//</span> 空weak_ptr可以指向类型为T的对象<br>    weak_ptr&lt;T&gt; w(shared_ptr p);<span class="hljs-regexp">//</span> 与p指向相同对象的weak_ptr, T必须能转换为sp指向的类型<br>    w = p;<span class="hljs-regexp">//</span> p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象<br>    w.reset();<span class="hljs-regexp">//</span> weak_ptr置为空<br>    w.use_count();<span class="hljs-regexp">//</span> 与w共享对象的shared_ptr的计数<br>    w.expired();<span class="hljs-regexp">//</span> w.use_count()为<span class="hljs-number">0</span>则返回true，否则返回false<br>    w.lock();<span class="hljs-regexp">//</span> w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>unique_ptr的基本使用</strong></p><ul><li><p><code>unique_ptr</code>相对于其他两个智能指针更加简单，它和<code>shared_ptr</code>使用差不多，但是功能更为单一，它是一个独占型的智能指针，不允许其他的智能指针共享其内部的指针，更像原生的指针（但更为安全，能够自己释放内存）。<strong>不允许赋值和拷贝操作，只能够移动</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">0</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1; <span class="hljs-comment">// 错误，不能复制</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// 可以移动</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>性能与安全的权衡</strong></p><ul><li><code>shared_ptr</code>的大小是原始指针的两倍，因为它的内部有一个原始指针指向资源，同时有个指针指向引用计数</li><li>引用计数的内存必须动态分配。虽然一点可以使用<code>make_shared()</code>来避免，但也存在一些情况下不能够使用<code>make_shared()</code></li><li>增加和减小引用计数必须是原子操作，因为可能会有读写操作在不同的线程中同时发生。比如在一个线程里有一个指向一块资源的<code>shared_ptr</code>可能调用了析构（因此所指向的资源的引用计数减一），同时，在另一线程里，指向相同对象的一个<code>shared_ptr</code>可能执行了拷贝操作（因此，引用计数加一）。原子操作一般会比非原子操作慢。但是为了线程安全，又不得不这么做，这就给单线程使用环境带来了不必要的困扰</li></ul></li></ul><h2 id="6-野指针"><a href="#6-野指针" class="headerlink" title="6.野指针"></a>6.野指针</h2><p><strong>野指针指向一个已删除的对象或 申请访问受限内存区域的指针</strong></p><p><strong>产生原因：</strong></p><ul><li>指针变量未初始化</li><li>指针释放未置空</li><li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</li></ul><h2 id="7-强制转换"><a href="#7-强制转换" class="headerlink" title="7.强制转换"></a>7.强制转换</h2><p><strong>C++中强制转换为static_cast, dynamic_cast,const_cast, reinterpret_cast</strong></p><ul><li><strong>static_cast</strong><ul><li>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li><li>static_cast &lt; type-id &gt; (expression)</li><li>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：<ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把空指针转换成目标类型的空指针</li><li>把任何类型的表达式转换成void类型</li></ul></li></ul></li><li><strong>dynamic_cast</strong><ul><li>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li><li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</li><li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</li><li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</li></ul></li><li><strong>const_cast</strong><ul><li>用于删除 const、volatile特性</li><li>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：<ul><li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针。如const char *p形式</li></ul></li></ul></li><li><strong>reinterpret_cast</strong><ul><li>reinterpret_cast<type-id> (expression)</li><li>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</li><li>几乎什么都可以转,不能丢掉 const、volatile特性</li></ul></li></ul><h2 id="8-RTTI"><a href="#8-RTTI" class="headerlink" title="8.RTTI"></a>8.RTTI</h2><p><strong>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid</strong></p><ul><li><p>dynamic_cast 动态类型转换</p></li><li><p>typeid typeid 运算符允许在运行时确定对象的类型，获取对象的实际类型</p></li></ul><h2 id="9-RAII"><a href="#9-RAII" class="headerlink" title="9.RAII"></a>9.RAII</h2><p><strong>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”</strong></p><ul><li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li><li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li></ul><h2 id="11-右值引用"><a href="#11-右值引用" class="headerlink" title="11.右值引用"></a>11.右值引用</h2><ul><li><p><strong>定义：</strong></p><ul><li>左值：存储在内存中，有明确存储地址(可寻址)的数据</li><li>右值：可以提供数据值的数据(不一定可以寻址，如寄存器中的数据)</li></ul></li><li><p><strong>判断某个表达式是左值还是右值</strong></p><ul><li>可位于&#x3D;左侧的表达式就是左值；反之，只能位于&#x3D;右侧的表达式就是右值</li><li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值</li></ul></li><li><p><strong>右值引用：</strong></p><ul><li><strong>右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</strong></li><li>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>&amp; b = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//左值引用</span><br><span class="hljs-built_in">int</span>&amp; e = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，左值引用不能使用右值初始化</span><br><span class="hljs-built_in">int</span>&amp;&amp; d = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//错误，右值引用不能使用左值初始化 </span><br><span class="hljs-built_in">int</span>&amp;&amp; a = <span class="hljs-number">10</span>; <span class="hljs-comment">//右值引用</span><br><span class="hljs-built_in">int</span>&amp;&amp; c = <span class="hljs-built_in">num</span> + <span class="hljs-number">40</span>; <span class="hljs-comment">//右值引用</span><br>a = <span class="hljs-number">100</span>; <span class="hljs-comment">//右值引用可以对右值进行修改</span><br></code></pre></td></tr></table></figure></li><li><p><strong>右值引用的特点</strong></p><ul><li>通过右值引用的声明，右值的生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值变量将会一直存活下去</li></ul></li><li><p><strong>移动语义</strong></p><ul><li><p><strong>定义：</strong>即从右值中直接拿数据过来初始化或修改左值，而不需要重新构造一个临时左值后再析构右值，减少了两个对象交互时不必要的拷贝构造</p></li><li><p><strong>可解决的问题：</strong></p><ul><li>用右值参数</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//在实现转移语义之前</span><br><span class="hljs-comment">//const &amp;的形参接收了右值参数，但是调用了额外的拷贝构造函数，生成了一个临时变量，销毁临时变量还调用了一次析构函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//在实现转移语义之后</span><br><span class="hljs-comment">//会调用1次移动构造函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br>MyString(MsString &amp;&amp; <span class="hljs-built_in">str</span>)&#123;<br><span class="hljs-variable">_len</span> = <span class="hljs-built_in">str</span>.len;<br><span class="hljs-variable">_data</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span>;<span class="hljs-comment">//从右值中获取数据</span><br><span class="hljs-built_in">str</span>.len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> = NULL;<span class="hljs-comment">//销毁右值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对象存入容器<ul><li>void push_back(const T&amp; value)</li><li>void push_back(T &amp;&amp; value)</li><li>使用push_back()需要调用拷贝构造函数和移动构造函数</li><li>而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造函数和移动构造函数，效率更高</li></ul></li><li>vector增长扩容<ul><li>移动语义之前是复制并删除，之后只需要移动即可</li><li>vector添加元素在空间不够的时候需要重新分配，此时对于原来已有的元素会调用对象类的move constructor，而如果对象类没有定义移动构造，则会使用copy constructor</li><li>所以给类添加移动构造函数可以在很多时候提高效率，因为没有它只能用拷贝构造来替代，而编译器又不会自动合成一个</li></ul></li></ul></li><li><p><strong>std::move函数</strong></p><ul><li>将左值转变为右值</li><li>只有右值引用的类型在后面加上&amp;&amp;仍然是右值引用</li><li>其余的在后面加&amp;或者&amp;&amp;都是左值引用</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">string</span> s(<span class="hljs-string">&quot;hello&quot;</span>);<br>std::move(s) =&gt; std::move(<span class="hljs-keyword">string</span>&amp; &amp;&amp;) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp; )<br>此时：T的类型为<span class="hljs-keyword">string</span>&amp;<br>remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例化如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp; t) <span class="hljs-comment">//t为左值，移动后不能在使用t</span><br>&#123;<br>    <span class="hljs-comment">//通过static_cast将string&amp;强制转换为string&amp;&amp;</span><br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir">std::move(<span class="hljs-keyword">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp;&amp;)<br>此时：T的类型为<span class="hljs-keyword">string</span> <br>     remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp;&amp; t) <span class="hljs-comment">//t为右值</span><br>&#123;<br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t);  <span class="hljs-comment">//返回一个右值引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>完美转发</strong></p><ul><li>使用场景：需要将一组参数原封不动地传递给另一个函数，左值&#x2F;右值、const&#x2F;non-const属性在传递过程中不能改变</li><li>使用方法：<ul><li>在模板参数列表中使用T&amp;&amp;（通用引用）</li><li>使用std::forward()转发变量</li></ul></li></ul></li></ul><h1 id="四、STL模板库"><a href="#四、STL模板库" class="headerlink" title="四、STL模板库"></a>四、STL模板库</h1><h2 id="1-STL中的swap函数"><a href="#1-STL中的swap函数" class="headerlink" title="1.STL中的swap函数"></a>1.STL中的swap函数</h2><ul><li>除了数组，其他容器在交换后本质上是将内存地址进行了交换，而元素本身在内存中的位置是没有变化</li><li>swap在交换的时候并不是完全将2个容器的元素互换，而是交换了2个容器内的内存地址</li></ul><h2 id="2-STL中的哈希表扩容"><a href="#2-STL中的哈希表扩容" class="headerlink" title="2.STL中的哈希表扩容"></a>2.STL中的哈希表扩容</h2><ul><li><strong>哈希表概述</strong><ul><li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预</li><li><strong>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</strong></li></ul></li><li><strong>哈希表扩容</strong><ul><li>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置</li><li><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png" alt="img"></li><li>这里需要知道STL中的swap底层，其实扩容也是vector扩容<ul><li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到sqrt(n)范围内的数) </li><li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换两个桶的地址)</li><li>通过swap函数将新桶和旧桶交换，销毁新桶</li></ul></li></ul></li></ul><h2 id="3-STL迭代器失效的几种情况总结"><a href="#3-STL迭代器失效的几种情况总结" class="headerlink" title="3.STL迭代器失效的几种情况总结"></a>3.STL迭代器失效的几种情况总结</h2><ul><li><p><strong>迭代器的失效问题：</strong>对容器的操作影响了元素的存放位置，称为迭代器失效</p></li><li><p><strong>失效情况</strong></p><ul><li>当容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li><li>当容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了</li></ul></li><li><p><strong>序列式容器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; q&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><span class="hljs-comment">// 在这里想把大于2的元素都删除</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br><span class="hljs-keyword">if</span> (*it &gt; <span class="hljs-number">2</span>)<br>q.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 这里就会发生迭代器失效</span><br>&#125;<br><span class="hljs-comment">// 打印结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>迭代器失效的原因是：因为 vetor、deque 使用了连续分配的内存，<code>erase</code>操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效</p></li><li><p>解决方法是利用<code>erase</code>方法可以返回下一个有效的 iterator，所以代码做如下修改即可：</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在这里想把大于<span class="hljs-number">2</span>的元素都删除<br><span class="hljs-keyword">for</span>(auto it=q.begin();it!=q.end();)<br>&#123;<br>    <span class="hljs-keyword">if</span>(*it&gt;<span class="hljs-number">2</span>)<br>    &#123;<br>    it=q.erase(it); <span class="hljs-regexp">//</span> 这里会返回指向下一个元素的迭代器，因此不需要再自加了<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    it++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>链表式容器</strong></p><ul><li>对于链表式容器(如 list)，删除当前的 iterator，仅仅会使当前的 iterator 失效，这是因为 list 之类的容器，<strong>使用了链表来实现，插入、删除一个结点不会对其他结点造成影响</strong></li><li>只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator</li></ul><p><strong>方式一：递增当前 iterator</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); it != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*iter)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      cont.<span class="hljs-built_in">erase</span>(iter++);<br>   <span class="hljs-keyword">else</span><br>      iter++;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式二：通过 erase 获得下一个有效的 iterator</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); iter != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*it)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      iter = cont.<span class="hljs-built_in">erase</span>(iter);  <span class="hljs-comment">//erase删除元素，返回下一个迭代器</span><br>   <span class="hljs-keyword">else</span><br>      ++iter;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>关联式容器</strong></p><ul><li>对于关联容器(如 map, set,multimap,multiset)，删除当前的 iterator，仅仅会使当前的 iterator 失效，只要在 erase 时，递增当前 iterator 即可</li><li>这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响</li><li><strong>erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用<code>erase(iter++)</code>的方式删除迭代器</strong></li></ul><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">for</span> (iter = dataMap.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; iter != dataMap.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; )<br>&#123;<br>         <span class="hljs-built_in">int</span> nKey = iter-&gt;first;<br>         <span class="hljs-built_in">string</span> strValue = iter-&gt;second;<br><br>         <span class="hljs-keyword">if</span> (nKey % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>         &#123;<br>               dataMap.erase(iter++);<br>               auto a = iter;<br>         &#125;<span class="hljs-keyword">else</span><br>      &#123;<br>          iter++;<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>dataMap.erase(iter++); <strong>这句话分三步走，先把 iter 传值到 erase 里面，然后 iter 自增，然后执行 erase，所以 iter 在失效前已经自增了</strong></li><li>map 是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系</li></ul></li></ul><h2 id="4-迭代器：-it、it-哪个好，为什么"><a href="#4-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.迭代器：++it、it++哪个好，为什么"></a>4.迭代器：++it、it++哪个好，为什么</h2><ol><li>前置返回一个引用，后置返回一个对象</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span> <span class="hljs-comment">// ++i实现代码为：</span><br>int&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>  *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br></code></pre></td></tr></table></figure><ol start="2"><li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2.</span> <span class="hljs-comment">//i++实现代码为：                 </span><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)                 <br>&#123;<br>   <span class="hljs-type">int</span> temp = *<span class="hljs-keyword">this</span>;                   <br>   ++*<span class="hljs-keyword">this</span>;                       <br>   <span class="hljs-keyword">return</span> temp;                  <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="5-STL中的allocator、deallocator"><a href="#5-STL中的allocator、deallocator" class="headerlink" title="5.STL中的allocator、deallocator"></a>5.STL中的allocator、deallocator</h2><ul><li><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器</p></li><li><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块</p></li><li><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空</p></li><li><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面经-个人总结</title>
    <link href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、TCP与UDP"><a href="#一、TCP与UDP" class="headerlink" title="一、TCP与UDP"></a>一、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1.TCP 和 UDP的概念及特点"></a>1.TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p><p><strong>（1）UDP</strong></p><p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的</p><p>它的特点如下：</p><p><strong>1）面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2）有单播，多播，广播的功能</strong><br>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</p><p><strong>3）面向报文</strong></p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4）不可靠性</strong></p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP</p><p><strong>5）头部开销小，传输数据报文时是很高效的</strong></p><p><img src="data:image/jpg;base64,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" alt="图片"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</li></ul><p><strong>（2）TCP</strong> </p><p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）</p><p>它有以下几个特点：</p><p><strong>1）面向连接</strong></p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础</p><p><strong>2）仅支持单播传输</strong></p><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式</p><p><strong>3）面向字节流</strong></p><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输</p><p><strong>4）可靠传输</strong></p><p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</p><p><strong>5）提供拥塞控制</strong></p><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><p><strong>6）提供全双工通信</strong></p><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2.TCP和UDP的区别"></a>2.TCP和UDP的区别</h3><table><thead><tr><th align="left"></th><th align="left"><strong>UDP</strong></th><th align="left"><strong>TCP</strong></th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制，尽最大努力交付</td><td align="left">可靠传输（数据顺序和正确性、不重复），使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td align="left">只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td align="left">面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td align="left">首部最小20字节，最大60字节</td></tr><tr><td align="left">报文长度</td><td align="left">面向报文，不合并，不拆分，直接传输报文</td><td align="left">TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的，流式传输</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用，例如视频会议、直播</td><td align="left">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3.TCP和UDP的使用场景"></a>3.TCP和UDP的使用场景</h3><ul><li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录</li><li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）</li></ul><h3 id="4-IP-x2F-TCP-x2F-UDP分片"><a href="#4-IP-x2F-TCP-x2F-UDP分片" class="headerlink" title="4.IP&#x2F;TCP&#x2F;UDP分片"></a>4.IP&#x2F;TCP&#x2F;UDP分片</h3><p>数据发送时，将数据从应用层-&gt;传输层-&gt;网络层-&gt;数据链路层，其中传输层是TCP和UDP，网络层是IP协议</p><ul><li><strong>MTU以太网帧的长度为1500字节，所能接收的传输层数据段最大为 1480 个字节（以太网帧中的数据包括 IP 协议的报头信息，IP 协议的报头信息为 20 字节）</strong></li><li><strong>在计算 MSS （网络传输数据最大值）的时候，用 MTU 减去网络层报头长度以及传输层报头长度即可</strong></li><li><strong>UDP</strong><ul><li>一旦 UDP 携带的数据超过了 1472 （MTU - IP报头 - UDP报头 &#x3D; 1500 - 20 - 8），那么在 IP 层就会对该数据分片，一旦分片就意味着增加了 UDP 传输丢包的可能性。 由于 UDP 协议传输本身就不负责可靠性，再加上分片，那么丢包的可能性就大大增加</li></ul></li></ul><h3 id="5-UDP协议为什么不可靠？"><a href="#5-UDP协议为什么不可靠？" class="headerlink" title="5.UDP协议为什么不可靠？"></a>5.UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li><strong>不保证消息交付：</strong>不确认，不重传，无超时</li></ul><ul><li><strong>不保证交付顺序：</strong>不设置包序号，不重排，不会发生队首阻塞</li><li><strong>不跟踪连接状态：</strong>不必建立连接或重启状态机</li><li><strong>不进行拥塞控制：</strong>不内置客户端或网络反馈机制</li></ul><h3 id="6-TCP的重传机制"><a href="#6-TCP的重传机制" class="headerlink" title="6.TCP的重传机制"></a>6.TCP的重传机制</h3><ul><li>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong></li><li>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号</li></ul><h3 id="7-TCP的可靠传输机制"><a href="#7-TCP的可靠传输机制" class="headerlink" title="7.TCP的可靠传输机制"></a>7.TCP的可靠传输机制</h3><ul><li><strong>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的</strong></li><li><strong>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段</strong>。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段</li><li><strong>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答</strong>。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面</li><li>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP就是通过控制发送窗口的长度来控制报文段的发送速率</li><li><strong>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体</strong></li></ul><h3 id="8-TCP的流量控制机制"><a href="#8-TCP的流量控制机制" class="headerlink" title="8.TCP的流量控制机制"></a>8.TCP的流量控制机制</h3><p><strong>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小</strong></p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口</li><li><strong>滑动窗口出现的原因：</strong>在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候</li></ul><h3 id="9-TCP的拥塞控制机制"><a href="#9-TCP的拥塞控制机制" class="headerlink" title="9.TCP的拥塞控制机制"></a>9.TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li><p><strong>慢启动（慢开始）</strong></p></li><li><p><strong>拥塞避免</strong></p></li><li><p><strong>快速重传</strong></p></li><li><p><strong>快速恢复</strong><br><strong>（1）慢启动（慢开始）</strong></p><ul><li>在开始发送的时候设置cwnd &#x3D; 1（cwnd指的是拥塞窗口）</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)<ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p><strong>（2）拥塞避免</strong></p><ul><li><p>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞</p></li><li><p><strong>思路：</strong>让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</p></li><li><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示：<br><img src="data:image/jpg;base64,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" alt="图片"></p></li><li><p>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</p></li></ul></li><li><p><strong>（3)快速重传</strong></p><ul><li><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p></li><li><p>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</p></li></ul></li><li><p><strong>（4）快速恢复</strong></p><ul><li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法</p></li><li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法<br>   <img src="data:image/jpg;base64,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" alt="图片"></p></li></ul></li></ul><h3 id="10-流量控制和拥塞控制的区别"><a href="#10-流量控制和拥塞控制的区别" class="headerlink" title="10. 流量控制和拥塞控制的区别"></a>10. 流量控制和拥塞控制的区别</h3><ul><li>拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程</li><li>流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收</li></ul><h3 id="11-TCP的三次握手和四次挥手"><a href="#11-TCP的三次握手和四次挥手" class="headerlink" title="11.TCP的三次握手和四次挥手"></a>11.TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img src="data:image/jpg;base64,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" alt="图片"></p><p><strong>三次握手（Three-way Handshake）</strong>其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息</p><ul><li>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态</li><li><strong>第一次握手：</strong>客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态</li></ul><blockquote><p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><ul><li><strong>第二次握手：</strong>服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</li></ul><blockquote><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p></blockquote><ul><li><strong>第三次握手：</strong>客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li></ul><blockquote><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>为了确认双方的接收能力和发送能力都正常</li><li>如果是用两次握手，则会出现下面这种情况：</li></ul><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源<strong>简单来说就是以下三步：</strong></p></blockquote><ul><li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态</li><li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态</li></ul><ul><li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</li></ul><p><strong>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程</strong>，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况</p><h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li><strong>第一次挥手：</strong>客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态</li></ul><blockquote><p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认</p></blockquote><ul><li><strong>第二次挥手：</strong>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段</p></blockquote><ul><li><strong>第三次挥手：</strong>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认</p></blockquote><ul><li><strong>第四次挥手：</strong>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态</p></blockquote><p><strong>那为什么需要四次挥手呢？</strong></p><blockquote><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手<strong>简单来说就是以下四步：</strong></p></blockquote><ul><li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求</li><li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态</li><li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态<br>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态</li></ul><p><strong>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭</strong></p><h3 id="12-ACK-SYN-FIN解释及是否消耗序列号"><a href="#12-ACK-SYN-FIN解释及是否消耗序列号" class="headerlink" title="12.ACK SYN FIN解释及是否消耗序列号"></a>12.ACK SYN FIN解释及是否消耗序列号</h3><ul><li>ACK 确认标志位，ACK可以携带数据，若不携带，则不消耗序列号</li><li>SYN 同步标志位，SYN不能携带数据，必须消耗一个序列号</li><li>FIN 终止标志位，FIN可以携带数据，必须消耗一个序列</li></ul><h3 id="13-TIME-WAIT状态及2MSL时间"><a href="#13-TIME-WAIT状态及2MSL时间" class="headerlink" title="13.TIME-WAIT状态及2MSL时间"></a>13.TIME-WAIT状态及2MSL时间</h3><ul><li>四次挥手期间，客户端和服务器端都可主动释放连接，谁主动释放，谁将进入TIME_WAIT状态</li><li>MSL是最长报文寿命，一般为2分钟，2MSL即4分钟</li><li><strong>为什么TIME-WAIT状态必须等待2MSL时间？</strong><ul><li><strong>保证最后一次挥手报文能到B，能进行超时重传。</strong>若B收不到A的ACK报文，则B会超时重传FIN+ACK，A会在2MSL时间内收到重传报文段，然后发送ACK，重新启动2MSL计时器</li><li>2MSL后，本次连接的所有报文都会消失，不会影响下一次连接</li></ul></li></ul><h3 id="14-TCP粘包是怎么回事，如何处理"><a href="#14-TCP粘包是怎么回事，如何处理" class="headerlink" title="14.TCP粘包是怎么回事，如何处理?"></a>14.TCP粘包是怎么回事，如何处理?</h3><ul><li><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法)，在数据发送之前缓存他们。如果短时间有多个数据发送，会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能</p></li><li><p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包</p></li><li><p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据</p></li><li><p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p><ul><li><p><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理</p></li><li><p><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</p></li><li><p><strong>进⾏封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包</p></li></ul></li></ul><h3 id="15-为什么udp不会粘包？"><a href="#15-为什么udp不会粘包？" class="headerlink" title="15.为什么udp不会粘包？"></a>15.为什么<strong>udp</strong>不会粘包？</h3><ul><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤小小于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收</li></ul><h2 id="二、网络模型概述"><a href="#二、网络模型概述" class="headerlink" title="二、网络模型概述"></a>二、网络模型概述</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型<img src="data:image/jpg;base64,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" alt="图片"></p><h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等</p><ul><li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议</li><li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘迅雷</code>应该是基于此协议的</li><li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议</li><li><strong>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</strong></li></ul><h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><ul><li>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一</li><li>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层</li></ul><h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成</p><h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><ul><li>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”</li><li>应用需要传输的数据可能会非常大，如果直接传输</li></ul><h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式</p><h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能</p><h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质</p><p><strong>OSI七层模型通信特点：对等通信</strong> 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信</p><h3 id="2-TCP-x2F-IP五层协议"><a href="#2-TCP-x2F-IP五层协议" class="headerlink" title="2.TCP&#x2F;IP五层协议"></a>2.TCP&#x2F;IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下： <img src="data:image/jpg;base64,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" alt="图片"></p><ul><li>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等</li><li><strong>传输层 (transport layer)</strong><br>有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议： </li><li><strong>传输控制协议 (Transmission Control Protocol，TCP)：</strong>提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）</li><li><strong>用户数据报协议 (User Datagram Protocol，UDP)：</strong>提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报<ul><li>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</li><li>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）</li><li>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境<br>从上图中可以看出，TCP&#x2F;IP模型比<code>OSI</code>模型更加简洁，它把应用层&#x2F;表示层&#x2F;会话层全部整合为了应用层，在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的<img src="data:image/jpg;base64,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" alt="图片"></li></ul></li></ul><p> 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： <img src="data:image/jpg;base64,UklGRkh2AABXRUJQVlA4IDx2AAAwLAKdASoABdABPplGn0ulo6aho/CbaNATCWNu/CCv6ZEfWv9ZG6vJeIODCxgqY8Wh8f2/aOzH7K/rf6L0qed/HGMp/h65e3PMN6l89H/D9Sn9p/4/sLf1T/Keq30S/4n0Hf1X/v+rp6R/776hv869MH1Y/9F6p3nAesN/bMll+Uf1r/If4nxa/uP+s/xX4/+pPlg9ue53+J9u7/m8QHS/7Zeq385++v8r+9e03+Q/4X+W/Kn0r+Uf+7/jvYI/Of6l/wvGR2pPFeYX7l/ePND+l/9n+j/w3tH9t/YD/pn+F9QP+x4i/sfsFf1b/h+kD9feoT9e/4/sQkyZtdMm6jbcza6ZN1G25l5bTWm93zYqduodwqp2yImGEBcSK2ZQ1DMPmbXTJuo23M2umTdRtuZtdMm6jbcza6ZNylbhBUA6RrLYuR/969QXQFUvZ8Hrt5ynWn9lxLeAIs7ejAcDeuobUplGYP4yTys8hvchsRwc5m10yble/uA5rpS7PTfK2i5Yd0ZMEru9wRmpW9fuJ5dVdTRuPHV2O3uJUNlO8LgfOFzYccjlJxvNq8G409bgt/AuhiB2+dzJuo23M2umTdRtuZtdMm6jbcza6ZN1G25mbJ71KApqwIasVRhoRikj579f3+szJyBEZMeGVhZqj1e4uuuhVEpeYOvOKGKbudf6RtuZtDarUT81ul0PFDzvn2b425uH4WeVgL97HRfJZzeX35RYL7EQGVmajCAS/0jbcza6ZN1G25m10ybqNtzNrpk3UbbYKf9fXxusu1l2su1l00t21O1AJL/SNrZMIRy+SsipILmtFzm+QZstlwkv9I23M2umTdRtuZtdMm6jbcza6ZNFvZrkHrF1Lh5kUw4TtxBAOIBKG7qNpQ76KVY4JtkVFHzMdX37RPXpTO4UkjSZc2dQpUyF45c2NHtrnM2umTdRtuZtdMm6jbcza6ZN1G25m041cFq5Xo6OOnQeYyVryb3o+knZd1obh8I4aWs97Sh4/X7IJW/a02McITNIC4fMy4KqS4NtzNrpjqXUvZm10ybqNtzNrpk3UbbmbXTJuo23M2uFFeCWnkZNG+qESy0lcS1NlXdIW6FyZ9Etm0A1BJsxvGxSVy4NtzNrpUDsza6ZN1G25m10ybqNtzNrpk3UbbmbXDFWmkow7LYpnJMXH/9JHBrYHv6bxezj/L5nVDwzMjFrLgzb6ZN1G25m0QszOAkv9I23M2umTdRtuZtdMm6jbcza6ZNysvan46Yv2i/GdCSbPqIY7nIShWavRr3wMlOOwCkRPHoh9310xC3Lns7vurS/Y8hRdpMaXv/Vj+8538puUIMExPbPK24fmpQXiuUWBnLsOTeszRCDnMm6jbcza6ZN1G25m10ybqNtzNrpNmzKJF08s5Mktt2dO1YcOg338EtDLSMrJ0WedX5cA3D3ofUqOmqYmX/g0PePYrJWkw5RAOnIl/x8YAP0kaJNclJnU2gUGvzHT1XdKUNVaE8x51VxdjkkF3EJtDNNkt1DWfqR+rp9p+Vm+oexdvaqAF11PumTdRtuZtdMm6jbcza6ZN1G25mYlklYou9ivVa9WdgdC7i4Dmg6xGPLOwFW6o8Q5X7XCTAaS2ulQOzAXuDNlHwolpJ9JPpJ9JPpJ9JPpJ9JPpJ9JPpJ9JPpJ9JOuXlOURZP7SSJb/WbE+Qf0cYsR4popvqiEk+wC7GcOIh0aNB7bB32jbnuYjbmbXTJuoMqv6iAHWdktYGfqQC58/yiVco/ivn5FDtdyH+cjT0BL9szyKlbAGFREFAnPA+6qf0iu7Tl7danaEOTgfptp+Nepb5l8WLXh25BBVt+9jDyqw7avOdgbZxqJkEQB+eENq1QgJEPfBwarpLGVt0gfQj0xwZRb7xCALl9QBzNHxCgWxJKl3mO4JMSNN7J3197Ajv7766Ri4SX+kbbdekjJh0f6j3vzEju6ii+gMl4PPdJjv6r0ikaRl51ZruLlXD+czTZtAptwcsmmpK/zN3IauN9KlCCH+GNAM0thvbY0p49/BaD9MemPtxkEkcl11+mX2gKKS8vtFz2hyYcNzVdbJ7v69mEDXEqlmbZMwFqCATmCx6+UaA6K8s0jwgZhVHGFSzQulhGXEp1DwLLQmiRrHrYsw5vzTVSR2u8uzRdVEzcLNxDErD5dsTF3H0q+PdIyn630mKItpHt3ZS8OTtPDL/NdIomr0ekbbmbXSu53RJNpcuElrm1FveHKN8HVoZadacgJGRXhNy8gtk6yNFzmHFuUJfPhVAblgvqqV5C2Vr6oakuP8y8MkQMvP40NEJyVb/p/MpWXeFJhIa00qKdM86hJbELrWcaxg8Z+x980+CqeQTHEXYi7FjyUxMpvxRAq+kNwZm1vLlEiMXKuuFNsZBfG7grcFbgqLLRk1xOpHkShJf6PMX1n/irP2v3WZbgbWXbgbcDazLcDbgbcDazLcFbgrWZazKnjp3tMS1cLQmeibuT1r/d08Ge7Za6l3jQbii9TSDmfJye/dOEz2mG/TYxoNfASuiOxcQU1HnZrN1DrhQqsUiz9q3PHEVRXsc1z+ScarpqUf6Bys754wrKNzUKrxvWwGOICfWoD9DkO5zE4Oa9WmXLg23MyWZCUXXyYJ/uDIvCTAMCCH0zknxQbv2UlquJi1vrdGORoPJfPlvz7pk3UbgR4F3quSwwDtCO8m4uqq4B17qhzIO4rDIAhpwctSW1H2vwyjBa1XT/qOvInWLiRFaG4vr6eQ6NA87HnY1m8NAp9sadUyoLXY32/O4oNcf5J+hTJmSlR/qGbHhOXXFalgq27VGHBw1UlcV9hQF1ZZRzh/kp3L0XhC8IVfgCI2Vak0hsZxcGZtdMmyS8hPjM70TOnYYXCN1OypcmWwvnWzDob8pwq0Ykfd+/OIQ4qPmbXTJuSOHN2VRftrNmXyREQmX8VJBc1nEdFEFRDo73P9Fby5cG1gFPULlJzDGApgHXIqSC50hd/pPC2WxfqbiW10xzTKjvWhVc1LNMAZXzE9IXg8RziOcUIXOcRziOi8IXhC8IXhCihfi9bhfqag9hiI/uNnnHi30subViM7rdN7MJDkfSYTGhb73BmvV1BMIj3wRRoFXTJunjlrhY61Grjxb7XdgAuh+puALnbYSBWKTzodDk3299aCc8y2yOZtdJIx7f+/DgI4okaTLmdB3KZFUaKdHmmDJ2dQxf+m1PjiGXLCKkiY8AQg851+4pZPEeT6m4tAxKDtYDN7aqWUh+zhytfQYUSNDHRCBf4SOlpgzYspZb8jtP6rfWVEk4QDCqDSi/obxv6S32rtA6hr/9MF1KzKGepJJMN685gI0386qt3xkXGIdYr8YoRYlw66wi55S0ppyzYVTWIRYSsnZmY8GJwxR7r5uwOp2MWOics+VH609IXhC77/aPbEA113tEFirF9Mm6ja+xSxKwte12vvGlTcSJ9jA/UOVvFF8yAmOP2Ys2Sb2hRJznvrbuuEVozsLy2hLxBUnS0Fo4ir7X0fGiFAaAjXtWxQHX7slLAFrUAkg8z7pk3KQjmvBUj3loR4OpklOnBvdKBPiEtzxQ01UCXMdYyOFpQvGnB1iVb5C7rF07rOXKPl2l1zRz4RP4ChQ9YPtoIp1WYjYtwJtaacDRD5m0iAf6FEloyVmwgE5m1wMuhlzurnX/xzm9kguJUYfFHVWcPYgLS7EPBQ7Te1KRl2gapp3c3YKrSk9n3jbmbQDW/1DeIMAy79Q39WGUd4jBfZgHgUB8fQYVkVJBpOpyndL8vMnhW6jbcsspqVaMHU/+1Mno8Rzig8RzihCareHvuVOWFzU+6ZNxziWGG538U9+ONsT0heELweI6LwheDxHOKELnOKELnReELwheEJqrr+xmFPqKd0ug+8oj8nHSrEI4NDOldZmsGPka/lEgHl9mZ15Lub5dVXFqcp19Jw+UFqMI1Yewx3Zkv6ZNyRDYxUO4wdYA5UaDZ/03dRZ+2rJM6Eu3R4pAhEa3sE74xhEuXs1oN5tM1pSyB2NkEoJzMo6ZOFvXeLJlsgLMo1akgcO4GdPilAHq1OkbZA+1v4/n34KaAj6asMrXgVpp4SJL8bV+VnBtGSaM3b2tdGld5tcGM7qmKo4YKHTpwKzQ5R8J4cZc6kPD58lk/V+xFhca3jpXS+cSzB2WKexybtwaxRs1cX13WxJ2YtDKRwKNBBRtfCvl5uEIlyfJGtyFSkG/hiP5FH0tazdF9ItmJabf1EL/ZIzTEz3Dq/NeN2sZQKCmxSX6cpLz2OspSO/rg1m2IKJrWd9spoxUxe3OH1SEeChxv7dR92asJQigDAqhEt9mijjdwVuCpB/a8S3L1+I6GkPhsw3E/gvDZxGDa/GQz3bIO97ADFVGnhVKJol8M8T5UKTDddZMrWS8ArOsvv1p4bcoQjjYMg9KWg5zxDNAoAkcbuCtwVHfAkbPbrYrQTKkiJmU+1A4RCc+aVSsg2SVR1fZHHe9cGn+lKT4uHRh+SLjMRmSCwqQaQ4fNQf2eucrTh19HLGZXXAu/mlSWnDrHmmlt8mN7yyl1Nzk1n4aUUertO8BwZA7GNDwh2+3nPrb/iGkDnUYtIr1OwiduY5v69FuVFr6F6Nm5yyi2ZdgBA9KdF5o1fIrZpiAwmW7eLMJqT1mHgsPt6RYtyyfR/Bj1KB5o8E2WjLs7Jwr6YKhmFNBEFk82ALCLWIDmPC2iqIGaYZIt+JEFSutXbiIRJZvaIDJuozEi5SkpF2I0GSRIWrTGmDZM70JNiAbuwuA5of5jwc7rIZm10mpAx5TYC94Bgz1G0GEgO8wAyzm5wKN7SuHbd+7/IHeWEX0gqIoal+AvzgqiXBOi1dp5HbGMNlH0h6bD0XxvZh1qR7rIHJFHZADZS+oyTe1rM/tCumTdPEwb3P3G3cUdYTzpfMJ9uwmieF3qShTykm7CgXRNE+Ai8fXyIUyQHyKPmbQ5ZHV0ob3z3q/tVQJ88NBkNFVnQT5Hc0PK4E6gJON4tE61CqTkFL322O1wvp6ASb/wgCb2ADXGHyYKC2qdIPDi2o2hN+HlASJ/ohmqQfkMwIjzkX1NL6VZ5R/tUHc7TpVFzEhnZHrWzMYPJn2ol86P4l6hqFscQORAdq5OQXtG0GoHHyZDGZZoYBeAZx8wphMwBlOT0Blt9oG6k+Jn+f4avEKUperM0yAp7LHA2rNj9ivPCcwOGUMwm+iMFwO9FrkAlI0QDKIDKcYwG/wnTq6bdWCL7PozgVzK3xuFM2ynbzfxp9sjbhalqRTYfTeFMiaulPtvlblZLN2FeHbI5+wbUQgzqspW8X2JFEV0T2piIky+c3Ys9BkV0DHYVRR0ODykItxKUqgFyQwk+87ENMTL5NWOyMP8MT2i9tgZbklhnwrVAE9cbnkeiY0bttpVNTxxrQ9ZCeOX29Mf7lcUBb36Wi7tcxSPhI+C4WMqDHj+IuLawcw0aVOM7xPYsbg/u0j2szG8LmKOQ3HOkkOpgVD4lPL4Caz1wxy5WQoHlusgf6y3TG8buCtvZu54E7Z6PSU114cyUV/BS3NTcKT6ilqJe9CwPR8TETyPJ2g1qictBX3Rbxknz6SfR1fbMhbof9a1T0UfljTO0L7EdNZB+RDthIvniN5U3hK3DTEGFYL67BYIxozes3HE5uZydJHdYZZhjlM6xqTuLygvKyriA8AFUQ4u76x4NCdAIVEmpTRiOPQibSXEoZySRCEpq+rln8sZrgLSx1eeJWKZ0sMUpXcQj/njvDKEjZA12NfW3DL8TUMemPQoN5n9QeMZMmgQh6Dsp8hDQayUcZWuZU+GJ1O/aAK/NBk2QkFmDuCtwVrMp/nByqcD5H+Qu8bcsslTb0Hc02E+ZfxUmXzWcT/mQmrtI/Y1zUS2umTLTjtD/2u61SkDPgZ8DPgZ8+PgZ8DkgckDPgZ2XeYyHi5rOI5xHN4hh2SH4fp+AAA/vm7wAAESNO9Wm/uaLp+fMHbHzg4SCPms+RhlUjGjp53bN9ZP0drBbmexZJCz+wxDG4qSgeTbjVMbIq1IW/1b6fZk3kH4IErKtRDBXIZz/CrD6iY9hWSB0ekNE7vQ4aNbEovklnC8q/XKkhIDdoyvdT3J4x2BBHsMZZNJRblEr51lksZoZ7py5CSGRw5jmQaS1/pstDCDFoH26eoH7lKbPReDeHuajE7MhcD/H1x0cx/Uz4HIqxAAAAAAAs6CsSdUzolyUu+HkQ3cUfYCjjc6jkYOxdCC6yiO2nhMtVrO29+KKAKMId1ukYtXFun+N+8oqCNIs5Sgq+y77L2aE9VlQXaRTyFccjklgKz2CS13TSUvI+GY6u6AJzKEz7U+9nepKL5DpcRWyLF3NcsXLojKkUga1CRb9jrY69gpLJ7SoNFLVUt4XU45KDZ8soF2B9CRI2cehQhr60KlJoUZoaIZUCy3Ja4supKok5ix4E4Ev4kyTOxPVazK46cRv7D6NncQs9nDhetWXhGJPU8zmHr8Nus9778VQARAIfU8UnqXNRmpKUsjSKQKKvL8yx085ydhwfx2ANRgcvmpP1wt62t7+nI3DD7eBgc5Krf/hpEyPyznc/m9yMqtT/fEzjLsPSSYIc8HdO8HimxSDXbU1aYFL37o8uBlvr2dUoKK4VIYvw+oPzJPWCv2a7QPKzHYCaKVwXOM8wd4ua7KhNgQoGpZ9tkhYBdeTX6PExIVECFq/pFlfOCH6ad1giu3km9PWbJPQPhouEDIfDNVjpHbRTwBdAIiLEkxSao4XxYaZpHAEKfIhH5wiNQwTdmogc68oB1K5qCHkfPbIFBEABlXw4ocQl3kPnU79u0ut4G6cTZGz6JIo2kHvxMPqEzqOGdCJMAk18OBkgdVIuF2JhqZ7+v12NCqpA9uWp9Gf5tG7UnopE6GIQuq+FGaMRnLTKLkijvbc8k6L7zXTQPoSWbqhESWwthdcYkFn1Ev1hyjNnV8OsTyEvQV7AQ3CGTLknGtjkMJmqgflsGCXvdDiJa2EyW4OwjGZtLsiA31LwGb9Kgm0Sz/JUrVCUvh9wkcv+/pJc9B9plI4vZ7xcRqC9S8/piuyn//D88BCcdHLX7QAb5q+6FOjphwavaEfdXgQi5m6gD+S2KCOoVQD5MmKLHNHFB57wa58Lqi2ki6Kzk4bDAIjjipMvpWWxqICT0wrGxshpTWeLG2hwmCFHfK0IaHIq2YAxXqdtCLlQxk3824mDnvR8OIB8qolzAJEJ1jLMLbAC0FrFpX/T3iAFrmNxXiD3MwidUqDkwBiQ8p26mFLhw4nqEPt9VFlIBU+jfY/CJB+FH27Ec+jD5DUXLCsBwJd6zLllRqpCxg3Of6nQ2nhJwIthO5oSa97EJ1E3iC1RiJeual3yvdPdkG28Cg0VyCjrdg2jU3CrsZwGfpWdg+XQFZUt8UOgoi1lcWW5E8pSwjmkkE+7r/+gQkMcJY1v9TQoib9QupwikmujccHF+vqMabJFzflI0V9IBXSW9dEG0vX0PX52cWtKRXXbExF7zviB91x3DovB6PRwPQ5PlJAu1Y7sFNghO8y/XsVl/weoKulOYsdvtO1no3uip7v20+La0hMKKmfIZKSCvj1uYTU42HgKpkjam8sp6v8Ai21wlVrbiuUVFG9u1XHTCbkgra5UZQi0/iFL3XgPGwVjVGD4S0E2fkb7ix7WNQvtFnFbUkqDHKrjf5ZhEDiLrMeMb0iI0eByLn4yHiGKiC96kr2A7iFvfZhmDYajROM8gtvALNyc+z988AAAAAB32lM1YeWt/gw2eZKQ1001R5jx1LnAGjc97gvgT0yzDT0fYCeOHe/y9b3sCXaoAFw9U9y+HCUWdVzNmaHFCW3TE1HEDhy6P0O7IJAUi7skkH80k/i2Haz20tD+AIo4Vu4AJ96GFmyjnlzwwkT+LDI7YFW+ixgwkdMc/VsKvYl8PCGEnZhzmlsaPZBJyKhNi5ghBA60CC4XEPm/Cd6nnnhTzNOgkm2HHUyiIQuspu04z/7BcmE0gFLvGDPZP25nFb/ODWvhZVhgGNGSzxZv8qZX08tIFKY3fEEbGfjEkhf227CDNQlSSreDsnqEVGdNutxPdu37nkI+y6oDQ1HfYVz3TzEJMy9Ho0LepsNSrYBT8FNg4cJd7ZCewCE1hdZRSJouFIpyDT8WigV7Xp9OYYUn669fhEsL+sKczocHVs2xJs1NzGSlpdjLA5ndSlgCcnM5O4lfolMMiHO6JtLveLzgUIsejykFTmzg9TNWgCSBTmfQTYFOzOiePviLzZySgXopZEX1wY6BhL45zr3582GOSf6XXpjAewzSftbjzLcmbLw3WxJizdYXsNBzuRXjzUpXeaqAViSZ/qA/V3jSoV0He1nk/T19xL/Jeu8OkerbIMeZ1j5EmkaxT1kYN7DZ/nCoGFSjHodfJqrCBWz8y1N8TiiI3Lag9+Afv+awKg8t3uli0ngJ4EJSilKvXRUWcNOTAyqYizUXsNpXl8NlUmMhn4mQHVpSLQmzmLTPfqvrhJsVsO+7PLTDSP599muu+yMA0lQDrAiu8fDndoVDrXtvVh6zJKeOfK6yC2E8irdGbRAAAAAAXICsFFLTQVt5kbf/QDvlyjwqhYPIBhnGUg4yjiFqonBWWo8UTY2yq0REyexc0JVGIAyCOIojDaYuxTsOk6/y/oAFp7WdQOsgAAAAPi286/zP3LZ5p/7iBgBBWaftvwJgiK9vO9wG26PCuHd6/xxMI5J6pwHFXDO61NuKR4lKZlej8sQe/e2DN67vShfiOX9xQT9QNKCW+9ff1TNroV/Hmik2hlte8xiBBgcUrhcqM3sIVK3ch9eUqgA9QDmjwQ00fqJFDSKiPAuuVFjziiU0aAz4WS10tcYHrDZfYHcXwr1dHM7+SJYuvMpo9sRZS8ROZsLfodXeqMn17A8H9QXAgcLzc5X/zMoOj2Fa4Dh8QTKL87atoVTzldEwnT9FPicJw0fQCtniHdcxMg4dhvzRu5rdX4AanVasAAAAAdZZB/EsYwBgyxE2nwY5ITZ44O7QurfYVS2G7QyNtoZjPfyDbeK4r4roaV6QEI9V/0404k2CfMViJV1ivxBSD6pxzP9TKTeFZ/2YV+LTWDh7vi8fDTpsHdGdutOF3faev9FAq5fhpEC3fa+SrJVVVskXkXOISed5zRGFJV9mqBjkhb+fY1B8EpH0CQat9TsCnTVI6KTXiWFiJ3NfapFRxupSDzgNSpM+ODl79u+xUZyfmhYCVO9P3GkBFgMr98j+eDsK3EU917u+dyJhopi/bpeYGtjtjgp/VHEbxtfZX05SYobIK8FMJgpmguKmb3HETCKxtC5T7TkTRKTznqTiLaOlphFcUWXaMUAbmhozsWZNG5ph6k2DVwn5pl9ZCOQCphk0NOTGCX6bGnELqISAAAAiipJHAKxhtYysAsP5AAAAAH9J6V3P8aA0045xd2ySYBLDIHyfi+eGen5CTJam3QDqPM8GBFasEOYTMwTa2z1K4iQvEXxgFDOoIS6WqpLyO7rKoJk3FZM2LbHAjQiLUOz+4CGWHkox1xn8v6o/v9bT5HWsLZckhy5rcsRfZsVsdFAmAKiMwO64w2AAAAA6kgpMJ3iwxYuQrt9+NHRXPXiY3ucrCXaM8vkTXDTmw4sPqKbk2mjzjg9S7gZecExDmPpnO5OkzyUu4JpwrUbuFYcguvM90Tvo/5l7CnCxYbQdN1QfCXnEF/QkAADNSyAAAABbtNGnfEVyMOsgo1G21H7CQAIe6nAX+QZ8ggtU3txlaevEEusKGA4NAHtlSk5T2cO3jaqFzUy9I2rce/MCWfTPNq85wgsvVw/13H561iH4x5gkwNMFZMnJJNwYHGdSpDD5tFOVwEh4YKF5IcURHtLsELpfd+JEljiG4xLubj7449N5+yE3Yc65LdA+5BGLyxnMytbMvNdbabDPZJqE4vzqLSeD1wo4ydYm1lGdKusWreoZyPCvblfpa0YhvbL8ccQuYgt/vMfjsd4FZDiPrMWv3pPjnkcQOrbI+vtRZh/2ns8Mn9gPYIfSiiTBp0/1TJH9ORvTi2rdCKzsiuVPZ9QFi+swPXtjaaEloy2fPsRdd39Bqe0+EsWLc+WLleh/07yWHWeocYVGIOoS1RrsW0mYeZ5aqQvqoY16pm5RSQpNNpEyfbeJ9yBFq8txakTtq7l64YQ6DxO/FtRlMDMc6ZPlBAMPGiPI3Q5iTfgqDf4g/MZ9dO/MfiTTPnILu+CvLOndqDWo+mKalC2GYLildb+GPmX1VSnr49BXfXE32XcGDU8Cu3N+FOlqk+PejKGChTf36fY1ZgWMxcvVghgDrGZQqWQwSqpefy+biYBk5Gxn1/goPnIJwGyd+Vrtxx+aTM3AcjlMmUkhVBwCBTCOQKj8uY1VZQTAUW4xCnMJaVkuH5CrwmGbQ1OydhEJ4LT27xW/3F7G2y1ue1J8qF+u++ERfsixGYWlwkUCOefvDkpPwhJgfHKM91SUDzKhyfFnDESwit/cRNALD2Y7O0KvHQtIqNTNkLRfmAAAAAF6GTNmO6/yP1hiE6iuLDcVFH0D5S1woGhopas1cwgKySQumTVl9t9Z7uukvwvpMStmBRnkS7R6h3FOBvtBecyX5dsgv3pu5oSR6WSSF7UU6QmU9jOXqgoZfm4nNGm1Uxq2V8I4aPM6p3l132SfOlpQ3IujGjXpl1aMd1cnO6O1fiGVTP6/mlZWTJLBbXDX5xaO3K6pbdHu/Rxry0ql/b2VOP2M3flh3tGZLDrrMTQjDCrA/9/21vQvicpgy5HiZNqI5ikhizqirfHYuprMvMs1pOLmFPsCteNvkwi3p93SnC9b7FIRiJQ9CZLtGisa43TTnTeBjPhXBqbaRV55YJ9CO5cuWmv+uttvDDlPg/xqW3a6Fp/BF8Sg7i/BxfGzCqxr5+CMUqbYuxJt0JFP1fqIAQiKbw8MYIBc/nBXRm6ZXrxX4S3yW8f96dpMqvck2PFq10JTSEWxJMAlVsMW3FFeGGChzUPeAiIIy4x6oF5LGz0j+hwTEUR5yjlVa10Tv5oTMEHnJD0zo7tP5RXBCD849HGzo4Z9YxslfqWN0Z9xRQGdUiUC/nZapmyJEQOtMaUSIZVkSVnmN4ZL0A5W/jqng/0U5WMWRCXl+RchDMY3NqSHzZ9tW8dDFl4Bee9Lxewn66I0ODeg0xo2aIBYOPc8V64A90iW2K2ql92hXHGVBHwhFFj4VDolExGYLpaLFbCDKPcbe+u2U9vtArn0Tvz40I1aYFnbNjyVdrNuf7WTXFlSSK+xMFATtudJmVN8eU8ArkYfOp17AR0i1UVqaYHwZ1tWjs0dk+g03H+2JcrWleoeLFonpzzYKJiVWpBe4WjhblMJSxWjS+tVgI2LaObuJe35FrUnydbXODqyTZe7729csvGMoy6hQZ/OMSoiojEsrF5fPldUC2PrPEJghf/9KYgBcEVAzXl/COGYnfwjsQNVhvSe3msuaC4n8aGkkTn3R3G2jldQ71qAAAAAWVtdNQmr6cbgfkUjgMoUZ0qkVKjDj9mPgiYzghLo/ZnEATwAAG8Xqw/FngcR8Z9uUXEwhZG3GDvxbb6IOG5VD37uz9cZ4xbXdV14dPN9qJ4bXPJt7Mt2NsBM0Vh+T8ReI4Y5z+Bl/Gemf+pu4z38lVIKS+jgAAAHcshvoN4njftes+JWC4ANVd2iko2H+XDhqHRsIOTRTr8dbYjDX6LaVv/2oHXiLy1a6MvYX+eiAQxmZKA/cu/ndjtaJ7LIG7G14o95amH1XiVbmuupDahEhEc2K4JvzLmPBbJK0KroUGP4jXDppic0JUwf0Sg2SFbPKXBs3OZd776OC8B7+0uW2K2kkaoSffYlTug4Ca+8gj3okCQhsR1hPGBBTvX7WzRZxmEwvVLf74KHTZbo1OnDrLADNyDmVcG0x/eIgLuoMBc/u4zjg/er0W1Vcl5h9Dj72RRyD3zqcjBgYGifAAAAAZqtFrOxnEQittefWQ3YFiKjA6tg1Vh62bi4GJCxCKsgPS4pfwkkYhrkv0G+9H+p2vV1P5S0cjzL8t9aFE8vYYTX8hyF5XfiKWw1hyfHLTZKlDF4/IaUFg6Aj+0M4JONy0G427+cjIu8/Rt7U9INcB7sbhQ2EXJvBPQgZdZv3pVHnuqbjJrUjOaups6BvSgu36RgAr6PDrGFSSq5HaFlUZf0DeCW5ev+Tda7W0oAp4cIsc+CrEzCwXMow35OGfxbjD7B9JFiundsS8L1/Wrk0N9oKtaD7RnkvavCK3ImNbgButJDMcxYfpzeMx5kzJvQPvVAkrQ1ZrzSV36FXcTJKEpdPX0ps/k0BptnYdRzW+fTktCBZ29Va9T6Wm9pqTC6k5RxzXTCAFCvXeU6ngog6HiYUCj5T6laYrvA+x0zTkgsTWf+5fvrH9R3akdcF9Tjfos9WCSRo0rJzBqD9ouPjo9f696x9UQxtbWXfeJAkugfWSJmVUcZbSZSJ23/vMxSvgOXlIh7sQR9TUBLGMrNlhXjM5DiBmePAMzlJrUmhPrE2WwToYsPGGRgtxSxVQVVNBrs4+SLCT6f0JpuyLLwvd/WKU/+rQJk6QXb6C3ebT3nCS0UPFfYS+GWFn9PUlbA3ShhyInQghXf9fYzVf+2YUXambI8UgRcWZEF+a2jpKmiCXYLVa/wNqzpP71lvVIc4pvGopw4ooSO7lDZFLfOdw1tXYCKdXzq0veL0j1KdY1rakb2G1/O/df/W2Ve2Wu0nIlkX2lBDfmcy7I/p02tXUrjwjZagh5KrzHTUdpAkuCtuM1SWFElGYyT8MSQDzjCmmHBslbq4H/LphBwwsfh2t4Yyz2ScnHkRT5PP6+1UZV/UEpXwtQOIGivsyrzE8uAUYSCcx6JHele6zgqRjBBUMKfnXvc+b1EtxxvmvlvEzYG0oY75/zXx/f28MM1Y+i61d+DTh/+X7gFo/BBAg+VY1zQVM55kAPVIRY6KIz4/voFNpou4pwFmXdRXdgSL56uhhwhFponijenuWYJrA9ScjNN3MPzCe51/X/r/DYGB4DVO4CUFrF+jnfjKof3We6qwGz6u5gINe04OqvMU4SIeMKaKd4lCaB4Lext+KE5zTred8fP6IUuwZp+WCSAOLK4zuq9qPiPR0cAwtKdi7aW0cjLaTL+8Lzr8Sr1x0rA3g5zLqejK5K+3tpOoI2zn/6btoUCENmzCSnu1TKwK2LvcUFPMV+04fZICxjsdtfEv9uk4a1pwd/pYVBB87NBJ2Xce6TNBy78Xp/3SW+luiScqfDmmtoahcmmsshR3V+xdjQw6InhBS0ThCxU7OHGOWpu7d4tn/w4pMG+15rrYcSnVZgNLl65dv5C30TdMW/fs6loqT56N1bUDQxXAZzZPleQDRyE0cWB3BMXxyr8kZEYwy6YzIn2HCxeeNkHZ+65ngU7qe/IoW76HgmHoYU6dh2iHKSiu/LzQUXPyfbwJO4v0np9nhYh/15mX0kh4OY93h9JdQwDui2Hz7EkAGR+uxZMeJiopz5wDWr0XwveG9+QofDT/n2JD1Qv4UcWvmUqb3PM+QoU+Nl7tCD/+Qg14jhcNI3duL4PUFPW7EB2nNpaN9EEAlYbHL8KJ11y3KdP2Tuw2oHn5fyh9SLbMsywO4mzGG6uhl4qdRRXFS4d+y1bf+ntSDJ7WmyOhjYOPaOQFXVdcWkXlR6evP+aGBvlWMyjV9r6TfKEJNZaoD/fPEMyFGt5Ci2AgAd2snwdAdhJYMT5a16FZi4Ydta8T30edGcr7+zujBfeAkhpHn7mZD6ETtWtXGn/mOuD21u9hWA8w8mihfa138I8AWPc6Wlwfn8hNZH953Xkey3DeVkm+6P18WGAobzS6bw0aiHELWQq4FgAP6E/w3VgOa+ja2OYZo8goaEhfz9xCOkfDhBWmTQxcIZgJxb7Y7Zi655Os2JGF5KvJDfN/X630aKvxJLdJrCeqiBUqkV7tb+T9ROKmBPE58zFYAuKkpm36g6qCnB7fr5zgWJFclbUVlZf7ilZ3mmfc/T2ULQqi4I0eDv2PHdFYMhuL7LqUncG/BElvUwm8LpiO3lipo1yPJJMLS61tW7p3mG0/404UE44lqzkzne8XvNZj31G97le1IXwhnLEXH4HllyKiUQhZeXexAsNOdJcOgcy9XA1lCeZRO/0ihUMc8s5ix07y+fHr3yDYba616fkOflD8XBLxzL8rYss4V88kBM/bLpBZaXcGP/9VN/RT0MZ/T/JQWvct8jsfU4aqlQgP70k9gUvfolFyTSyrje9k9Cjn7hHXjW7hE49mUQHPTiNlPZ9OnVk53ioOUX4FVAZbRlW/RPg1ilkvdcHEb1WGQXtaSqRnilnKfP4Mg1a4bQpR/fVdf1mF8WspjraM9KV6oukmavf1oxLp1Zz47FT9Aj50jzk52elZ9G5z3UMTGpzfuRaM9aUbEB9BEtFB47+Onc9/cS4tPvjn5yZucEe0e8JysA6NUbwkQE1cDB9xVGEp3wrTJD9dtGxV65IeWWuHEY8e3nJDN+ZxfCZjSKZarhwXasKA3mlY9v7tnDhpWcy1Ix5+4rWgqZjkH1ULJaeW0QzU/bJsBQJW7C9nH6JoPL1bmygwognx6zmVICGS+tA0lrVpzXPZ5NCgzGio2y3pahqBs18kh/AUxf+MAXd3bATyiTmXw8G1knevXrD/aYdNOT1bJG6/FTvLbGIBegYous4HX2UhAbLuJobGEIdbRw+MIuSbYJZUbyEaLZjD4LZfW69GGJcCaOQVWOCgTTpCAsUB5aYczhgFYqqiYerxs1Svjt6PwPehNxvR0zteS+0Wl67qHMqNz/Bk2x6A+zrX/8PElj+OB+iRXLFx7BnG6ShT5KlJ9LpbzUGU8rCreGCZz21N7F9bmTDRHwJLwNOP1+VMIcSaJlQ1iL55vNK+nsrt7UBmLJMv8gP4638BBkWMLiEVa6Ft1JiG3c1Xe0OS5NLmxn3oFmc0kSlm3rKU9dGhJTWafZHNs4Xzgw/UXGLAye0dZAuJHGhX8oUE/uQ/kaSIafcFu5Dl9k8zmMhXrge8uwejPils1ozfAk1aU3QyZp6kNk1bQ6D0ghANYplc6cuEL/7ofkoXAGW53QOcnkKmWVLwzpn4pcomrUSrdBGlLD06J1Gbk0nt8jkm1+L49DFEL1KLsBmOcmi3w/q+B9ahVHzkKyWy/cp6DqHKYufGcrq7F0p+uHl1prY5YqUpLlSfB7T2nYWlfrKuLd9EVPo7KXHxTE3COeIK/MSH57wP1D3+SsYPYu1W0vgNct34chqz9mBO78GxqzmswlrEDxM7xEdrweN0jIHjKmptxWIj2TJfOgqWTXnkePyYqnNBNPArbeJswqfoy0yBz2hgaplknC6046yVibpJS0mv+2BUvkW3L8+YJp93IXbjD2RpsPGVUVf6xzqMHxJZM45aVhpBIi4MVF5MlUpUAaBF8irmlNjnsIOrB7V+luME440QgLP8jC9Td+D05cOjqdB0/U32fzHTxNFRJACuUtG6LUokDAHbbO5TY36LSbIInom0X4j+QN9ccWtd+yyj2msXHhdeblyzi4rgtGCZlLEk+YmgFXGUQEa4FWR/3C8QxXAuu5/jVo0XTGezlvRTrg+6hRSFSHlxPGCKHTgJlEUt0Q+IdNnAVqnR3BTAQCyCUYOHbxio5W4m/WPqj0U1B+n9eU6kTybTNrF0H/j+vwiuUgCyWYUSdveuVAeAdRvs/Lkzk1naAwX6bailXRRDJRfCVn63XIbePgxx6vVfHgH6XcGJ5t5pmmHtep+xQSXsOzbaLikAP/lp3jrpNTEj99B3OSWHBdEOogeDyrxVGuqXWPh5hpHT3MhE9z3ue0SSOS2LM1HbmI5HVoae16GQZpf1WqluuKnSbZkbtVk3pgj3FknyxKeCOds30vemQcdfk3Bxf9FESjY0OZRCKb0x7oSqgD5Ien7ijIvXXhdjNMo/UL272yUZoGqRY2NpYLVTGMzf/mOwU6c+7nSQPd4wr0sKtI+6Rx8CuUQ7e6Q16vaVAbaYlAXQXIj0CMsGPFcVbQsTsz9B4LxuteaDNRFKQUJ1aGKCRhFtUSXNgKqaCkdsEkcLoOB8mVS/HLXerdaQUJ00gxY1RlzQMhUMbcWg71FE9ojXjtMRgqnhvxOhkms79ereRM1aeSqLQqguGXaP9CbLGBlsx6R3IYaRzONfZls9i1qNxjnwNDzqLcBLatelOD+Ij4zgE7TXYqzxECZ83ET1iFJkWJdjPNrxtSUII6wW7UIYg88jLGp/RE/0euO26cyuLrPVdh08/lXGZe/PoBAvRnQ49iRyO6PnJO4TZlmhBud72ekHqyWT/+RJtV5/yGotJ/HdBlXuXO8RXe9nAjwcZsjoJzg8BZSWGFy5fXMuwv3IjU68Ed8+uQnJj71rTDmNyoK5kk3hvwhYKO6W9Eno/RzuFZLXxinl8MzsnRAMdoTjeH57qaIjRCXt+Jg9vwkIfLceZ5ocKh3ScYg3M8EGkB1q0cds1t2manKi6qXhbJ04lntvEZ14TAY1dAAAAAADas6XgFMcnWhW66mZ5k3taYo8AxFKWp2y1OtityraBCPzxxSPgQlAs6HMwLlDoXQhI/wmUkmwBaYRUX6drrPQ0+OVZ1z2jmSguDTXgS4j6iP75w/zyGtdnl9pFLa+s30oPIRay+aYF3pzbWIkEeB0QvqhcwQ/keW/Rj4bOqQ8VJpW/Nv08QFzA2aDWhKUoKUxgjg/KUwI3ImNRiZUn3b6KrR2yZlwLt7aen2kgDhKQMwbpo5eYwV/u71CYBYEyaf4tAUMGRfuS1FYP8SGmPSHYk0z+z2H4fpli4LPCgxn1EbzBwMQWQajEfEHDos3pslbg1BMQDAfY1vnfiMcEmhNwAvQ3AGYGwt0XeJEFjyEJU/tSl6MJgJgvyl2xWDr0XDfNEuNJIvOg91eKF4EMg3WQJRYpEqTm0Na1EPwiUFbZ48C+fIMuTT19sShJVpaMw2jqO5cR9H8BEbmWjcV1dzqGU69jXLDIh0eHtSTSAVfDjUKc4YctCOjZBr14RKOrqSStKHmQ2cKWAsdD+EUXJfm8nQztbiAfgncMqPTA/CCW0uRafsqlmXI3UNnX9rcxhAKyafRUXuB/foafXkPnm3v9fT2iIT56qAr9c1NYYH3kwXUFjreq/iNQ+VQomowYquWSVqeqld9NQx2wyPUIw93ZPrnWguq4Hlb3uxcUhK/T6hfPoARFCvfPkof8RS6I6I2MX+Hb+qgdvnfpY2I/DSAKmpPf+BdxWygOPXyQr3gRwW23iWCdqeAm0ufAomffC/XE/mCIsnEOkEpGmfMk8Pa9OUfFegizsbbjUs72uXKsWPllZal3ruu5wC9bvB18q/ZIOBKjgvpELj6uWQz9kZaA4wsIF7eLQ0Axtxl3wjVbJmn2SoqrvlejqVKkoNGftl88XHz/X7YqX9Ardw10YArfiHkXm5bvj1zM40F//GlX81ukvMmfzbc2p+r1Ff6eCUAruTczDLRQF5UTl6rsa+lrBJdj2bQ2zFWj845nsTSSzAEYmBkQXZ157mw1t14QRQXnBP1Fdw//fQWOeLBvknIYrQ1IPz/rjkpypYA4NuqKoYqmKlNhi8cFc72GrlbPOlD790Fl/Gycx4ib617s0TJBbWhRxQDsJcgaVCbFPINhaxeX+VVFREmvNqPy0/s5vzd2JV2cY8KAiWAEoGL86d/D9j2dcg1tOMiTADfPRAJFHbf/JNBnqYQvY4ZwiaR6vgaQJz3MSAicjkCP216OV6fLjm8VcdCf3FvPL7VK23/dR6rWv0b7zB5DZ50EmfnUccQ0uGeT9s9lkxq2faVEvqspOCIrROzpwMiJ3jpMAhPjRPV7cX+lHNg2zHsCodjdo65ekJiYIelQgFxP43RIGiIEvw5AtJgXfqBIeS8CTs8PiN51mc2v2OsJjNrEqpsbB4DPvsPWH5Y2/64XhmaJqiH9MDOku7GeLThPx9HflvWpz56m/blazAAMGbq23HuIOWPed4PI2C1s8yTH0KY+0z0Nnqodzo2tDFL2Q+lJ+nNg8VXrRHSLvwTFvm8pD4Ir0r8Qw1Elrxq7D1Gxb94YEIrOOoAyhLdIPdglMLg3/AC6IDbu8Rw/otsrX8rXE1G/cfXOU5fM+Es72muZl4QwrDYJtuA4GM26PJuiv/lV/Na4pvnlg7J4ByP5c8bbLiSP4nHZAa/MFJvKqNU0KdthxD0eK+KKnEmzr2M2vde66tRmvV/5c94k3N2z27OfbKaliW+4VASSae4hScdlM8Q0MWexFa/LzhXRCeGh4bj3Nl5Z+118kn/x2Adv/U7pfPOyCgqpB+CO9fXUbUT/+DRuXawOJtVXZSdkRnRQf3Hp3G9QsQWDYjileboNJ6j+I/el4hslYgAiP9FG8MQI8mDFCnLqtlz4dbmbx6gxIg4pHo10xE0654OSfqffj84QxnSrQeL2BrIOdAErFrxG8CmGnZTHkIZJpacv8T9wdjtn+QzrLKCR7ptxtudhJBxjBoQPfMlohwT9Dk44FSc179/c6X/t/7eiBjHn0twb/5wDNZk+oMMebYBnrJO9c6Lg81mFoZvKz0cegyzX/q4MtC9Rz7FmswVZlAzoXs+xIc86NIjo4ZYWce4sS1JnEC1eAmCU1DbUAS80Zrxch9v8jHJki60IUNOq+rqendi+lmxCbL9gIVlxl8sqxNomR29YexQ8m/OWXSrRnNzWP+Wx8/3av0LoOKqbZLslpcwgPl+l7bQceauITcMYT/zjhdi3L/zHXaeZSypActAMhvqjFmyqOZdadj22nmUebr7IaQI8PgpJsGK7np7FgQx4Pou1XE3PIKnsU6lNaPMZoNUlvwYSiTRmFbmqayHVd84rjWN7jUHeFqiCynmJXLOjS3ZYBe5j77cWQQI7KH/C7gsGSQOeVECb2ud12xXAz8yl6qk72vDNvgfG359Y1fNo+NiU9Whozwb/g6ne+19BIcNYypbP1WO7H1voSXqAS4Uy6kQwjtl9OmMA+ggMUIvzVyj0rK6HucxqQ9UugcUdIjCLlbvxBOi2A6X7UJ3RWsFx0cHTaS9f//wmSBpuvm1IV6v2xRh1HL00lHdYHS/tjjUrvUl2b0YSZ/RsgGnOW7t1XfU2Bfc6F50d+dpvkfaG9c1D4az901Gk8vJf6jGI7+4Ww3RV6FICK3s0WxUboHJ5aoS5RKrnIRFJtu3w8Jdkdzpr7xt3y/3Qw7c2Ke7AVseDh2xK/1xgO7huO+HW/NWA9n9Nyhr5tbXz82TpLuCwNK42mqOFMIgkqeC5tv8rOsClk4L0QRIbiuXLIZFkTh8nnNe80OHVFhtK3ne571R5gyDf3J6oItgz8Wbj7WK7IICq99ySGzIISEmVkZD9aCrtNeTVbqT26KboojYSn9dx8x5XYiKpNSpmkuPhOJOXG0EGYG5mEhG0jFE3x7UqGzYrB1L/CsN9yrOfUso7EtivSFiiT2bnZ++DS0zUR2/hUlZ9UbEVc6EqdQx5jzdjZZ5mf3fyhTSNxeJ8vbVvykoKdJYxfcZcYxSP5vhS00kFQtiGsdoSG2B5MvoGGDr6Z3lO3Ee9C1A5946Lvqvst0M6E1xJ9XTWTHgEVuL24vKaeI0qjBNrEP+K9xgKRlFF0mY/3nQSS3XzNIquaPKKJG8bXcfmdOOVxpMcVDebcMPBSismaLT8oahxup+Qo2oNQYpgSyny65N2CJq67+bKsM9SwYE+H586DHMDbgVFpOdVKnX7lFP1fUkbJUUT6eilpcgLU5Kf0cldbGKJgmfMbOy55AHAMd8vPhmfA3CPA8awteO+7OemBovWJH2mAqIT8AJICQGzyX1y+3WBF6efdNb9F3Ad9OQAdFOtK6wuoVpXaKAe1FWhiuGHUINk9h5RX226KZKabzeXMrkcRRrQsSEBfgwhX8d50yB0PBIAAAgBD/x+dOaDOSUHdNgfgjkMRY03twfTTaiHPikqL34zPFs+eZC5K9vRX2lDkJyeCjNecsLMn7HL68qMEXBa1xXYRGT7M5KwqW6nOX73Qk2jruBTm0UwRIbeHUPIrxBSJbEypTMAElMZTruCUNk35A8l7Q3MVQNBtDPqDnjfJc9uGIHzVhW2+F1uS8cSL82NY+CO1plpI2wVsMytrvC0J+mwQ6pAOjSA4ltb+DO1ZV/gs/6kMpeyCUVyKFMKrAoW88iVHUmq5I3LsJCfr4TTlUS96xuvXQ93X9HIUVE1QJYeMY+UmLMoTMI5wWlsAFxjFkBUZI0MzBAN6YkYRvceWKZykYcfQdwKXjFO5clBl/ex2OSgnYdC41sBRxFe5XrBN2FuDK8GSB4A42wAAr+wNxwjsljNjbpunhixB//0VPMzhKKZjBjWFtbLfI1rjB/4FYN+H/YHreHHo6FxPM2lNy/Ff9p8/bN1CCJZxdL7cgDGVQAFfiGLb7jrCviMWgwRK9uYmQYsjxEsy1SzUnFp9oW7Xv44X14eiq/aQuowN6MAVglqWXcM+ppLONdEiRWytXxLXaXVCwNigPVszCCSV5XNYgC/amVibKPkGLTbzNDz1AVAAA2WA8W3uR1WNMABYyBi/K5wy5cydL5Gin67DWuw/EsqA4tL6dGj4IJN0FYEb6WUPm7Li1sANvGdA3z+NRaM9/T2iaRXWZC5+C2nP22389wsUkJqMxHWqEXgapdjKEdsihpOR9R07QS7Le7k/ywvN4NFDOhgd/ACYAZBSuKr+UO5/s+T2CDMUVfY/+KKAuI99SWR8//GfxLKmUb0Od3b4aDDlYD6288Yt+EvcGzSh/sk0JRTo+loOMe/PL70zzrR8XH2yNXxTi4lOXGqPeyUfqvYNCNbU397ibl123zvD+jeB3vHCgiDs+D+ZjlJSpA8efhoF4xD419RkL2TfYjz0a2n/pOhd9S9MHiHphstLvLI0Npw9llu+vNi4Dy8mmeI3ONAARlT7wuqXBXtFKLw0tcAPxc69AfNe1yRtakFbJlYGXfTvcMd5Nr+UOiNas7+zVui4d5oNxLF4FJ9PghvBBiQTeOJJSoUCGaj5ijDXoo+Tq2Cy73kVzulJ6JJPWpYVcdvnUdoU7lcdhe93xI0vKqmDulDCawh1fEe7tjUfBfH3zzwdiTVqRETfsVHrI9nlpF8+YtUM12YU4Z3mVgGcQeizwcm0ggGKFLWAdK9gJZayESRM1RJQhI95RM0c5sA/sJB7jdxoDsd3oAwnwysfH1Q50xR0+m/kkzp5KdbPiQ9R81bf+BqEBzD0Fd30sDl+4WZy89JbruUWKLPBDccHiiF7BznOesjeEqGG5r7LgGlTQsm313sdnE+oEQUY4jZzKMHXhR/8ej/EGj7JGTvD+jcTkxwD0cRniUIlvqda29JvHNL1igAuXYdN7HbFnrYPl9FVYooflz6OyfCf59Jzl9/yOqQoPVhW2sc5LtmVNTgJaR8lwiJx0GoOowhySm4gMkAY5AboTPOe7sjaLuJcjdKYiZXFmDD+YzTjXDxgpGXdBzTHbrbx755aU09vA5pYrrkavgivqLT71yHHgGw/wVQDpMGVCKi6XHmVqctKaxVoKpVhrODV1Xusu9Kh1zYXuDs9QO6YUO9aHlasq7r3h7r7b+DJhN4U0fqz8TKCK8aHSVbzKHDt+wgSOqHiYL+DCezc7wFtOHDC5RkAFMNe8pgjc5hZpLVDHuTZiMEvOSu06ixacsUjN0PX4spABaXaBx4+0hzhl7762vDO9KfamzfDy0PhsNNd4Bib5rcU3+l1Yf8rbipocLnNWPq8I5KBAbYw1OIojVNLA52/AB8yYnNAWYJZduJ2qUkafTjGhP+A3Z2Km38bv4xJRhIQPRiH+c6fAYsI1UvCNX5jFuENJkoonAqeLzwLmImuC9U5pYjSxgamUXUck7aV/cjIF2Gm3mTuDW6PpNOxUz3fEPvaqLPaf7WYPevZlzWx2qLoO/BTPAA+AYN21SRqQVIAvhLADT6C4uAhWoVQWYtgjXAxyZsDD7dGwjOwHEpAfDDCszSPO3V1RSUANBqWrogszFcvUByARFKEKAxwsMPx8dLjomkdAgk1M7JvJt2BuhJo671Js3qsKSKrKMj4+nFvRDTp9fapWuDekjiJo822+ieH9MBAhPBGZybJtcPKoKdq7nYm51BVpDoyNyDif6RS4q7s39TTb05qvYVk1qlpZ9XWwAcQRKh6DAWmnvm5qVevjZFrbIAvmK6uSjxpyRpyAXtk6/UIaUpOnCGobVSD5zVT0O2C2EX7E/TbTrZu6EfT9iHeSi6XbdmHMeWyzQK/ITmOcOeUihfvl21eMgvMpMrLpXaC3b2RlQBnMKThzQWEWPqJVe0I9v3py3tJVmzZD/AKzeloWV6ct96wUY5Dba8O2FUF6sZFBHN5VaqnfMlSpmr6Jqthh+8tU/woP+/bfUuVN78N8A1C0LMgp1FAoW4ykleAfeFrR9vAm90siSCfKnni+5AFpvlH1+GDX0egfhHN6iuvYq1H9/lvpfr3DTVJ8/DzEVxopZSY2iccKWUcKoBMcN3oWyln1nTa9x2AGxitdRt5rf8Wcbx9vBIbSRND0DMSVccYEbW/bJomGMsAr0C+6Tn/Wx8gaXS6DJlY5DkmmXMCav77PFkdWRg86gyC5Bhhfk+Q+O/cqCAmSK+Hfu85A65vfGk/pPOXWqym5p77KREcBleXo7qeBFL00nzgV31qUpyt3hf4JGifobOe0fojT3UTtVPeIvxV96yxrv/zfHp1hWi4PdzphknqbBR5DuZEFma2bADgATOx5678pwmzYDBAxiAYsHlNK95vVK7YgEYxoPGRj1Mpt2xK5pJlekuHNx0Kx/1zGPrghqkz7bQsfq1O3BhDHFDl3cyjK6btIIrBY3EzGE0Rvm5BfDgla/umAABPRUZZkHzsCEy58X9S1VqkEqUOjqAlzWRewL5jTj/1nVWvd0OQ14W7TCbw+sA7aoDMSei/Efs+GtjPY5ydCeno29ed3NovCD2gxzk5liWZzVV1wqi8EjX7pKZ+7HGYQ5KPqip7ITkwKqtCJ/hgxTiqL6YH4U7LbIOoDWGr/cYzi1J7lGtbt5Ksi5ludZLo+7/ruTfbHomw8moi6Dz7a5LcAWclDaVxMSursXD66TC75CTTA613F58wOrSzvrkNhXad/PzLDz/v6KT/qn5WU03vRzOjhgWQwY6w0QWQc2FngRgg1DPWWVIz6+BX1IYGcRS38xlEo1aNMtEyIoNLS7KihmdJeaCgNWlMTqpRRyudWfuoH8b1C8oV383sDWzYlJ3fl0726ZLWt1hNuIvaIZaZWuFOED+1ncJ20dXcTEG2kcf+xs7aaUquXuIlo9Zguf6JOCznOHdmPnDZp6IzJ+qTsAGVlYc/eC56fNk69KHpjPfTNw/TGDUvHuK14Rh5sfJkEULzxXBBhnDSYKLqzHDiLeNuEajfiflYldV9PqcUl95w8DDcrXTVLJ+GvW15UJWZ4jTByXTYXQxVm9A1vsmxW6591XA+QJt3479LPDpHf57hbO2U0pZzU0EY+aL1MzMtTPext+ID5bIbIIEJ9/eDDX/pNKkqV29WmzVs6kX0oTzSeDhCt5jxSAaS3qgizTYiyW/l4khB5/T2LS9KnjHtNnQDaAe4A0CtF0QN7Q/d6FNVw4Q5r3ZgCDoAObkUcjhnNwYPnue3+JPgUK12tPBjkIiilETMGZArSVQ71ScjH0Bq+2i2Ecm+f+J4ocOciCPMBA7huPtOG72agx4z09GPKCCOZN1Yx0W19cAIJHSI6FRxPSAgFmpBHxGDiX14gvWlpAqKoEVCfSALfX4ORFGDZsBdXpg8+dvupsaSiHkYdTOk/gH/VVsOZ6ExcAecJS2VSaH1pvt+qIzVRXmX9TMx+Cc09LoA3bySNwENmpSawwIzFoIbL/M0DuREMYn+hGhB8zZVQBtbBT2oaQnkdX1kVQApF1f6Ku6zYQIP2V/Bkobol+4Y0s17wj3QdfdGXsDYlnHks42huSFYYACaGlosLMgY17/cBrXzjej9NBj59Ot/NNOQi7GQ0jpmtJjiIM3W4/8JSHu5QO7TzbpKc0kWoJ/ap4ZvKX/U6ocCukc4EUjuxn+AbGcP49f4FkWwyWiybyft8c4Z+Zv5nCdB+otB1pFFr7J72u1gCCyOrNb4YCL1XZEVJDVOBnMsARUo9acCSmVsoeYWm6e/6x+bN2gDLKdVgY/MpUs2O2UfNvb+1QzBJi4CNnuiGlRU5ep0u+cWR4DU8KmLQaAa3PWDxLdnxM6YBjdF5dUfXf+Vg6tAQPZkJeC+s73a/Dnv8FT/6OBXJ/5aiygJkI7ZGwCGySUZ5UCKgy0JgEPeyC0n0aR1h1hYXlk1fD+y8v4+/H0I/hB9l4JmnF1gznmO2me2H3FLGiEqzVeD6ByN8OXRmih5x+i8McgTiqPXybs0awCJN8DqKTxx+1fLbuC9nHniieomCz3NRXXKZUAwpfy5F4CaObNwlLRggAScVW4MGon2L8CKfGhC5/lota853G78p/HHR/x0AsutCX9TECtR5EiKdT9g6PpjBExbFfPKcoXfu0XBtC7XXOJDaWABqDJBDrRMgnvh2BU4bMLTPenpfbvSsALLuu8vubGvTxwTOfoWNl6xdc8v14Nnt6GQv+J+FL1yhtf0H/kOvcBZQd9LGWtuy6RHM+KAZYCBjdE4spFf0lRb8gl11vjSmlZ2rxfIclShFE8T998lydSGhiRiAGnfuM4w1w3RuU4QmP4JHbPgPlAJGReJ0MtEB1+sDrFWuSa5/ahfleQTqK//AslTsymL34DdCQCNUdwK3RqQsjUO7l0vFXBNJBJhfNiKEzvN9Bk3AAOlrplN41cfJpn8FhVKGbRZbeDUlDOplvI5H9jDdqTQXmBhS8WdwZJozgdbxDLl6IRZgdPVHP489utnMTsFADubC3eZIuCV2VvKShA7vgxWI4A8XfSEW8V28+PFaghwKLqQAxb++wuo0Ww3zk5nmecnrWxvCZnqBasAhg6S8kOQZa3b4tfN7Ib480+GTScmDaAdCSB+zPQguv6lHEJY8WdsXZ7Z8nui+w30gkY0Iv/gdhoGWVW4yK6BXNAtHZl3oIhWGD6DzI6QAUJDyc1SAFDg8RUutWsd/gxj+QAUSREcV2xjLoSxxz/sk1R5y7F9V7PLuZt1kmWcq10zuHDNMWXespe533ukXSFallYvXLIlRjd0dBSCzoEJNJzO9IalE7rjZzRdWoLVo3dkz+Dp2CPwsryyxbGEHN2xRFQQDUV1lqWm32fOVL1VHp0N5uE0Fdz6ZVmt57zlLkpozvceD3i0K3vVP02BMamOZhhHxVahAjUd0DvwaKd36X51dVeQRnFyzfzPWADc+MCfQuh1cxA+FYHqXf8+dqjbxbpyh4kcANZK0+RcZJpU09WuV2ito4DeLREBXdKZ/Z6INvkdVGeyV1gU+gF26LUUT94yt09SCZoNnFAnJ7UT88QLRDZ04PGDPrAqrpQ7jNZjCb+hLf6YonRyuZxXZtt9Zec1i+KfKXvcVPaLcKGTj0wbS3OUL0i4pDtMhn4Y5BFnCrWjbsi7qxG8eh8mhMx9KW5G0uwi0Zx5/1liR3zKRJLoB8fummXJdqvgPrNu/7ZMgzTfVkgNhFj3SzPWxf//9NWFvYfieHRTHTogacQ8hZH/US3+9VnsDRI644/zEFj5c3A+mZL0eDQnLoxSfuZbpxYsmpqATVULIKs01CR5cOpI/wvnmmzucBXUsA/ocyLcA4J1k6QuBDw0nMYEI+goiQ8NLJhj0kwaHk6xokQZkzGa4QTvjjQ8cduXppzGXI7yb/IOtjXXI+sZY9/X81rbu+t3R8kM5hjZZPAouQMWeZbK1R8dIjaAbxTQAi/7xBK6OeynGs8WTO2dS0dGDYnHnd/9mIdrhjXkjzJkyY2E/9Y1qPD4H8fEIQp6LxwQ4ePHSrvafC072eNb6n06EcRsywRzl+luqDOtGZLt2nMTl1pBp9LlW1ysrbotz0svbB+mWKQ4JrIwSnJD4a7bl2AStjQzB4Gn0d1q2GZO6DkP4E9aWBNr+YquLMCKVysuIstlAfJbaU1y5+Ek1b53T4M+3rF/QK7CgZb9V4ESXp3lGpYl3RhDViuqm3AkDzQHlk9N7zug5nvyYEci0UQv0IRWXr7HfDz+BRJTPa1wNxchF62x6vOAb7a7vKTQgtWTwGUjvhbW10ZLIikKo6lmk/KkMCkN5cMl3C58BFwVAP47Z38vlEFGhtjgHQ1+Ni7OUUO/FyyjBXScjmhNOSZ5fVCMc10iaWGKGiXimyqkswfJifXpTL870v4+Z/7IjcRu2lLBOpyXZqIyklLjtigZlRBP0rCTdR0SXkx2qvQGi1ocCZ7igzuekB2vlexCiVBrbetGSvic+xCdBTewieVevNZY/2FER2fr+yhxC/loeTwfYA/+CQdKEBimd21+hI/6Ea4kACpHBgx+p9tIU2EpCH5pjNqzvMXfD5n7NkSA8f0RAJ/EyTiPXNlv1cx/zlAMBiUzUkQdEZWddI7ptc49eUP2NwJiGMNznmkhOVizukgM0WgurfB4UBGLnYgN3SP7oxIAzv1D/tHaVK5SiCc75TDplDcIx2k/evAV79Vr6jku+eKdpU6Pam00Euv5i+ejCOPfC+UPzfhivA56j84EFHA4q/YTUj6cDXMnybClLUFv1u6eTE8nnmkatSHhGqRVQt0F3F5/k0823fg4qBJs7f6M+w/lWh0fESCNe+tFO7GqDWAo5TlXOShg/qZocP3FPG0WAibDXEy3ppZf1hWYXZOwlyjRdi2KgnrBOL+OTy8W3cxtRrEI8cy7+i1cpuu7tGqXYK42jk4Lz6dJlby8ySlKA3xr9GEkb2GBGF3KMbbNeAprsC2ZdaD+gVoQgljYwZJiMNuhlhloD0ZZ6zWlOYtuPtyC9XtlI+qXIGZdPbPqRSujqkQLHC1aVRggBNnyxZJsPLN7hqz4ssCiqEo4Od6/ZMgIM3uQdL3NOKxL6sBo4rbLdbpMNnfvxXDtbkhfoGPMpB5fs0MtXCxf4/pK/DDYu3y0PvF0GWzmaXYXTAUnArzDswmHCNtgVI69im9HxCK7cp0s4AAiPT9mu8/ZSyVSCYERDeqSIxKxEyQxEfmZFz2r70UnSbMZJOvi5N7VGgpUePVzRVNAEYZxub0FDns9oXtbsENi4SAvwjwoAK411XT3hTDkUZDxejWIPw4J2IVw2D0F5ivauMr7arUrHY+NPKV5zCHUMAVEn+s4OxyKmxpCUY7oah9RxF1VceEzh2YYNRC1+pOazGwEVDbFbYnrE4RFas9GgKDeK2Kdq9e63nxcbIycsKYB0eoHskSFp3nVP2h81Ff+QuH6TZu9BTiXNWrOBNpP6WsBZQxFd8KohWJqrIIHQPbCBaUa5DHzpy63Gl3RcNj3Tq+Xf+qgaROeugGw8i7TKcIUiMU0Fv4zOJqGR8APn63csDla6HiFj1aJ9vhCnwFQNeRrwlgDSHCjUBNIJSHGbXPjFhNCgxi5pkV85nQD+rzo+c/qUVnrW7kD6lRiAE5QbSC3nlwIEDkhSiLlXm3D6m89ActqoHUJ6kWFgTMCKThjUSLKyF/IOauoMZvHEedeksiXGDCgRKY2ZSj4FKwWydNcrs9FNTww1FuwXv6uKkwUgMRe1SCC+ZLoNmaFLe8+BnAt6GsuwplsHtuUiDJNP1aI6Adv4wYy1Z2d4fZjh8Oc15h6AifqDqh4Pk9yyRSXfTZEYTV5tEHZ8rijLtPw7NX6zp3bFxedhJx+aFYGSJW1SB8zO79K2XQ2qc9+FtYgtUlNRsUUCv7dq1Zl3/55zHQ9gVrrFOiQ1Au+LwpAkEqAenW8OQ1j5JICMD6D59FVLZZ2nqYKKHVrZiqLTKJhWawYftnWiddDNaD0dP393jnRNGuZmK3yPtD4VA85CoiqLTw8EjrVgolb1Dmq5uGxiY1g69hGa7IsmRaLIwEg2CK5iQjjt3AV2tdOOLK28BZ7ymrGT38JohDsea/277hMZYN6B+UJaSi/gVFcM7aCyD0jqFpnYp3NEcaKPL2tsIPuk4qC1qNvXW/m3UcYnlHUmT7SAklXRf8BXIAwlVRENUlNaKLlCRdWlug1CNNW7GSWCJqPrxZnHnYh56yY58zfn4kWhogythe4pr95pWXsR/CEuVIsFljqT3j+bLrK374tkouneSzbBWtq/tSiEihOlNNK7lgrL4LsHkr9lxpFct9n+8Wwv/UjCn5NnDj4WLYqjhwEZwPVjlc8ge0iVH5q7PmzYaRILanAp6Oj+GbJlL1Chiz8EraqSW8S/GWAzRiDmsJ2PMXnO1Ei/ePCAHuf0BrhFRg96XhvLHXHCnubIQR+t9cvNCBbUF364/YKiplvRjdzxaFLyaPKc36/cx2LamVdDr0Q6RQp5a72g2Anzi+zVfPSIZQRmG8ZjWFAzYAjIz9ZY7cgSWceMhW+qJWaCrcYkqrBLx0HdLV8KGpqpZT9798OOIB1Sydr0fj3lF/56Soh9DzVO8Ygfd08LT08yjyTcVlveZShKrQBWd+TjH5KBxPjmvMIsur109J2K4NS5HX/c+Xm1v2DbVQfeySgMpBUhWGyZYO8SsnHnTM8Zg/uBnvX73FEaJHT0F8QJCQdfmZ2onmv7TBpoFlav+PTCEumI6y1VMFaF6Asv7yg8O66U63M00bESNaOXSm9kxELGhsX7msBV2Nj2y/BU4I0TFrZuzHbhZMfnGm5qvan4C3qurQtHPmT7M94b/Gi0nLq+k7BAy0nTOtzzPrEnZ1YPY6QbYLC7pDyv946nzIu92afUllF/6fbbm4t+sp/FrwFINkVgWY8qfkywAdZvlar4xG+4QHr965BZuwSMoXz76uTabtD0b/hnIVxZpsNxPrVkZltELtm9kVjZwvwsw8EkgegBbIlWKhl4xLUHRVo/ozHiKrFXZyvRK3n+RTa7XjKD2Ft1E4KCT0MaT+9CpVfdZ1kZM6I+TWjR92e1CFCQL8a7qtI46Rtlyk5CfudGgzHoY3D4nLgKAuseZZ8BfcSj5nLU6v9eQx7iLxqmNPjrA2b5jZsyWfIc73egA+m9Rbr1w1Dn6fX2q4Fm6a+dMloYl5iOXnroR3G1HWrphfyn7h+acSMbRCXRT1VMgyteN2GWfiB8ekDqHN48J2GEn15ZfRej08KFYL+435j+TNkuI+xHenXtf53uiP+ECZ7FMPp6l3QmnDkTlI9FXB375wIkvRv/hI+n4QqW7lXXfvISbhRtUeMpAoeqHZ/6FP267NQx35uRnZrszJHxMWyTIcA5V/YHPf2ubCYWWo0/fJ2mes5xIxmle5arcHLOuTQSb7eNB463BqStOtZnsxkhySAOg265b7s61qTg4UNopYGw68NxW9VK9+03p3Hl43Kctp9W3KpXh7yc/rHVRCmKmyBfGeLBU2hSQT2UuFrkosxilma+1hKAXhnHgkaHIApCg+pBn2ug3PVxBK3wP+QXs7A1F6ckjHy09LNUt+keGki/UqoqY9WK7cqV2GuUlkwx1LTMgKWbLDvPmqPm2yPQz9xgDNG15Aix303/9I0kblbutQUVvmLAZZmuylk2+f1/c1Zcvzez0cO3nyp/7SQ0e4cEps+YaJdEA7ZufYfYajgma3eHRCF3IIrIXEHui2wc1ZI7XmJnTPuYJNrQ0F6GTryb5Q7ekW5XjKGQZWf96a4K9Fd1CM3eKY8SBcrJ/MpYMxpVbu8cohqKlCUnbfu7Sz1y0VsN41NNB84nVz6WsUCW+5XBCVeQkIxFj8mmSapbo6jx23n7g/HBOcFF0knRO5fR6WKOiMlLJ3ImNZCR9jiRzgIdMWn+YmhlGxw4UIT2Aj4yGs3+KTjKUa+djBbaNRelZ3ydNkmi6W0n+IBfO/rMvtfxPRhP/b35bNhtQs85UHzNCDDoYtGOKKn60erXNfj9nIKs1SZZqxqHCn5wK4D1JHOYIiSTRL3P1F81MQwU9cpuqySfUxYRI2ePO3K1ElIIAMPxdIQXHUCFqidG2peaTvJdS7q+BNu89IVzfyAWL1DKTnoVeUIYTwSjcsMhowhayRmwkKK7PWea8HXNq8EsTA0Ny3DIeJBb5q8Jpc/Wapl+0vHnfbj4BcEJvugbTLA0JWTXpZaV5844uajWRQLBRAzYfXslLwG4rosEnjAExmB9QzU/U6dEAYPe3KkkaHWSihv2612X2yPNIlSiSC7g1OlZmXThyi9SfTZBzkipALQhXHj0FG/A40YLgtHDsMgt8BOFBE7JCS3U4AE5xXO7qshFu5wmyKfHJlxwyFdr7Ak/+TMKKnleq5eFBsInvYTtkrkAcbd3vlgOhAf9YaLjBmVbl3+3s9KjNWaY46+MYUp5Tb8NyAffJd9W7z2pYgRehF+71aKd9nygI/oA5Lmtkc1AxjSvOWdus31KW/6RNzS/zKF9jizNGb3JnDCsb6PADUFg3PsG9V+ZlCmXIlGBqZiBTV1XDq/gt4gVGfDAQIWtJYAH7aqHLJ45HGn46e1CXU2cKgj3WhfCTPid8Ng+rWhsmhUaTu+5wA/aD1Xsmg/aJKaWAoJ8oyzkpZwlteofCAwGpdZSLu9JBvm9gHqO3jNnI6p/x8VCZ+zB4FnGTeTSHkhDxxJLroG66CE1+0kFnQcmt1H+gzsc7KD4krOjKs9Bez2ScbsxPHgYT4rdpCwShSPgVWQ9gqCdrAsZEyuNdngLWYw9AUgbjqhP1fJL9KlMFM5ohLaY1NtK9wwjWt8s3lA7lx8/85DiKP6J1HJzGirzRtzOrO4RfVykJxW5rfWQ6iVTqjGKrrF3Sa7CFsClH8kdw8f4LDqYIGLXd7ZGO6EjeECZOzmD+wT4LBZ4Qg52rF1aoMK+uHFzQXiIcLq5hZyyk5Mumwvaevn1yKb8TQChyqbP610F6OclHyU56A3+dlXoq+CREeoy/30P2se/UwHl/FHzXDMqFZ5T+Q7Q3ny+FUOEHMeX0dCQnWg5b9w9B1WccQoK8XB4+871ODbF+kVwUn22Pqq2QP9ncV2Z1I3p/eDDvUb22MmWriR/Tb21ec5YbL0GfG1sM/HydWjEF4PP6ea8Mz5lxG896lG2pF7666HuW/oX3fJ7+kF//D7mZS+gR5RuBAtxqHdHwGzQiI3qkT64rs6eCPjorWNhMtXZbnMxO7URh/oL/MZyI7puSLTSl2hzU9Ild6ENJqzBtwyB5R7nmWRFMKq2AdcJmaeBNZwVQb1o/mCRALfF+iMcn2AmAXPDt/KOSqDjf22EwH60RKCdT/r3MnAKPtWhu4DQiGCaTSEwUflOY4Bi3ysDOVnZSzo25Xp0oSTu5igZpEofkvPC8iX2bGp01xAZ2yhJsc64ghXsiR3nzRDhM9t6xucrmzmTpJJ/GpHyYgVFdiuWHw8PF4x+Re5abSxSRTD/n6ttiv29kk4+9lNulhq9Xj1xemimFio+PRebMq6r3NEAOHIu6m0TF0SugGIoVEqYoFLwudrsIYKxrywcNVzbjGjtZptZnZU1h7wZmPb9oMedm6EUB9N+zju92ZyDHJ3cspDAPZd5KOVcCmUpXQkFRLxVl2jgYGrmhRjoTrK3CPyj4n9QugGndjRVYfQcnrvQeN+8LRjBesSVPrlE2+c05yWLsB1s5ssPJMzPMpIpA5YQfUzBTW9hsjlwCmzomCmoM0lbPLrTXw3IZJM5bovUMqcudrQFxykuISbi9VEdKpwHcoX4/7P37UskIYuvvfXhlM3cSYEtmpBlJsTCW8sAV9D85eoxZA4Bldkw3907Qr6eHGvIDmDqZBuFG0VgcYCOFSrtear3oRgYdHLTP2T8j7jBu41iEAQdi9Kt75HxEarMADDRVP2NVHhjglw5JvyAEyNmogjmaHhKqPYrkICp1QIPq17ZB515gxHCOgODkwhkfK1NgBCiXOKvIRDmIkeIebv7L6p08BNN40zNY9aaU14lNj4x/KsCx79IUT6rR7XFGEzz4M4VaTkr/EgtVmIEGy7zACOuKb4SsdCdXgSlKJT0XjjDVxydEZBczKsLbgJOGlF5IsuwCH+D1jtWfU+bMw95qIS6huDsJh9IxbPDtYF2tZ+NUFY/NH1KUEL3rqJuvMFWkhuU4lF80yD4COBFOyzUFZoBSjUQXMnGMhqlMMEQQ4GmoCFnGMgFg7+14+iwIqhBxPgQM8yrcXh8E6+8lOxLL7r57gmdGlwnMR6o9bb2TTLpMZh7WeQtCDePEktlxFx2ZhD2WXill0kUgGB2uX/P/zULBpzrElL22fQS2IK32Z8f4BcAML6I1JVQVf3kK6h2pwHbufB8Q48BkGUv4A4McQLD5F/yVwDlsc3rzXr37lya4JbOw5vAVmMmWHjopi0GweRuUngfviMdW7c6S80u3zkAdVJkw7EUkp+ch9H9iFFoVjLZFbQPwmndm/I+afM0jNuW3AVMPgb0Wbl7PP6Y0TT07vprhyFmLQaRIbcqlLGL3QG5lfpQ4AlWXffINWZYIkIvjoVQBTXBogNd6VQBvFvPU2kkhP/N6n7WdM3XoybLPQwgN7CM2warEJn0FUoYzhDqg7qW8BTdzRyp+f6RHD46ibyLLtIGtyCBwGqpvtvNHJhPGSCwWNfQz/iuhY/wDPHg+7N9ZJKX4AqBbTAcLkw9M4gYakOzDd1eaPjS7DecUgbjntYdCEqnmRwImm4nmLLcS5hkDhAwZG3dtqzPJaT/W1bqBkwPA3KwyZ7UlODK1lIPfYd92PTek3606y3LBy2T/Kugv3M7CpGaS9zTpLO+fSNjjV8W52fp8vlBWma+8ZJ3IZNzCkG7TgK9es5/noKYkkCROzaLSzHEA64m14ZOuxivK1te//J/2EYCBpisJD45GY3Fme+VerYCsMFx8KczRknXmGTUkU0vnNhs3rldUmsr+mUhmWbRf+XvCfIxnYIrbSvMrpAMrQXdYwG8oTSCfbYQ3OYXRycaAh/bL3GzmDQThDSXfpY/38hpBdkskObvdTTPn+c3YqRGCNgri4VvbRfgQlV+0sjam63zXdSgsmh2oMDaLFVq4JtBI5zNYgp/p+sHqdPiMRdscauAJpH0RO4aC8AqNQXolzRp4hasUfeGGPYyg9Tlh9YKa7SoYkHTqrTSSV8QHvIXmaNzWh2sRXFlJJRMmzmMA4jULcmFQH6K7CW3ZO0e7WuuBNuLJvKDHDvTE4yRFq4BZIRS29z3QG6BQQu6DRwLb8ZRYXrfvyKT3l91f9j0gsgsh9vHaDO9M11JBj9Vl+0OOn1P82VRq8Xn4KGHFlPZjani29ME4LDWe3eL9PqRJPxy1zWBnvBpX6eS5zjFCleBZ5HJ1EXDM9zLtuI7amHRkOu2sIPQk+t8ac8dyGG3kBat9xjAg9hVfMsGIIUF1eatTW9Nr3avXnqVm860prib4HTzucxu0079vWIEdSRUe/lS3X188AdxivzxVZYCPlRWvlRgfMvNloqZJWfLA8rE9iGCjB4eo+b1BfH03R1I71wlCXFyK13/jXkXlWuqE1UZX/a21MTLnbXxeATf2hts2nbgOYrYMGd5rqtu5wDrdV/++X4BBKeKiky3ITr+pls4afqXl1TAmx5ZbjZHxvxs4tPsmYOz8k6mIYkA5L/bbYIvqrmBEZR9UvuhcTpQH1BrE0LuohfV2SfYyLAskUn0wJj1wkh+3y2YEoYlmA77GBiLNSciWUU7YVN9UPwzTYM7EoKdGe7fIqntZvz2oGqI+mdvlBJScMX+dcYyy1wKSwISm+8byrqIyHXsAjwcPej1HoSlptPxG0c4Gmz/CqJJE0gWiETbuoxCfMhsTSgGdIG8PbCyh7BwX/7L/NzlbPdTZPFmagn+MHJCJk7xhw/ZGB4bvLCnt4HiK1spQHaj3KjKO6JqJT70kFGr/nNIRRnHwBUtqW53isuBWe6wL2d8pxbTXiLkfpP9JlkxuOWikBunjPHeVX3AvGLaJ/PKs3Ce0Zg4gbMmrfOApx8GSKDVY2g03ULdRguJOJSw+7N9z1l5sBrWDyxU1Ckwq8uT8qGDFal78s8pfBw87tzUEwCx4Iw7mWWGeVzEv2btZZW01edO6axZsyOVnmTl730Oa/pI9VSuHfG9Cl1UOj+leRU3IdmAgkcpfGJq7/4FIzvJrCWby55OIkf5e5jbAo/Wlpggp3MUik9oQteeXItI8Cm30J3ymHce6CDCBILNDr/rcT4haBMMfb9zYRkeYKV67I2R7fcO/pHzeCjelIv0H4DCg+HH8E/KnHtqiAYSDp+7qzQZYQv8/sgLx9ZVYUfcTpuTDKuWHF+JaAw6CbZQFSuUl2vqecTRts2/08tCzUscQLk9AQTRk6JXmvf95+nCUahgvUeC8Fk/7IsAzuCBrSaSnnBIdE9FbJ6X9EPEHPa4we713LM8+WgunKmA8uSTKmg3I3Qnue6FzinyRWwpLQ0qQiWu5hzaT8c0ez6G9YncBHen5oY32HWhjoJTDE0Hczt90HNvaVYptA1fCpIdST5B6aS5UtIwRXlLUamqzBZiTL3cX+ddFsUWYv6UWosBdRQ/CkM/WO1OJT789DGzXLtUQtOYEjJOWZxxM4CtEUTA++AgBrTtMCI4Xl2bqSGivrhfeNxjopVFeNK1hcuiaY+fiv7oFtZsyWzfyFi2SqDvhaAg4z/IOrLyvMZksp3vbpCn2bpPjdj9LYGSwwPGy2ZP3WhoXe4e3V6JwdIDK5ALYG3A9NKd035aU/pBUl/y8JrlSd0Tc+RRZGnTzMtUfH2ErP0DIlbYu7nlTeOPnUYzWNxbaNEcgc26la0mTZe9ruK5za98HH2b1oVgxCz8zDFkLECdOkdFvpJutq6/FQe5YARhj7jAuIgqsqGaeYEMoQpNJkrKCJHldhHtLpL1EN30kXMQfKcTN3Le6OMpBkS0kKiRKFly6eYOf1uSqNBuhMht2d4D1h4+4hbYJpje8Zhq5GmgI7HUAS7O0xYrc1YyPDBdEjXtEIKduTrqIdMB61FY68/Iv32amCoLkX1I4Ruuc3Cr0e/A+fxhTE0BOHDEknOuEVgHfhbSPv43+xwHWhxYe7EpbEE0q8swoxhbKZiFlEO+C+ySESNfsmchgNLHEEashSToH//HNL6QQqHf5MsexLbHPnRnT0dcJ25P0MCrGzf1aLBmLYZZ4MV0HadpclHcyzUH/vMD9MsSkRPwXnm1qrK1Ee0jErklp7yM2yrNoqK/Iq0JvCxirwqov3ldCK8NpDCChvW0hhNU/qGI3XPHWJBVzCMGXqXpTna+Eg5O9/wDXfpSCEz3ma187XHdazcCVxz33nzoM7zLa+tiCsRrpLdc4NO/uwx0jSycSJQLtm7A0ylxpsNm6AMgeB9W4YTjaymTX/vHy5j/FtYWlQXAd3wrNCY+Q9k8bdR+NkghngdPU2YaJPS2W42Y5ib3EWL5lR+cwMGXt86XmhbjE/DKdn5iVQ89Z5agI8XbQye5cZ29l2TrPuyCdt9QqVK0YdZY4O9jrERrCuODhfDa0zGNFyoU5tGdXjDoFTho4jx83GKWbwYYqfaY7fJfSF27GFg4wOHLPpvOud/8GFPR49e5TueQny9Nc7+pjpHDaGuvaBRmGmQEW5OoBMxrCHY4afSuKEQj2Z4UCuYbUiOetqDyqxZTaNW1lHFn2pllB1YTbq3ie1OAgKkTDOiDUIJ9ilAM9AoqoGmdBxroUkPyuSEU3dqCzNedh8poTpBv73Rw/KX4YIcSRw6JTJHnfvlvpzgikpWrE0deQSYNNjdmngEO9/TZf1ZRJcaZoMmhbAjdISEbvEL/5QNG5jngKW5SWjUogKYYQQMat0LOrJH3Tr98bmmAnt6NRoEGPO0NHivx46IivZ9CR/c3+mD0fijZWTspWWVz+QHDV2yaW1ve9l1mJorPAr777qH25QpjuhlPmna389W1IT55YZakwfTZWkuSkDF6qYEYa0A/i3GBj5jqtreBxJPaMYPRPjB4SPwUGASpTIhLddvBOlZFOc421l1ZVEphhFu4U+I+NnLzzG/i8VQZESCiRYv70FA7IDXz0V+pjvz1KVwxwb0ceHA1oQ3fiFwloco5z/HIWaZsVmWO6hxScQIHnRILvLbwBeBLxqGfy/bVviUIE+DUPG0z8hnR5EYjM1G8piYfgopxH7OyqTrGFExnZRSMEYlKNX325i3Bk4RAe6NW1xamF+97Lj61ruE59r+l7/Y4T8+/lcEzK1Sd8M5s3ovItYzlO0s9hMbSIUTMvY5r9trn0tfsrXPUkOCXQr3//YaZwb/iGQXaXUG8iE1XZsUjtYxlJAqw2VgTPXkwRS43Ea81J7qF5TeUBdq89mnNICrUBzfa5WWZx5TQSlVmLM/OVHY/Vz814bpK0Dd8hw6b72yIzeRyB1wkNEGr/vjtCBDP6lVATi13N8tbZJG3GHpmWW16ib3pNgusXD+jvqlfQtsu9N1vNrjCCn1qgCakT6bRKYafCL75erab2Mzu81g5M6HkAurvYgu3BlxN8yLUY7a7OAmzQVQom6hVergqofZSYkuLT8PfPX8n4jPZc0CBpDI3h1wMNJnad02/T1cCqapKh1eQVTzlMklGp0t9jZ+7JDUBSqmUOBThGJOar4AI1lnfxtdXV5twcpGz9QYMEhDy0FwJJMzCuHzB92arpYw8q8CV9h5DRKHFD0Dtzwyx/Omyr9bnPjHSJVNhN7QTmKVpoXbYiczpQRwVSiRecif/yt/q7hxAb9dMIiWqZv1sPixD3+NKJfZcmvffrl7tOoc5Lm/+rd+6eN8QVCqMHUwTnm7k4T9KL+bHjoGPU9cSZFoReG5Y0eD624jiL1HJZviklt4zYix9b20871S5oPttMADBP7JHVMwpqC+ntcAqvTt1mzN5EuK0Dn+/rqYOpxSdGhfNyJ2+lQ2tVfL/SyAgJtRGqPk+HxrUX8tSxcNE4tAIWrm2VxMM47q339uK7l0LUaFSDHW7WweYepvWOsWAGnEMdrES/4bFDKzyxOjFRDdtoZKgFsw3Ly/kvKz7ApUMVTMIvbSdLw9xz90SLJ99uIOpCtVfprDFbMz2QvIZO6dUvP9cQQ/wGrfmkz985+ml9DgKas3HLOe8zFU6qtAG2Wpt4K1t2oFVgpONc2NNYN8vo6OvHJaff+uqatlkA/w5rivUKu+EJAUCDBKsi4EPXNB1VW7jWRn28r55zZ81n9i48Fs7pQTkG2Z5G1IepyS7X9rA/ONoxdtLeA7VgpcUPC0kQodSCBX0OzIATSvUgGYsrMbXI/dHCTgYhJ1tCFplvayloe2R3Dry39WJZkrat+C+2QKXBbXUW65B8DLV4NuUR0v+zYlvBVM6WCysKggdbxNxX+0cyDrjUWeSbTTjJ/iolT9ZMRMt4cuur7c903VM+xA6RvzOEwFkp3lGnmw0YaXiqWAxsFGQrMZh4/TkzNQdEzzNj8VEk0cjEvRCA475JkMn3uXeWQ4Ha6ZL+bRPMIx/0iwAp90O8AlHcvG3w9Td59A+VLUOq+KNcZA2JuOe8nmndUnYylgh7OfgcKBWAdDfvwXZ79QEJXilwqzXftT44T0U+VuweIvQMEmcWBb6k0ZyH7Vx2akGxhCt2gSTdRzqAYIYSXJvTiZ/D0g0ElEujFKoNZRhK2JcXE2szJtU5R4rf/We8+3NhfcWgokZvTBibUoZ8N2jGHIanPnji10CIgbFN32Fbxj/i8bdwj05e/pcKhr9VEangbjoSNWw7GC3PPYCLQJ+aeoZQNPh7LnlDWa+DfThzAFA586Yxaqh8vO/r9JqK6YIroYqlCR11sFpRYX8t5t+9tUUTH6G/cXMBhfFyygeRHFnC65tfTYE/Aqyu7NZ5KoZbH6tBX3P54ZGpksxVxp9gM/nGgaFt+BrCjDzoa6WGVWiSwi9vV4tHZd5P0ba/mN1tG+xCGNfRJogljbc/hJiqDcAgvNLJNCipNGcF9Scj0+Kkz5QZ/XdS6jT7+HG3GIYSUSIY+VHBc1I20K1uF+LVaE3CPMezoA8UxP9fFh5nbx2edwoFsdPnklu3izQJ+tV9o34UUF4JqefW/+xOjqBhJPZpsbsTsiISMDiJzPu/hZW/2zQ2sbAF0WeorwL9ZM7GwU8cjk1xnl3C37m75K1r0DXoOX7wGQyjrACa+7uCo70JpquOcoYkwnFZHnyEj2WIbUDZU0zgRvxvi7Ug3uzlokESE0CHzDd7E+RelGJO+R7+DoifldwwlQSGeSF7kNfM7ho9Fn2sFGOEBzsYMzTuXRDWQx/037kqkzv+xc0w09xteQ7XbFOLNHnr3W/zYF6vmdF+nlSs1ASfgfnCKP5G/oFbJ2PycQOwUtpQZXFJkOv53jtifQzKBDbO9dj0TmnOCxYJjrrwyX0wLt7xqnN6gHveGNcgK0Gnr9XQpyUL8Gu1jq2cZwI2oTy6N5+r4ECtmQMtz/J25lTVpqnnxAovJTWiNSdJcFEXwDTBJlYitQRhqaOgUxgH5CL2YXWFiQJlaiFy0COacDbbyld8YmOCyZ5EvnQxWjt5z1CGsP8C0bapO4OOCJEPo9KS1UREgsAYXSBoaR/iN+MwgG/fQPFIyMOoPEjabIJiy/ZAPw5Ls7Q/VUSzvwAMx6XZ2AYRbKQ6XwD2DsvouxXG7GAMeUZTElgc5Vwlp6h6hnnEAl2xsO67qme8md3zo6Jx5/dMb8WDMmQ1qoTUGQE4mJ0HlZYB2aTk09QbFdF/rsoOv3JjYbp55zISa1RXMPRE82uXUbbxMk74q+MwQ1Ep+nhnNjnBPnm8c1qVyb7YIfD1OcCdVnLnPGH8jCsz4HYNgCKIVAAckIjkct1w/hZLeWXQ6jhiZ5Jw8G7pgXES9sVUPc8hBKKP4O2E1ybPwNdZwIlXUWUkX+TYogBgCYl+CBKBwmvVCges8OMeGds0qmPVbIym/jm0dYUp4Es2mtmN+erTAvIfFWAP5D/B+LSabwxY85lHdfrAGrxYipDnIHYee5omJjamzDum/cxYn6EqEgJOre2wU9yfGkBO/yTnCqYikFiiZDJqVc0DJ9lPfPrcOYogYKhIL1uB3i1o23hH9qoMIoKzOPoatWvzRduom1X3bcpMDd0uaTSSMglK4tONV8k7jLI4unbP7cmFk222UYXoVxrTcAICPkN/NwRiQ1pHB9j966PagpkHJ4smxUVUFGPrgUp53kVQ7wmP7xRzN9nhu4LZQavB8ZHphgRidCWHGTCpP6hJAZk8/ldQa45rXIZSIj4ci3J69S1WQHfGuIsx8qb155Ue1eBQzehKj+OxhNBZA2Cgl7Lw5ZFuXnkFXwJo7sBvLOXCfrYNaEVHKd9OEpHFbqw+4brFxm+0fNG7q5HLeZhq0bAAJAaBMH/oFqJbYfgDovFzBYEYVIvMcqbuKJwX6t5kqFs4YHAPjkhmSevpqOsG84DdqSTrQjsUuuLzHzbLYs1ZaIGONl+v+wayNsCmbrBmO8lp9w276JUSSOpF3531FH6+hAVe7yd9tLZWaOPkifoml7a50gkaKFDghjc5HnZxM7xosnW1oc6/Erak7+FRWJlytQGBIVfAVBkZVF26PoJy0YAl1T0+rgbZ9jqk9m87S7nZhR5bAaA1SU9+NdtXtUTb7wDrNgE2gPATsg7ybuvfcjPHhO2GTtJtS/35/ipLf8kM6aw5ebyydN/out1jJneAabGUkgK7Xrr0fEaQSrB+oQeHFpn67dN5B5w/hpb1FmwYyUBmCUjlhvHm4sLVCDxRVmnSJlnDpcLkSIyzo8ES1vxlT0Eu8aY8VAjSLls4be7bY7B2IsmXR8la7Tcr5LXgyryXgHt1ofwvYsHqO42dZJxlFxqN/cz45ZTZU3uRWhjr0U3DxKFT+mN2IyYFTKThW2VV+R+/r8O9okTIwJ/KKKcx100GLO2J1Ao9ng3IdqwIWdURxhJ56nC9V4hw7aCF1TNzRHO3PTcMe49VURU4qFQDFtz7lZgbz3SNFHUvKTjPKLOPR03znTgfysMlOANcgTl3u5QkrsKlFkjHkJAZDs0f3PgqengquYaZjbrJ0VjrzjUlVa84F+rkq/OZIE9mhmE7ejPs6GuT5yVxOTke70rZIWpirowRXjTSx124AUY/fY3pCXSkg49T+SmX7L253aFsi11bVOc8sGJGqLsjkW3f84NjGnElULFawVaR4vPcgUNaWjqvkgCH5GATxidytdJtSmVWKahMWJsd56DKSQF2w3tdj+f5RgANUcOEgAQMrB04VFeRXSEl5G759Spsj4wdQ8/pT+ArKBKLDV+gvC5TtRWQgKKkZjHt1pE+AG5WbwEZMOBMb9HLP5k8SGcHgqJHsDYnwrzfuDXG/t67gh2gI17M6ZEETS8b56kIYy33cjOMYecAiRY0IQ+/Z1jS8tc6pxn/66B5Rf7KACqNoAAA" alt="图片"></p><p>同样，TCP&#x2F;IP五层协议的通信方式也是对等通信： <img src="data:image/jpg;base64,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" alt="图片"></p><h2 id="三、HTTP协议"><a href="#三、HTTP协议" class="headerlink" title="三、HTTP协议"></a>三、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1.GET和POST的请求的区别"></a>1.GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作</li><li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存</li><li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据</li><li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中</li><li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的</li><li><strong>参数类型：</strong> post 的参数传递支持更多的数据类型</li></ul><h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2.POST和PUT请求的区别"></a>2.POST和PUT请求的区别</h3><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li><li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li></ul><h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3.常见的HTTP请求头和响应头"></a>3.常见的HTTP请求头和响应头</h3><ul><li><p><strong>HTTP Request Header 常见的请求头：</strong></p><ul><li><p>Accept:浏览器能够处理的内容类型</p></li><li><p>Accept-Charset:浏览器能够显示的字符集</p></li><li><p>Accept-Encoding：浏览器能够处理的压缩编码</p></li><li><p>Accept-Language：浏览器当前设置的语言</p></li><li><p>Connection：浏览器与服务器之间连接的类型</p></li><li><p>Cookie：当前页面设置的任何Cookie</p></li><li><p>Host：发出请求的页面所在的域</p></li><li><p>Referer：发出请求的页面的URL</p></li><li><p>User-Agent：浏览器的用户代理字符串</p></li></ul></li><li><p><strong>HTTP Responses Header 常见的响应头：</strong></p><ul><li><p>Date：表示消息发送的时间，时间的描述格式由rfc822定义</p></li><li><p>server:服务器名称</p></li><li><p>Connection：浏览器与服务器之间连接的类型</p></li><li><p>Cache-Control：控制HTTP缓存</p></li><li><p>content-type:表示后面的文档属于什么MIME类型</p></li></ul></li><li><p><strong>常见的 Content-Type 属性值有以下四种：</strong></p></li></ul><p>​（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码</p><p>​（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式</p><p>​（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串</p><p>​（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据</p><h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4.HTTP状态码304是多好还是少好"></a>4.HTTP状态码304是多好还是少好</h3><ul><li><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载</p></li><li><p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应</p></li><li><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高</p></li><li><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul></li><li><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止</li><li>收录减少</li><li>权重下降</li></ul></li></ul><h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5.常见的HTTP请求方法"></a>5.常见的HTTP请求方法</h3><ul><li>GET: 向服务器获取数据</li><li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改</li><li>PUT：上传文件，更新数据</li><li>DELETE：删除服务器上的对象</li><li>HEAD：获取报文首部，与GET相比，不返回报文主体部分</li><li>OPTIONS：询问支持的请求方法，用来跨域请求</li><li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信</li><li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断</li></ul><h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6.OPTIONS请求方法及使用场景"></a>6.OPTIONS请求方法及使用场景</h3><ul><li><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法</p></li><li><p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存</p></li><li><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li>获取服务器支持的所有HTTP请求方法</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限</li></ul></li></ul><h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7.HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7.HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延</li><li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略</li><li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站</li><li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等</li></ul><h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8.HTTP 1.1 和 HTTP 2.0 的区别"></a>8.HTTP 1.1 和 HTTP 2.0 的区别</h3><ul><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础</li><li><strong>多路复用：</strong> HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题</li><li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流</li><li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了</li><li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的</li></ul><p><strong>【1】队头堵塞：</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象</p></blockquote><h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9.HTTP和HTTPS协议的区别"></a>9.HTTP和HTTPS协议的区别</h3><ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全</li></ul><h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10.GET方法URL长度限制的原因"></a>10.GET方法URL长度限制的原因</h3><ul><li>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span>的长度值 = <span class="hljs-variable constant_">URL</span>（<span class="hljs-number">2083</span>）- （你的<span class="hljs-title class_">Domain</span>+<span class="hljs-title class_">Path</span>）-<span class="hljs-number">2</span>（<span class="hljs-number">2</span>是get请求中?=两个字符的长度）<br></code></pre></td></tr></table></figure><ul><li><p><strong>下面看一下主流浏览器对get方法中url的长度限制范围：</strong></p><ul><li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应</li><li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符</li><li>Safari (Browser)：URL最大长度限制为 80,000 个字符</li><li>Opera (Browser)：URL最大长度限制为 190,000 个字符</li><li>Google (chrome)：URL最大长度限制为 8182 个字符</li></ul></li><li><p><strong>主流的服务器对get方法中url的长度限制范围：</strong></p><ul><li>Apache (Server)：能接受最大url长度为8192个字符</li><li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符<br>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作</li></ul></li></ul><h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11.当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11.当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong> 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程</p><p>（2）<strong>缓存判断：</strong> 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求</p><p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</p><p>（4）<strong>获取MAC地址：</strong> 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址</p><p>（5）<strong>TCP三次握手：</strong> 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了</p><p>（6）<strong>HTTPS握手：</strong> 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输</p><p>（7）<strong>返回数据：</strong> 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程</p><p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了</p><p>（9）<strong>TCP四次挥手：</strong> 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态</p><h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12.对keep-alive的理解"></a>12.对keep-alive的理解</h3><ul><li><p>HTTP1.0 中默认是在每次请求&#x2F;应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。<strong>其使用方法如下：</strong></p><ul><li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段</li><li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段</li></ul></li><li><p><strong>Keep-Alive的建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul></li><li><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul></li><li><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul></li><li><p><strong>开启Keep-Alive的优点：</strong></p><ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）</li><li>允许请求和应答的HTTP管线化</li><li>降低拥塞控制 （TCP连接减少了）</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li><li>报告错误⽆需关闭TCP连接</li></ul></li><li><p><strong>开启Keep-Alive的缺点：</strong></p><ul><li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源</li></ul></li></ul><h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13.页面有多张图片，HTTP是怎样的加载表现？"></a>13.页面有多张图片，HTTP是怎样的加载表现？</h3><ul><li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度</li><li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求</li></ul><h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14.HTTP2的头部压缩算法是怎样的？"></a>14.HTTP2的头部压缩算法是怎样的？</h3><p><strong>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率</strong></p><p>具体来说:</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</li><li>首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值<br>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销<img src="data:image/jpg;base64,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" alt="图片"></li></ul><h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15.HTTP请求报文的是什么样的？"></a>15.HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p><ul><li>请求⾏</li><li>请求头部</li><li>空⾏</li><li>请求体<br><img src="data:image/jpg;base64,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" alt="图片"></li></ul><p> <strong>其中：</strong><br>（1)请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1</p><p>（2)请求头部:请求头部由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p><ul><li>User-Agent：产⽣请求的浏览器类型</li><li>Accept：客户端可识别的内容类型列表</li></ul><p>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机<br>（3）请求体: post put等请求携带的数据 <img src="data:image/jpg;base64,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" alt="图片"></p><h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16.HTTP响应报文的是什么样的？"></a>16.HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成:<br><img src="data:image/jpg;base64,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" alt="图片"></p><ul><li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK</li><li>响应头：响应部⾸组成</li><li>空行</li><li>响应体：服务器响应的数据</li></ul><h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17.HTTP协议的优点和缺点"></a>17.HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性</p><ul><li><p><strong>HTTP协议具有以下****优点</strong>：</p><ul><li><p>支持客户端&#x2F;服务器模式</p></li><li><p><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</p></li><li><p><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间</p></li><li><p><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快</p></li><li><p><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</p></li></ul></li><li><p><strong>HTTP协议具有以下缺点：</strong></p><ul><li><p><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息</p></li><li><p><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全</p></li><li><p><strong>不安全</strong><br>（1）通信使用明文（不加密），内容可能会被窃听<br>（2）不验证通信方的身份，因此有可能遭遇伪装</p><p>（3）无法证明报文的完整性，所以有可能已遭篡改</p></li></ul></li></ul><h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18.说一下HTTP 3.0"></a>18.说一下HTTP 3.0</h3><p>HTTP&#x2F;3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议<img src="data:image/jpg;base64,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" alt="图片"></p><ol><li><p><strong>流量控制、传输可靠性功能：</strong>QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性</p></li><li><p><strong>集成TLS加密功能：</strong>目前QUIC使用TLS1.3，减少了握手所花费的RTT数</p></li><li><p><strong>多路复用：</strong>同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题<br><img src="data:image/jpg;base64,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" alt="图片"></p></li><li><p><strong>快速握手：</strong>由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接</p></li></ol><h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19.HTTP协议的性能怎么样"></a>19.HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里</p><ul><li><p><strong>长连接</strong><br>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接<br>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接</p><p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间</p></li></ul><p><strong>对于不同版本的采用不同的连接方式：</strong></p><ul><li>在HTTP&#x2F;1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接</li><li>在HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接<br><img src="data:image/jpg;base64,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" alt="图片"></li><li><strong>管道网络传输</strong><ul><li>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能</li><li>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞</li></ul></li><li><strong>队头阻塞的解决方案：</strong></li></ul><p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务</p><p>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题</p><ul><li>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题</li></ul><h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20.URL有哪些组成部分"></a>20.URL有哪些组成部分</h3><p>以下面的URL为例：<a href="https://link.juejin.cn/?target=http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1%23name">www.aspxfans.com:8080/news/index.…</a></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符</li><li><strong>域名部分</strong>：该URL的域名部分为“<a href="https://link.juejin.cn/?target=http://www.aspxfans.com%E2%80%9D%E3%80%82%E4%B8%80%E4%B8%AAURL%E4%B8%AD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8IP%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%90%8D%E4%BD%BF%E7%94%A8">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li><li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）</li><li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”</li><li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li><li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符</li></ul><h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21.与缓存相关的HTTP请求头有哪些"></a>21.与缓存相关的HTTP请求头有哪些</h3><p><strong>强缓存：</strong></p><ul><li>Expires</li><li>Cache-Control<br>协商缓存：</li><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><h2 id="四、HTTPS协议"><a href="#四、HTTPS协议" class="headerlink" title="四、HTTPS协议"></a>四、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1.什么是HTTPS协议？"></a>1.什么是HTTPS协议？</h3><ul><li><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性 <img src="data:image/jpg;base64,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" alt="图片"></p></li><li><p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生</p></li><li><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong></p></li></ul><h3 id="2-HTTPS的特点"><a href="#2-HTTPS的特点" class="headerlink" title="2.HTTPS的特点"></a>2.HTTPS的特点</h3><ul><li><p><strong>HTTPS的优点如下：</strong></p><ul><li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器</li><li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本</li></ul></li><li><p><strong>HTTPS的缺点如下：</strong></p><ul><li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂</li><li>HTTPS协议握手阶段比较费时，增加页面的加载时间</li><li>SSL证书是收费的，功能越强大的证书费用越高</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本</li><li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名</li></ul></li></ul><h3 id="3-HTTPS是如何保证安全的？"><a href="#3-HTTPS是如何保证安全的？" class="headerlink" title="3.HTTPS是如何保证安全的？"></a>3.HTTPS是如何保证安全的？</h3><ul><li><p>先理解两个概念：</p><ul><li><p><strong>对称加密：</strong>即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥</p></li><li><p><strong>⾮对称加密：</strong></p><ol><li><p>私钥 + 公钥&#x3D; 密钥对</p></li><li><p>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</p></li><li><p>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</p></li><li><p>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密<br>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能</p></li></ol></li></ul></li><li><p><strong>解决⽅案：</strong></p><ul><li><strong>结合两种加密⽅式</strong>，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通</li><li>此时⼜带来⼀个问题，<strong>中间⼈问题</strong>： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据</li><li>所以这个时候需要⼀个<strong>安全的第三⽅颁发证书（CA）</strong>，证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等</li><li>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，<strong>数字签名</strong></li><li><strong>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名</strong>。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了</li></ul></li></ul><h3 id="4-HTTP和HTTPS的区别"><a href="#4-HTTP和HTTPS的区别" class="headerlink" title="4.HTTP和HTTPS的区别"></a>4.HTTP和HTTPS的区别</h3><ul><li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</li><li>HTTPS可以保证报文完整性，另外可以核实发送者身份</li><li>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</li><li>HTTPS在TCP三次握手阶段之后，还需要进行SSL的handshake，协商加密使用的对称加密密钥</li><li>HTTP协议端口是80，HTTPS协议端口是443</li></ul><h3 id="5-TLS-x2F-SSL的工作原理"><a href="#5-TLS-x2F-SSL的工作原理" class="headerlink" title="5.TLS&#x2F;SSL的工作原理"></a>5.TLS&#x2F;SSL的工作原理</h3><ul><li><p><strong>TLS&#x2F;SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造</p></li><li><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li><p>基于散列函数验证信息的完整性</p></li><li><p>对称加密算法采用协商的秘钥对数据加密</p></li><li><p>非对称加密实现身份认证和秘钥协商<br><img src="data:image/jpg;base64,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" alt="图片"></p></li></ul></li></ul><h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><ul><li>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性</li><li><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密</li></ul><h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><ul><li>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法</li><li>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一</li><li><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码</li><li><strong>DES：DES的基本结构是由Horst Feistel设计的，因此也叫Feistel网络、Feistel 结构 或者Feistel密码。很多密码算法中都用到这种结构。<br>在Feistel网络中，加密的各个步骤称之为轮，整个加密过程就是进行若干次轮的循环。DES 是一种16轮循环的Feistel网络</strong></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208081129181.png" alt="DES加解密"></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208091327030.png" alt="Fesitel网络中的一轮"></p><ul><li><strong>上图表示Fesitel网络中的一轮，根据上图讲解一下Fesitel网络的具体结构</strong><ol><li>上面两个方框表示本轮要加密的64bit 明文，输入的数据会被分为左右两个部分分别处理</li><li>下面两个方框表示本轮输出的左侧（密文）和右侧（明文）</li><li>中间的子密钥指的是本轮加密所使用的密钥，在Fesitel网络中，每一轮都需要不同的子密钥。由于子密钥只是在一轮中使用，所以它是局部密钥，因此才被称为子密钥</li><li>轮函数 的作用是根据 右侧 和 子密钥 生成对左侧进行加密的bit序列，它是密码系统的核心。将轮函数输出的bit序列与左侧进行异或运算，其结果就是加密后的左侧</li><li>输入的右侧将直接输出</li></ol></li><li><a href="https://www.dounaite.com/article/6277c862ac359fc91324c5dc.html">详见</a></li></ul><h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><ul><li>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题</li><li>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208081130937.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208081130591.png" alt="img"></p><ul><li><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢效率不高，一般只适用于处理小量数据(如密钥)</li></ul><p><strong>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题</strong></p><h3 id="6-SSL的工作流程"><a href="#6-SSL的工作流程" class="headerlink" title="6.SSL的工作流程"></a>6.SSL的工作流程</h3><ul><li><strong>协商加密算法</strong><ul><li>浏览器A向服务器B发送SSL版本，及自身支持的加密组件（包括加密算法及密钥长度等）</li><li>B从中选择自身支持的加密组件和SSL版本，发送给A</li></ul></li><li><strong>服务器鉴别</strong><ul><li>B向A发送包含公开密钥的数字证书</li><li>A对数字证书进行鉴别，获取B的公钥</li></ul></li><li><strong>会话密钥计算</strong><ul><li>A随机产生秘密数，将秘密数通过B的公钥发送给B，之后A通过协商的加密算法产生会话密钥</li><li>B接收到秘密数后，通过B的私钥将其解密得到秘密数，然后根据协商加密算法产生会话密钥</li></ul></li><li><strong>安全数据传输</strong><ul><li>双方会互相发送一次数据，用会话密钥加密和解密他们之间传达的数据并验证其完整性</li></ul></li><li><strong>通信</strong><ul><li>上述验证通过后，才继续进行http通信</li></ul></li></ul><h3 id="7-数字签名和数字证书"><a href="#7-数字签名和数字证书" class="headerlink" title="7.数字签名和数字证书"></a>7.数字签名和数字证书</h3><p>使用公钥密码加密的一般流程：通过A的公钥对报文加密，发送给B，然后B拿A的私钥进行解密，得到报文. <strong>注意：并不是每次传输报文的时候都要加数字签名，数字签名一般用于数字证书的验证，这样的话浏览器内置的CA拥有服务端的公钥和私钥</strong></p><ul><li><p><strong>数字签名</strong></p><ul><li>普通数字签名(<strong>能核实发送者，但无法保证报文完整性</strong>)<ul><li>A通过A的私钥对报文进行加密，将其附在报文的后面，发送给B，然后B拿A的公钥对附加信息进行解密的过程，为数字签名</li><li>上述过程中仅仅实现了数字签名，但并没有对实际报文进行加密。实际操作时，可以通过A→A私钥(数字签名)→B公钥(报文加密)→B私钥(报文解密)→A公钥(验证数字签名)</li></ul></li><li><strong>密码散列函数</strong><ul><li>使用密码散列函数对报文进行与运算得到hash值，简称摘要</li><li>密码散列函数有MD5和安全散列算法SHA</li></ul></li><li><strong>报文摘要数字签名</strong>(<strong>核实发送者，保证报文完整性</strong>) 对报文本身加密可能是个耗时过程，比如这封Email足够大，那么私钥加密整个文件以及拿到文件后的解密无疑是巨大的开销<ul><li>A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1</li><li>然后用自己私钥对摘要加密，生成的东西叫“数字签名”</li><li>把数字签名加在Email正文后面，一起发送给B</li><li>防止邮件被窃听你可以用继续B公钥加密</li><li>B收到邮件后使用B私钥对报文解密，用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充</li><li>B对邮件正文执行哈希运算得到hash值，取名h2</li><li>B会对比数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改</li></ul></li><li><strong>数字签名的作用</strong><ul><li>确认核实发送者</li><li>保证报文的完整性</li><li>一般用于验证数字证书</li></ul></li></ul></li><li><p><strong>数字证书</strong><br>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了，由认证中心（CA）或者认证中心的下级认证中心颁发。通俗来说，A确认收到的公钥真的是B的公钥，而不是别人伪造的</p><ul><li><strong>制作数字签名</strong><ul><li>CA拥有非对称加密的私钥和公钥。</li><li>CA对证书明文信息进行hash。</li><li>对hash后的值用私钥加密，得到数字签名</li><li>明文和数字签名共同组成了数字证书</li></ul></li><li><strong>数字证书验证过程</strong><ul><li>拿到证书，得到明文T，数字签名S</li><li>用CA机构的公钥对S解密，得到S’（由于是浏览器信任的机构，浏览器保有它的公钥，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥）</li><li>用证书里说明的hash算法对明文T进行hash得到T’</li><li>比较S’是否等于T’，等于则表明证书可信</li></ul></li></ul></li><li><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全<img src="data:image/jpg;base64,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" alt="图片"></p></li></ul><h3 id="8-HTTPS通信（握手）过程"><a href="#8-HTTPS通信（握手）过程" class="headerlink" title="8.HTTPS通信（握手）过程"></a>8.HTTPS通信（握手）过程</h3><p><strong>HTTPS的通信过程如下：</strong></p><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息</li></ol><h3 id="9-HTTPS必须在每次请求中都要先在SSL-x2F-TLS层进行握手传输密钥吗？"><a href="#9-HTTPS必须在每次请求中都要先在SSL-x2F-TLS层进行握手传输密钥吗？" class="headerlink" title="9.HTTPS必须在每次请求中都要先在SSL&#x2F;TLS层进行握手传输密钥吗？"></a>9.HTTPS必须在每次请求中都要先在SSL&#x2F;TLS层进行握手传输密钥吗？</h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行</p><ul><li>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下</li><li>之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了</li></ul><h3 id="10-cookie和session"><a href="#10-cookie和session" class="headerlink" title="10.cookie和session"></a>10.cookie和session</h3><p>HTTP协议作为无状态协议，对于HTTP协议而言，无状态指每次request请求之前是相互独立的，当前请求并不会记录它的上一次请求信息，如何将上下文请求进行关联呢？<strong>客户端（不同的浏览器）记录用户的状态通过cookie，服务器端（不同的网站）记录用户的状态通过session</strong></p><ul><li><strong>cookie</strong><ul><li><p><strong>工作流程</strong></p><ul><li>客户端请求服务器端，服务器端产生cookie响应头，随响应报文发送给客户端，客户端将cookie文本保存起来</li><li>下次客户端再次请求服务端时，会产生cookie请求头，将之前服务器发送的cookie信息，再发送给服务器，服务器就可以根据cookie信息跟踪客户端的状态</li></ul></li><li><p><strong>基础知识</strong><br>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie，它是服务器端存放在本地机器中的数据，随每一个请求发送给服务器，由于Cookie在客户端，所以可以编辑伪造，不是十分安全。</p><ul><li><strong>非持久cookie</strong><ul><li>内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的</li></ul></li><li><strong>持久cookie</strong><ul><li>硬盘Cookie保存在硬盘里，有一个过期时间（客户端cookie设置的时间），除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的</li></ul></li></ul></li></ul></li><li><strong>session</strong><ul><li><p><strong>工作流程</strong></p><ul><li>当用户第一次访问站点时，服务器端为用户创建一个sessionID，这就是针对这个用户的唯一标识，每一个访问的用户都会得到一个自己独有的session ID，这个session ID会存放在响应头里的cookie中，之后发送给客户端。这样客户端就会拥有一个该站点给他的session ID</li><li>当用户第二次访问该站点时，浏览器会带着本地存放的cookie(里面存有上次得到的session ID)随着请求一起发送到服务器，服务端接到请求后会检测是否有session ID，如果有就会找到响应的session文件，把其中的信息读取出来；如果没有就跟第一次一样再创建个新的</li></ul></li><li><p><strong>基础知识</strong><br>session是存放在服务器里的，所以session 里的东西不断增加会增加服务器的负担，我们会把一些重要的东西放在session里，不太重要的放在客户端cookie里</p><ul><li><strong>session失效</strong><ul><li>服务器（非正常）关闭时</li><li>session过期&#x2F;失效（默认30分钟）<ul><li>问题：时间的起算点 从何时开始计算30分钟？从不操作服务器端的资源开始计时（例如：当你访问淘宝页面时，点开页面不动，第29分钟再动一下页面，就得重新计时30分钟；当过了30分钟，就失效了）</li></ul></li><li>手动销毁session</li></ul></li><li><strong>sessionID的传递方式</strong><ul><li>通过cookie传递</li><li>当cookie禁用后，可以通过url传递</li></ul></li><li><strong>不同场景下的session</strong><ul><li>当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session</li><li>当不在同一个窗口中打开相同的浏览器时（打开多个相同的浏览器），发送请求，仍是同一个session</li><li>当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session</li><li>当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，是不同的session</li></ul></li></ul></li></ul></li><li><strong>区别</strong><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</li></ul></li></ul><h3 id="11-浏览器关闭后，session就销毁了吗？"><a href="#11-浏览器关闭后，session就销毁了吗？" class="headerlink" title="11.浏览器关闭后，session就销毁了吗？"></a>11.浏览器关闭后，session就销毁了吗？</h3><p>浏览器关闭和服务器session销毁没有任何关系，会话Cookie（非持久cookie）在关闭浏览器后就会消失，但是原来服务器的Session还在，只有等到了销毁的时间会自动销毁</p><h2 id="五、HTTP状态码"><a href="#五、HTTP状态码" class="headerlink" title="五、HTTP状态码"></a>五、HTTP状态码</h2><p>状态码的类别：</p><table><thead><tr><th align="left"><strong>类别</strong></th><th align="left"><strong>原因</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">1xx</td><td align="left">Informational(信息性状态码)</td><td align="left">接受的请求正在处理</td></tr><tr><td align="left">2xx</td><td align="left">Success(成功状态码)</td><td align="left">请求正常处理完毕</td></tr><tr><td align="left">3xx</td><td align="left">Redirection(重定向状态码)</td><td align="left">需要进行附加操作一完成请求</td></tr><tr><td align="left">4xx</td><td align="left">Client Error (客户端错误状态码)</td><td align="left">服务器无法处理请求</td></tr><tr><td align="left">5xx</td><td align="left">Server Error(服务器错误状态码)</td><td align="left">服务器处理请求出错</td></tr></tbody></table><h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1.2XX (Success 成功状态码)"></a>1.2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了</p><h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了</p><h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用</p><h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容</p><h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2.3XX (Redirection 重定向状态码)"></a>2.3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p><h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向：</strong>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址</p><p><strong>使用场景：</strong></p><ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个</li></ul><h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向：</strong> 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的</p><p><strong>使用场景：</strong></p><ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面</li><li>未登陆的用户访问用户中心重定向到登录页面</li><li>访问404页面重新定向到首页</li></ul><h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><ul><li>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源</li><li>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET</li></ul><p><strong>注意：</strong></p><ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做</li></ul><h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系</p><ul><li>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部</li><li>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能</li></ul><h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong> 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了</p><ul><li>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容</li></ul><h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3.4XX (Client Error 客户端错误状态码)"></a>3.4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在</p><h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码</p><h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><ul><li>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</li><li>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口</li></ul><p><strong>以下情况会出现401：</strong></p><ul><li>401.1 - 登录失败</li><li>401.2 - 服务器配置导致登录失败</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权</li><li>401.4 - 筛选器授权失败</li><li>401.5 - ISAPI&#x2F;CGI 应用程序授权失败</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用</li></ul><h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关</p><p><strong>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</strong></p><ul><li>403.1 - 执行访问被禁止</li><li>403.2 - 读访问被禁止</li><li>403.3 - 写访问被禁止</li><li>403.4 - 要求 SSL</li><li>403.5 - 要求 SSL 128</li><li>403.6 - IP 地址被拒绝</li><li>403.7 - 要求客户端证书</li><li>403.8 - 站点访问被拒绝</li><li>403.9 - 用户数过多</li><li>403.10 - 配置无效</li><li>403.11 - 密码更改</li><li>403.12 - 拒绝访问映射表</li><li>403.13 - 客户端证书被吊销</li><li>403.14 - 拒绝目录列表</li><li>403.15 - 超出客户端访问许可</li><li>403.16 - 客户端证书不受信任或无效</li><li>403.17 - 客户端证书已过期或尚未生效</li><li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用</li><li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用</li><li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用</li></ul><h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</p><p> <strong>以下情况会出现404：</strong></p><ul><li>404.0 -（无） – 没有找到文件或目录</li><li>404.1 - 无法在所请求的端口上访问 Web 站点</li><li>404.2 - Web 服务扩展锁定策略阻止本请求</li><li>404.3 - MIME 映射策略阻止本请求</li></ul><h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>: <span class="hljs-variable constant_">GET</span>,<span class="hljs-variable constant_">HEAD</span>,<span class="hljs-variable constant_">PUT</span>,<span class="hljs-variable constant_">PATCH</span>,<span class="hljs-variable constant_">POST</span>,<span class="hljs-variable constant_">DELETE</span><br></code></pre></td></tr></table></figure><h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4.5XX (Server Error 服务器错误状态码)"></a>4.5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p><h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障</p><h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p><ul><li>502.1 - CGI （通用网关接口）应用程序超时</li><li>502.2 - CGI （通用网关接口）应用程序出错</li></ul><h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端</p><p><strong>使用场景：</strong></p><ul><li>服务器停机维护时，主动用503响应请求</li><li>nginx 设置限速，超过限速，会返回503</li></ul><h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的</p><p><strong>使用场景：代码执行时间超时，或者发生了死循环</strong></p><h3 id="5-状态码总结"><a href="#5-状态码总结" class="headerlink" title="5.状态码总结"></a>5.状态码总结</h3><p><strong>（1）2XX 成功</strong></p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><p><strong>（2）3XX 重定向</strong></p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>（3）4XX 客户端错误</strong></p><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p><strong>（4）5XX 服务器错误</strong></p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6.同样是重定向，307，303，302的区别？"></a>6.同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get</p><h2 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1.对 WebSocket 的理解"></a>1.对 WebSocket 的理解</h3><ul><li>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输</li><li>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息</strong></li><li><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件</li></ul><p><strong>WebSocket 特点的如下：</strong></p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据‘’</li><li>建立在TCP协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li></ul><p><strong>Websocket的使用方法如下：</strong><br><strong>在客户端中：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br><span class="hljs-keyword">let</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:9999&#x27;</span>);<br><span class="hljs-comment">// 在客户端与服务端建立连接后触发</span><br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection open.&quot;</span>); <br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 在服务端给客户端发来消息的时候触发</span><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);       <span class="hljs-comment">// 打印的是MessageEvent对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 打印的是收到的消息</span><br>&#125;;<br><span class="hljs-comment">// 在客户端与服务端建立关闭后触发</span><br>ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection closed.&quot;</span>);<br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2.即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2.即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p><strong>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯</strong></p><ul><li><strong>短轮询的基本思路：</strong> 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的</li><li><strong>长轮询的基本思路：</strong> 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费</li><li><strong>SSE 的基本思想：</strong> 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源</li><li><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了<br><strong>上面的四个通信协议，前三个都是基于HTTP协议的</strong></li></ul><p>对于这四种即使通信协议，从性能的角度来看： <strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong> 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： <strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong> 所以，还是要根据具体的使用场景来判断使用哪种方式</p><h2 id="七、DNS协议介绍"><a href="#七、DNS协议介绍" class="headerlink" title="七、DNS协议介绍"></a>七、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1.DNS 协议是什么"></a>1.DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址</p><h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2.DNS同时使用TCP和UDP协议？"></a>2.DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议</strong></p><p>（1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多</li></ul><ul><li>TCP是一种可靠连接，保证了数据的准确性</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包</li></ul><h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3.DNS完整的查询过程"></a>3.DNS完整的查询过程</h3><p><strong>DNS服务器解析域名的过程：</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器<br>比如要查询 <a href="https://link.juejin.cn/?target=http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表</li></ul><h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4.迭代查询与递归查询"></a>4.迭代查询与递归查询</h3><p><strong>实际上，DNS解析是一个包含迭代查询和递归查询的过程</strong></p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。<br>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行</li></ul><h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5.DNS 记录和报文"></a>5.DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">（Name，Value，Type，TTL）<br></code></pre></td></tr></table></figure><p><strong>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间</strong></p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p><ul><li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射</li><li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息</li><li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名</li><li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点</li></ul><h2 id="八、网络层与数据链路层"><a href="#八、网络层与数据链路层" class="headerlink" title="八、网络层与数据链路层"></a>八、网络层与数据链路层</h2><h3 id="1-ARP协议的作用"><a href="#1-ARP协议的作用" class="headerlink" title="1.ARP协议的作用"></a>1.ARP协议的作用</h3><p><strong>网络层使用的是IP地址，数据链路层使用的是硬件地址。 ARP协议的用途是为了从网络层使用的IP地址，解析出数据链路层使用的硬件地址</strong></p><ul><li>在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表</li><li>当需要解析时，先去arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址</li><li>如果查到了，将目标ip的mac地址封装到链路层数据报</li><li>如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX，所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单播的形式将自己的mac地址回复给请求的机器</li></ul><h3 id="2-ping发生了什么"><a href="#2-ping发生了什么" class="headerlink" title="2.ping发生了什么"></a>2.ping发生了什么</h3><ul><li><p>ping主要是为了测试两台主机之间的连通性，通过应用层直接使用网络层ICMP，没有通过运输层TCP和UDP，是通过发送ICMP报文回显请求实现</p></li><li><p>A主机构建一个ICMP格式的数据包，通过ICMP协议把该数据包和B主机的IP地址一起交给IP协议</p></li><li><p>IP层构建一个数据包（A主机的IP地址+控制信息+B主机的IP地址），获得B主机的MAC地址，以便构建一个数据帧(IP协议会根据B主机的IP地址和自己的子网掩码判断是不是属于同一层网络,如果是属于同一层网络的话,就会获得B主机的MAC地址，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC)</p></li><li><p>主机B接受到主机A的发过来的数据帧以后，先检查该帧中包含的B的IP地址，并和本地的物理地址进行比对，如果符合的话，就接受，否则，就抛弃。同样，需要将该数据帧交由自己的IP层协议，IP层检查以后，再交由ICMP协议，构建一个ICMP的应答包，发送给主机A</p></li></ul><h3 id="3-traceroute发生了什么"><a href="#3-traceroute发生了什么" class="headerlink" title="3.traceroute发生了什么"></a>3.traceroute发生了什么</h3><p><strong>traceroute用来跟踪一个分组从源点到终点的路径，及到达其中每一个路由器的往返时间</strong></p><ul><li>通过发送UDP报文，设置目的端口为一个不可能的值</li><li>将IP首部中的TTL分别设置从1到N，每次逐个增加</li><li>每次设置TTL后，重新发送数据报，路由器接收到数据报后，将TTL减1，若当前的路由器接收到数据报，发现TTL为1时，会将TTL减1变为0，然后丢弃数据报，发送ICMP时间超过报文</li><li>如果最后一个数据报刚刚达到主机，数据报的TTL是1，此时主机不把TTL减1</li><li>因IP数据报中封装的是无法交付的UDP数据报，此时目的主机向源主机发送ICMP终点不可达差错报文，表示达到目的主机</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux面经-个人总结</title>
    <link href="/2022/07/09/Linux%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/09/Linux%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、OS基础"><a href="#一、OS基础" class="headerlink" title="一、OS基础"></a>一、OS基础</h2><h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1.硬件结构"></a>1.硬件结构</h2><h2 id="2-操作系统结构"><a href="#2-操作系统结构" class="headerlink" title="2.操作系统结构"></a>2.<strong>操作系统结构</strong></h2><h3 id="2-1用户态和内核态"><a href="#2-1用户态和内核态" class="headerlink" title="2.1用户态和内核态"></a>2.1用户态和内核态</h3><ul><li><strong>概念</strong><ul><li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同</li><li>用户态拥有最低的特权级，内核态拥有较高的特权级</li><li>运行在用户态的程序不能直接访问操作系统内核数据结构和程序</li><li>操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的<ul><li>分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性</li><li>分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统</li></ul></li></ul></li><li><strong>用户态和内核态可以通过指针传递数据吗？</strong><ul><li><strong>用户态不能访问内核态的指针</strong><ul><li>为了实现内存的保护，防止越界访问而造成受保护内存的被非法修改，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的</li></ul></li><li><strong>内核态可以访问用户态的指针(有前提)</strong><ul><li>必须保证用户态虚拟空间的指针（虚拟空间的地址），已经分配物理地址，否则指针传入内核态中将不会引发缺页异常而报错</li></ul></li><li><strong>内核中访问用户进程的地址的时候用copy_from_user，而不是用memcpy直接拷贝(或者说使用用户态指针)</strong><ul><li><strong>copy_from_user主要是这个函数提供了两个功能</strong><ul><li>对用户进程传过来的地址范围进行合法性检查</li><li>当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行</li><li>对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表。这个过程对于用户进程是完全透明的。但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误</li></ul></li><li><strong>直接使用memcpy时为什么没有出现异常</strong><ul><li>只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常</li></ul></li></ul></li></ul></li><li><strong>两种状态转换</strong><ul><li><strong>系统调用</strong><ul><li>用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作</li></ul></li><li><strong>异常</strong><ul><li>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常</li></ul></li><li><strong>外围设备中断</strong><ul><li>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序</li><li>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</li></ul></li></ul></li></ul><h3 id="2-2库函数和系统调用的区别"><a href="#2-2库函数和系统调用的区别" class="headerlink" title="2.2库函数和系统调用的区别"></a>2.2库函数和系统调用的区别</h3><ul><li><strong>概念</strong><ul><li>库函数调用是语言或应用程序的一部分，而系统调用是操作系统的一部分，<strong>跨平台技术的原理就是通过库函数实现的，库函数可以理解为是对系统调用的一层封装，但库函数不是必须包含系统调用</strong></li><li>库函数有可能包含有一个系统调用，有可能有好几个系统调用，当然也有可能没有系统调用，比如有些操作不需要涉及内核的功能</li></ul></li><li><strong>区别</strong><ul><li>所有 C 函数库是相同的，而各个操作系统的系统调用是不同的</li><li>函数库调用是调用函数库中的一个程序，而系统调用是调用系统内核的服务</li><li>函数库调用是与用户程序相联系，而系统调用是操作系统的一个进入点</li><li>函数库调用是在用户地址空间执行，而系统调用是在内核地址空间执行</li><li>函数库调用的运行时间属于「用户」时间，而系统调用的运行时间属于「系统」时间</li><li>函数库调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大</li><li>在C函数库libc中大约 300 个程序，在 UNIX 中大约有 90 个系统调用</li><li>函数库典型的 C 函数：system, fprintf, malloc，而典型的系统调用：chdir, fork, write, brk</li></ul></li><li><strong>为什么不直接用函数调用</strong><ul><li>因为读写文件通常是大量的数据（相对于底层驱动的系统调用所实现的数据操作单位），这时，使用库函数可以大大减少系统调用的次数。这是因为<strong>缓冲区技术</strong>，<strong>在用户空间和内核空间对文件操作都使用了缓冲区。当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓存区</strong>。同理，内核缓冲区满或写结束时，才将内核缓冲区内容写到文件对应的硬件媒介</li><li><strong>为了保证可移植性，现有跨平台技术就是通过库函数调用实现的</strong>，不使用系统函数调用。Qt各个操作系统都有特定的宏，然后代码里面根据不同的宏调用不同平台的API</li></ul></li><li><strong>库函数的缓冲区</strong><ul><li><p>对于库函数，如果标准输出连到终端设备(直接输出到屏幕)，则它是行缓冲的（遇到回车换行符或者是缓冲区满了才输出）；否则（输出到文件）是全缓冲的（缓冲区填满或者是程序运行结束了才输出）</p></li><li><p>程序运行结束时，会刷新所有的缓冲区<br>由于上面的缓冲机制，也给我们编写程序时带来了一些奇怪的问题。解决办法有如下两种：</p></li><li><p>任何时候我们都可以使用fflush(stdout)来刷新标准输出缓冲区</p></li><li><p>使用不带缓冲的系统调用write替代printf输出</p></li></ul></li><li><strong>系统调用底层原理</strong><ul><li>每个系统调用函数都有一个系统调用号</li><li>首先找到系统调用对应的中断号（Linux下是int 0x80），然后在中断向量表中找到对应的中断处理函数，再根据系统调用号，在中断处理函数找到对应系统调用函数进行执行</li></ul></li></ul><h3 id="2-3计算密集任务和IO密集任务"><a href="#2-3计算密集任务和IO密集任务" class="headerlink" title="2.3计算密集任务和IO密集任务"></a>2.3计算密集任务和IO密集任务</h3><ul><li><strong>计算密集型任务</strong><ul><li>特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力</li><li>虽然可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数</li></ul></li><li><strong>IO密集型任务</strong><ul><li>涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）</li><li>对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用</li></ul></li></ul><h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h2><h3 id="3-1程序的局部性原理"><a href="#3-1程序的局部性原理" class="headerlink" title="3.1程序的局部性原理"></a>3.1程序的局部性原理</h3><ul><li><p><strong>基本概念</strong><br>程序倾向于引用临近于其他最近引用过的数据项的数据项，或最近引用过的数据项本身，这种倾向性被称为局部性原理</p><ul><li><strong>时间局部性</strong><ul><li>良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用</li></ul></li><li><strong>空间局部性</strong><ul><li>良好空间局部性的程序中，一个内存位置被引用，程序很可能在不远的将来引用其附近的一个内存位置</li></ul></li></ul></li><li><p><strong>从硬件和操作系统层面看如何利用局部性</strong></p><ul><li><strong>硬件层</strong><ul><li>局部性原理允许硬件引入高速缓存存储器这种小而快速的存储器来存储最近被引用的指令和数据，从而提高对主存的访问速度</li></ul></li><li><strong>操作系统</strong><ul><li>允许系统使用主存作为虚拟地址空间作为最近被引用块的高速缓存</li></ul></li></ul></li><li><p><strong>从存储结构看如何利用局部性</strong><br>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存</p><ul><li><strong>时间局部性</strong><ul><li>同一数据对象可能被多次使用。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中的快很多</li></ul></li><li><strong>空间局部性</strong><ul><li>块通常包含多个数据对象。我们会期望后面对该块中其他对象的访问能补偿不命中后复制该块的花费</li></ul></li></ul></li></ul><h3 id="3-2存储器层次结构"><a href="#3-2存储器层次结构" class="headerlink" title="3.2存储器层次结构"></a>3.2存储器层次结构</h3><ul><li><p><strong>层次结构</strong><br>本地磁盘 -&gt; 主存(DRAM) -&gt; L3高速缓存(SRAM) -&gt; L2高速缓存(SRAM) -&gt; L1高速缓存(SRAM) -&gt; L0寄存器</p></li><li><p><strong>缓存思想</strong></p><ul><li>位于K层的更快更小的存储设备作为位于K+1层更大更慢的存储设备的缓存</li><li>K+1层的存储器被划分成连续的数据对象组块，称为块，数据总是以块大小为传送单元在K和K+1层之间来回复制</li></ul></li><li><p><strong>缓存命中</strong></p><ul><li>当程序需要K+1层的某个数据对象d时，首先在当前存储在K层的块中查找d，若d刚好缓存在k层中，则称为缓存命中</li><li>若缓存不命中，则需要将K+1层中包含对象d的块缓存到K层中，若K层中满了，则需要替换现存的一个块</li></ul></li></ul><h3 id="3-3虚拟内存页表寻址"><a href="#3-3虚拟内存页表寻址" class="headerlink" title="3.3虚拟内存页表寻址"></a>3.3虚拟内存页表寻址</h3><ul><li><strong>什么是虚拟内存</strong><ul><li>为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存，防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存</li><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存</strong>，也<strong>不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令</li><li>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</li></ul></li><li><strong>虚拟内存的好处</strong><ul><li><strong>可以更加高效的使用物理内存</strong><ul><li>虚拟地址空间一开始并没有真正的对应物理地址，而是在真正使用的时候才去对应</li><li>通过虚拟内存置换算法在访问后边的地址空间的时候就可以将前边当前没有在访问的物理页释放掉，或者交换到硬盘中。这样这个物理页又可以去对应新的虚拟地址。从而使物理内存可以充分的利用</li></ul></li><li><strong>内存管理</strong><ul><li>为每个进程提供了一致的地址空间，简化内存管理</li></ul></li><li><strong>内存保护</strong><ul><li>在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提高了系统的封装性</li><li>保护了每个进程的地址空间不被其他进程破坏</li></ul></li></ul></li><li><strong>虚拟内存页表寻址</strong><ul><li><p><strong>分页</strong><br>虚拟内存分割成虚拟页，物理内存被分割成物理页，用来作为磁盘和主存的传输单元。 虚拟页分为三个不相交的子集</p><ul><li>未分配的，不占磁盘空间</li><li>缓存的，当前已缓存在物理内存中的已分配页，在页表中标志位为1</li><li>未缓存的，未缓存在物理内存中的已分配页，在页表中标志位为0</li></ul></li><li><p><strong>页表</strong></p><ul><li>内存管理单元（MMU，属于硬件）管理着地址空间和物理内存的转换，操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，存储着程序地址空间到物理内存空间的映射表</li><li>页表存放在物理内存中，物理页存放在物理内存中，虚拟页存放在磁盘上</li></ul></li><li><p><strong>页表寻址</strong></p><ul><li>一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量</li><li>页表分为序号、页基地址、标志位</li><li>访问虚拟地址，先通过页表查询页面号，查看标志位确认虚拟地址是否在物理内存中有缓存，然后由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移虚拟地址中的偏移量就得到最后的物理地址</li><li>一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间</li></ul></li></ul></li><li><strong>缺页中断</strong><ul><li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存</li><li><strong>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</strong><ul><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ul></li><li><strong>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</strong><ul><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</li></ul></li></ul></li></ul><h2 id="4-进程与线程"><a href="#4-进程与线程" class="headerlink" title="4.进程与线程"></a>4.进程与线程</h2><h3 id="4-1单核CPU-x2F-多核CPU-x2F-多CPU"><a href="#4-1单核CPU-x2F-多核CPU-x2F-多CPU" class="headerlink" title="4.1单核CPU&#x2F;多核CPU&#x2F;多CPU"></a>4.1单核CPU&#x2F;多核CPU&#x2F;多CPU</h3><ul><li><p><strong>概述</strong></p><ul><li>单核CPU<ul><li><p>一个CPU中只有一个核心处理器</p></li><li><p>多核CPU</p><ul><li>一个CPU有多个核心处理器，处理器之间通过<strong>CPU内部总线</strong>进行通讯</li></ul></li></ul></li><li>多CPU<ul><li>简单的多个CPU工作在同一个系统上，多个CPU之间通过<strong>主板上的总线</strong>进行通讯</li></ul></li></ul></li><li><p><strong>深入理解进程和线程</strong></p><ul><li>进程的调度和资源分配是操作系统负责</li><li>线程的调度和资源分配是CPU负责</li><li>进程是操作系统资源分配(包括cpu、内存、磁盘IO等)的基本单位，一个CPU同时刻只能执行一个进程<ul><li><strong>单核CPU实现多进程，并发：</strong>通过操作系统的进程调度算法，单核CPU进行进程调度的时候，需要读取上下文+执行程序+保存上下文，即进程切换</li><li><strong>多CPU实现多进程，并行：</strong>不同的进程运行在不同的CPU上</li></ul></li><li>线程是CPU调度和资源分配的基本单位，一个CPU核心同时刻只能执行一个线程<ul><li><strong>单核CPU实现多线程，并发：</strong>不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，这个线程切换比进程切换开销少很多</li><li><strong>多核CPU实现多线程，并行：</strong>CPU可以将不同线程分配到不同的CPU核心处理器中</li></ul></li></ul></li></ul><ul><li>单CPU中进程只能是并发，多CPU计算机中进程可以并行</li><li>单CPU单核中线程只能并发，单CPU多核中线程可以并行</li><li>并行有上限，进程与CPU个数，线程与CPU核心个数有关，并不是所有线程和所有进程都能同时运行</li></ul><h3 id="4-2进程与PCB"><a href="#4-2进程与PCB" class="headerlink" title="4.2进程与PCB"></a>4.2进程与PCB</h3><ul><li><strong>进程</strong><ul><li>进程是操作系统的资源分配单位，实现操作系统的并发，对于一个进程，它在被执行前其实是一个可执行程序。这个程序是被放在磁盘上的，当它要被执行的时候，它先被加载到内存当中，然后再放入到寄存器中，最后再让cpu执行该程序，这个时候一个静态的程序就变成了进程</li><li>进程创建时会分配4G的内存，其中0-3G是用户空间，3-4G是内核空间，PCB存在于内核空间</li><li>进程的用户空间是不同的，内核空间也是不同的。比如每个进程的不同系统调用，是陷入自己独立的内核空间里面，所以每个进程内核的堆栈肯定是不一样的</li></ul></li><li><strong>PCB</strong><ul><li>每个进程的PCB都是存在所有进程共享的内核空间中，操作系统管理进程，也就是在内核空间中管理的，在内核空间中通过链表管理所有进程的PCB，如果有一个进程要被创建，实际上多分配了这么一个4G的虚拟内存，并在共享的内核空间中的双向链表中加入了自己的PCB</li><li>PCB(Process Control Block)进程控制块，描述进程的基本信息和运行状态，<strong>进程的创建和销毁都是对PCB进行操作</strong>，PCB的具体内容如下：<ul><li><strong>标识相关：</strong>pid，ppid等等</li><li><strong>文件相关：</strong>进程需要记录打开的文件信息，于是需要文件描述符表</li><li><strong>内存相关：</strong>内存指针，指向进程的虚拟地址空间（用户空间）信息</li><li><strong>优先级相关：</strong>进程相对于其他进程的调度优先级</li><li><strong>上下文信息相关：</strong>CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行</li><li><strong>状态相关：</strong>进程当前的状态，说明该进程处于什么状态</li><li><strong>信号相关：</strong>进程的信号处理函数，以及记录当前进程是否还有待处理的信号</li><li><strong>I&#x2F;O相关：</strong>记录进程与各种I&#x2F;O设备之间的交互</li></ul></li><li>每个进程的内核空间中都有PCB，但真正的PCB是存储在物理内存上的，当进程创建和销毁时，会由操作系统操作PCB，每个进程只是虚拟地址空间，并不会存储实际数据，数据存储在物理内存中，只有一份</li></ul></li></ul><h3 id="4-3进程间通信"><a href="#4-3进程间通信" class="headerlink" title="4.3进程间通信"></a>4.3进程间通信</h3><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号、共享内存等）、本地套接字socket</p><ul><li><strong>管道(缓冲区有限)</strong><ul><li><strong>无名管道PIPE</strong><ul><li>一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程或兄弟进程）</li></ul></li><li><strong>有名管道FIFO</strong><ul><li>一种半双工的通信方式，可以在非亲缘关系的进程间使用</li></ul></li></ul></li><li><strong>消息队列</strong><ul><li>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识</li><li>消息队列克服了信号传递信息少，管道缓冲区大小受限的缺点</li><li>一个消息队列由一个标识符（即队列ID）来标记</li></ul></li><li><strong>信号</strong><ul><li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li></ul></li><li><strong>共享内存</strong><ul><li>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。多个进程可以同时操作，所以需要进行同步 ，一般与信号量配合使用</li><li><strong>不同进程访问共享内存</strong><ul><li>shm<ul><li>不同进程通过shmget-&gt;shmat函数，将共享内存连接到自己的虚拟内存地址</li></ul></li><li>mmap<ul><li>不同进程通过mmap函数创建映射区，将自己的内存虚拟地址映射到磁盘的文件上</li></ul></li></ul></li><li><strong>shm</strong><ul><li><strong>原理</strong></li><li>多个进程的地址空间映射到同一个物理内存，不同进程可以将同一段共享的内存连接到自己的地址空间中，从而所有进程都可以访问共享内存中的地址</li><li><strong>API</strong><ul><li><code>int shmget(key_t key, size_t size, int shmflg);</code><ul><li>在物理内存创建一个共享内存，返回共享内存的编号</li><li>key是一个非0整数，命名共享内存段，运行成功返回一个与key相关的共享内存标识符</li><li>size表示以字节为单位指定需要的共享内存的容量</li><li>shmflag是权限标志位，与open的mode参数一致，若key标识的共享内存不存在，通过0666|IPC_CREAT来创建，并设置权限</li></ul></li><li><code>void *shmat(int shmid, const void shmaddr,int shmflg);</code><ul><li>连接成功后把共享内存区对象映射到调用进程的地址空间，函数返回各个进程挂接的虚拟的地址空间</li><li>shmid是挂接的进程号，</li><li>shmaddr置为NULL，让系统选择一个合适的地址空间进行挂接</li><li>shmflg表示什么方式进行挂接，一般都是取0</li></ul></li><li><code>void *shmdt(const void* shmaddr);</code><ul><li>将共享内存从当前进程中分离，断开用户级页表到共享内存的那根箭头</li></ul></li><li><code>int shmctl(int shmid, int cmd, struct shmid_ds* buf);</code><ul><li>释放物理内存中的那块共享内存</li><li>cmd取IPC_RMID表示删除这块共享内存</li></ul></li></ul></li></ul></li><li><strong>mmap</strong><ul><li><strong>原理</strong><ul><li>mmap是映射磁盘上的一个文件，每个进程在自己的逻辑地址空间中开辟一块空间对磁盘上的文件进行映射</li><li>内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存</li><li>mmap返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，建立内存映射并没有实际拷贝数据，这时，将产生一个缺页中断，会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中</li></ul></li><li><strong>效率</strong><ul><li>read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了两次数据拷贝</li><li>mmap()也是系统调用，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝</li></ul></li><li><strong>映射文件</strong><ul><li>普通文件<ul><li>open系统调用打开一个文件，然后进行mmap操作，得到共享内存，这种方式适用于任何进程之间</li></ul></li><li>匿名映射<ul><li>调用 mmap 时，在参数 flags 中指定 MAP_ANONYMOUS 标志位，并且将参数 fd 指定为 -1 ,用于父子进程之间</li></ul></li></ul></li></ul></li><li><strong>程序异常退出，共享内存会释放么？</strong><ul><li>不会<ul><li>Linux中通过API函数shmget创建的共享内存一般都是在程序中使用shmctl来释放的，但是有时为了调试程序，开发人员可能通过Ctrl + C等方式发送中断信号来结束程序，此时程序申请的共享内存就不能得到释放，当然如果程序没有改动的话，重新运行程序时仍然会使用上次申请的共享内存，但是如果我们修改了程序，由于共享内存的大小不一致等原因会导致程序申请共享内存错误</li></ul></li><li>如何释放<ul><li>如果总是通过Crtl+C来结束的话，可以做一个信号处理器，当接收到这个信号的时候，先释放共享内存，然后退出程序</li><li>不管你以什么方式结束程序，如果共享内存还是得不到释放，那么可以通过linux命令ipcrm shm shmid来释放，在使用该命令之前可以通过ipcs -m命令来查看共享内存</li></ul></li></ul></li><li><strong>两者的区别</strong><ul><li><strong>作用</strong><ul><li>mmap系统调用并不完全是为了共享内存来设计的，它本身提供了不同于一般对普通文件的访问的方式，进程可以像读写内存一样对普通文件进行操作</li><li>IPC的共享内存shm是纯粹为了共享</li></ul></li><li><strong>映射位置</strong><ul><li>mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间对磁盘上的文件进行映射</li><li>shm每个进程映射到同一块物理内存，shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大</li></ul></li><li><strong>内容丢失</strong><ul><li>进程挂了重启不丢失内容，二者都可以做到</li><li>机器挂了重启，mmap把文件存在磁盘上，可以不丢失内容（文件内保存了OS同步过的映像），而 shmget 会丢失</li></ul></li></ul></li></ul></li><li><strong>套接字</strong><ul><li>本地套接字用于本机不同进程间通信，另外普通套接字可以用于不同主机间的进程间通信</li></ul></li></ul><h3 id="4-4fork、vfork、clone"><a href="#4-4fork、vfork、clone" class="headerlink" title="4.4fork、vfork、clone"></a>4.4fork、vfork、clone</h3><p><strong>fork、v_fork、clone底层都是do_fork，追踪发现底层使用的是sys_clone</strong></p><ul><li><strong>fork</strong><ul><li>父进程fork之后创建子进程，子进程复制父进程的所有资源，子进程的代码段、数据段、堆栈都是指向父进程的物理空间，但此时仅仅是子进程的虚拟地址空间和父进程指向的物理地址空间建立了映射关系，并没有真正复制</li><li>由于fork()后会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，处于效率考虑，linux中引入了“写时复制技术-Copy-On-Write”</li><li>若两个进程一直只是读数据，则子进程一直不会复制，直到任一进程进行写操作</li><li>父进程和子进程执行顺序没有规定，可以乱序执行</li><li>读时共享，写时复制</li></ul></li><li><strong>vfork</strong><ul><li>vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。</li><li>规定必须子进程先执行</li><li>严格意义上讲，vfork产生的不叫进程，因为他没有独立的地址空间，和父进程共享同一个</li></ul></li></ul><h3 id="4-5僵尸进程和孤儿进程"><a href="#4-5僵尸进程和孤儿进程" class="headerlink" title="4.5僵尸进程和孤儿进程"></a>4.5僵尸进程和孤儿进程</h3><ul><li>当父进程先结束，子进程此时就会变成孤儿进程，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素</li><li>如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，回收进程资源，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程<ul><li><strong>僵尸进程是每个子进程退出时必然经历的过程</strong></li><li><strong>僵尸进程的危害</strong><ul><li>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait &#x2F; waitpid来取时才释放</li><li>如果进程不调用wait &#x2F; waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</li></ul></li><li><strong>如何消除僵尸进程</strong><ul><li>kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管</li><li>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程</li></ul></li></ul></li></ul><h3 id="4-6进程退出方式及区别"><a href="#4-6进程退出方式及区别" class="headerlink" title="4.6进程退出方式及区别"></a>4.6进程退出方式及区别</h3><p>不管哪种退出方式，系统最终都会执行内核的同一代码，这段代码用来关闭进程打开的文件描述符，释放它占用的内存和其他资源</p><ul><li><strong>退出</strong><ul><li><strong>正常退出</strong><ul><li>main函数调用return</li><li>调用exit()函数</li><li>调用_exit()函数</li></ul></li><li>**异常退出 **<ul><li>调用abort函数</li><li>进程收到某个信号，该信号使程序终止</li></ul></li></ul></li><li><strong>已结束进程的状态</strong><ul><li>shell执行 echo $?，保存最近一次运行的进程的返回值<ul><li>程序中main函数运行结束，保存main函数的返回值</li><li>程序调用exit函数结束运行，保存exit函数的参数</li><li>程序异常退出，保存异常出错的错误号</li></ul></li></ul></li><li><strong>区别</strong><ul><li><strong>exit和return的区别</strong><ul><li>exit是函数，有参数，exit执行完会把控制权交给系统，exit(0)表示正常终止，其他值表示有错误发生</li><li>return是函数执行完后的返回，return执行完后把控制权交给调用函数</li></ul></li><li><strong>exit和abort的区别</strong><ul><li>exit是正常终止进程</li><li>abort是异常终止进程</li></ul></li><li><strong>exit和_exit函数的区别</strong><ul><li>exit在头文件stdlib.h中声明，_exit是在头文件unistd.h中声明</li><li>exit是_exit之上的一个封装，exit先刷新流数据，再调用_exit函数<ul><li>_exit会关闭进程打开的文件描述符，清理内存，不会刷新流数据</li><li>linux的库函数，有一种“缓冲IO”的操作，对应每一个打开的文件，在内存中有一片缓冲区，每次读文件，会连续读出若干条记录，下次再读文件的时候，直接从内存的缓冲区中读；同样写文件也是先写入缓冲区，满足一定条件才将缓冲区的内容一次性写入文件。具体可以看printf和write的区别，及行缓冲和全缓冲</li><li>exit先刷新流数据，将文件缓冲区的内容写回文件，可以保证数据的完整性，_exit会将数据直接丢失</li></ul></li></ul></li></ul></li></ul><h3 id="4-7回收进程资源的方式和区别"><a href="#4-7回收进程资源的方式和区别" class="headerlink" title="4.7回收进程资源的方式和区别"></a>4.7回收进程资源的方式和区别</h3><ul><li><strong>init进程（进程号为1）会周期性的调用wait系统调用来清除各个僵尸进程</strong></li><li><strong>wait</strong><ul><li><code>pid_t wait (int *status)</code> status表示子进程的退出状态，成功返回值为子进程进程号，失败为-1</li><li>进程一旦调用wait函数，立即阻塞自己， 判断当前进程的某个子进程是否变成僵尸进程<ul><li>若存在则收集子进程的信息，将它彻底销毁然后返回</li><li>若没有，则会一直阻塞，直到出现一个</li></ul></li></ul></li><li><strong>waitpid</strong><ul><li>waitpid相当于wait函数的封装，多了两个由用户控制的参数pid和options，可以自定义回收的子进程进程号，并设置是否阻塞</li><li><code>pid_t waitpid(pid_t pid, int * status, int options)</code></li><li>pid<ul><li>pid &lt; -1，等待进程组ID为pid绝对值的任何子进程</li><li>pid &#x3D; -1，等待任何子进程，相当于wait</li><li>pid &#x3D; 0，等待进程组ID与目前进程相同的任何子进程</li><li>pid &gt; 0，等待子进程ID为pid的进程</li></ul></li><li>options<ul><li>0，与wait相同，也会阻塞</li><li>WNOHANG，不会阻塞，如果当前没有可回收的子进程，立即返回0</li></ul></li></ul></li></ul><h3 id="4-8线程间同步及系统调用"><a href="#4-8线程间同步及系统调用" class="headerlink" title="4.8线程间同步及系统调用"></a>4.8线程间同步及系统调用</h3><ul><li><p><strong>信号量</strong><br>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p><ul><li>P(SV)：如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程</li><li>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1</li><li><strong>系统调用</strong>：<ul><li>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值</li><li>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒</li></ul></li></ul></li><li><p><strong>互斥量</strong><br>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区 时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程</p><ul><li><strong>系统调用：</strong><ul><li>pthread_mutex_init:初始化互斥锁</li><li>pthread_mutex_destroy：销毁互斥锁</li><li>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁</li><li>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁</li></ul></li></ul></li><li><p><strong>条件变量</strong><br>条件变量，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个&#x2F;多个线程。即，当某个共享变量等于某个值时，调用 signal&#x2F;broadcast。此时操作共享变量时需要加锁</p><ul><li><strong>系统调用：</strong><ul><li>pthread_cond_init:初始化条件变量</li><li>pthread_cond_destroy：销毁条件变量</li><li>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级</li><li>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问</li></ul></li></ul></li></ul><h3 id="4-9线程退出方式与线程回收"><a href="#4-9线程退出方式与线程回收" class="headerlink" title="4.9线程退出方式与线程回收"></a>4.9线程退出方式与线程回收</h3><ul><li><p>线程退出方式</p><p>注意：不能使用exit，exit表示退出整个进程</p><ul><li><p>pthread_exit</p><ul><li><p><code>int pthread_exit(void *retval);</code></p></li><li><p>在任何线程中使用，使该线程直接退出</p></li><li><p>主线程退出而不影响其他线程，只能使用这种方式</p></li></ul></li><li><p>return</p><ul><li>子线程中可以使用，主线程不能使用，主线程代表退出整个进程</li></ul></li></ul></li><li><p>线程回收</p><ul><li>pthread_join<ul><li><code>int pthread_join(pthread_t thread, void **retval)</code></li><li>用来等待一个线程的结束，并回收该线程的资源</li><li>一般是主线程调用，用来等待子线程退出，是阻塞的</li></ul></li></ul></li><li><p>线程分离</p><ul><li>pthread_detach<ul><li><code>int pthread_detach(pthread_t thread)</code></li><li>分离已经创建的线程，将主线程与子线程分离，子线程结束后，资源自动回收。</li><li>状态分离后，该线程的结束状态不能被该进程中的其他线程得到，因此pthread_join不能调用，否则会出错</li></ul></li></ul></li></ul><h3 id="4-10说一下LINUX系统中的锁"><a href="#4-10说一下LINUX系统中的锁" class="headerlink" title="4.10说一下LINUX系统中的锁"></a>4.10说一下LINUX系统中的锁</h3><ul><li><strong>互斥锁：</strong>mutex，用于保证在任何时刻，都只能有一个线程访问该对象。<strong>当获取锁操作失败时，线程会进入睡眠</strong>，等待锁释放时被唤醒</li><li><strong>读写锁：rwlock，分为读锁和写锁</strong>。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它<strong>获取写锁失败的线程都会进入睡眠状态</strong>，直到写锁释放时被唤醒。 <ul><li><strong>注意：</strong>写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合</li></ul></li><li><strong>自旋锁：</strong>spinlock，在任何时刻同样只能有一个线程访问对象。但是<strong>当获取锁操作失败时，不会进入睡眠，而是会在原地自旋</strong>，循环检测锁的保持者是否释放，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源</li></ul><h3 id="4-11线程间共享和私有资源"><a href="#4-11线程间共享和私有资源" class="headerlink" title="4.11线程间共享和私有资源"></a>4.11线程间共享和私有资源</h3><ul><li><strong>私有：线程栈，寄存器，程序寄存器</strong>，线程ID，错误返回码，信号屏蔽字，调度优先级</li><li><strong>共享：</strong>文件描述符表，堆，地址空间，全局变量，静态变量，进程代码段，进程的当前目录和进程用户ID与进程组ID</li></ul><h3 id="4-12进程与线程的区别"><a href="#4-12进程与线程的区别" class="headerlink" title="4.12进程与线程的区别"></a>4.12进程与线程的区别</h3><ul><li><p><strong>概述</strong></p><ul><li>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位</li><li>进程有独立的系统资源或地址空间，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如线程Id,栈、寄存器、程序计数器PC(或者说IP)</li><li>一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也宕掉</li><li>进程在创建、销毁时开销比较大，而线程比较小。进程创建的时候需要分配虚拟地址空间等系统资源，而销毁的的时候需要释放系统资源；线程只需要创建栈，栈指针，程序计数器，通用目的寄存器和条件码等，不需要创建独立的虚拟地址空间</li><li>进程切换开销比较打，线程比较小。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB</li><li>进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易</li></ul></li></ul><ul><li><p><strong>TLB</strong><br>TLB( Translation Look- aside buffer)专门用于缓存内存中的页表项,一般在MMU单元内部，页表一般存储在屋里内存中。当处理器要访问一个虚拟地址时,首先会在TLB中查询。如果TLB表项中没有相应的表项,称为TLB Miss,那么就需要访问页表来计算出相应的物理地址。如果TLB表项中有相应的表项,那么直接从TLB表项中获取物理地址,称为TLB命中</p></li><li><p><strong>程序计数器PC和指令指针寄存器IP</strong></p><ul><li><strong>程序计数器PC</strong><ul><li>用指令事先编好的程序连续存放在内存程序区中，靠地址+1的方法连续取指执行”。在八位机8080CPU中是采用先取指后执行的串行操作的原理，而其中执行地址+1指令寻址的部件就是程序计数器PC。那么在程序的执行过程中，PC始终是指向下一条要执行的指令</li><li><strong>结论：</strong>PC中的地址就是需要转移、循环、调用子程序和中断子程序等操作时的断点</li></ul></li><li><strong>指令指针寄存器IP</strong><ul><li>在向上兼容的十六位机8086CPU中首先分为两个功能部件，即总线接口部件BIU和执行部件EU，BIU负责取指令，EU负责译码执行。并且当BIU执行指令排队栈中的六个字节装满后，（8088CPU是4个字节），EU开始从指令排队栈的出栈口，取指令进行译码执行，同时BIU并行操作向入栈口补充一条取指令命令</li><li>指令指针IP则是指向下个条要取指的指令，而不是EU要执行的指令。而断点则应该是要执行的指令内存地址，而不是IP内的下一条要取指的指令地址</li></ul></li><li><strong>PC是模型机中的概念，IP是实际使用的，调试时我们发现，IP实现的就是PC的功能</strong></li></ul></li><li><p><strong>为什么有了进程还需要线程？</strong></p><ul><li><strong>优点</strong><ul><li>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量</li></ul></li><li><strong>缺点</strong><ul><li>进程在同一时间只能干一件事</li><li>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行</li></ul></li><li><strong>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性</strong></li></ul></li></ul><h2 id="5-调度算法"><a href="#5-调度算法" class="headerlink" title="5.调度算法"></a>5.调度算法</h2><h3 id="5-1进程调度算法"><a href="#5-1进程调度算法" class="headerlink" title="5.1进程调度算法"></a>5.1进程调度算法</h3><ul><li><p><strong>批处理系统</strong><br>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p><ul><li><strong>先来先服务 first-come first-serverd（FCFS）</strong><ul><li>非抢占式的调度算法，按照请求的顺序进行调度</li><li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li></ul></li><li><strong>短作业优先 shortest job first（SJF）</strong><ul><li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li><li>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li></ul></li><li><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度</li><li>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待</li></ul></li></ul></li><li><p><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应</p><ul><li><strong>时间片轮转</strong><ul><li>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片</li><li>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</li></ul></li><li><strong>优先级调度</strong><ul><li>为每个进程分配一个优先级，按优先级进行调度</li><li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</li></ul></li><li><strong>多级反馈队列</strong><ul><li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次</li><li>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次</li><li>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程</li><li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li></ul></li></ul></li><li><p><strong>实时系统</strong></p><ul><li>实时系统要求一个请求在一个确定时间内得到响应</li><li>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时</li></ul></li><li><p><strong>进程调度时机</strong></p><ul><li>进程状态转换的时刻：进程终止、进程睡眠</li><li>当前进程的时间片用完时（current-&gt;counter&#x3D;0）</li><li>设备驱动程序</li><li>进程从中断、异常及系统调用返回到用户态时</li></ul></li></ul><h3 id="5-2虚拟内存置换算法"><a href="#5-2虚拟内存置换算法" class="headerlink" title="5.2虚拟内存置换算法"></a>5.2虚拟内存置换算法</h3><ul><li>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换</li><li>当前操作系统最常采用的缺页置换算法如下：<ul><li><strong>先进先出(FIFO)算法：</strong>置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除</li><li><strong>最近最少使用（LRU）算法：</strong>置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问</li><li>当前最常采用的就是LRU算法</li></ul></li></ul><h2 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6.文件系统"></a>6.文件系统</h2><h2 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7.设备管理"></a>7.设备管理</h2><h2 id="8-网络系统"><a href="#8-网络系统" class="headerlink" title="8.网络系统"></a>8.网络系统</h2><h1 id="二、Linux网络编程"><a href="#二、Linux网络编程" class="headerlink" title="二、Linux网络编程"></a>二、Linux网络编程</h1><h2 id="1-网络编程步骤"><a href="#1-网络编程步骤" class="headerlink" title="1.网络编程步骤"></a>1.网络编程步骤</h2><ul><li><strong>TCP</strong><ul><li><strong>服务端：</strong>socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv&#x2F;send-&gt;close<ul><li>创建一个socket，用函数socket()，设置SOCK_STREAM</li><li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构</li><li>bind()函数绑定服务器IP地址、端口等信息到socket上</li><li>listen()函数设置允许的最大连接数</li><li>accept()函数接收客户端上来的连接</li><li>send()&#x2F;recv()或read()&#x2F;write()函数收发数据</li><li>close()关闭网络连接，需要关闭服务器sock和accpet产生的客户端sock描述符</li></ul></li><li><strong>客户端：socket-&gt;connect-&gt;send&#x2F;recv-&gt;close</strong><ul><li>创建一个socket，用函数socket()</li><li>设置要连接的对方的IP地址和端口等属性</li><li>连接服务器，用函数connect()</li><li>收发数据，用函数send()和recv()，或read()和write()</li><li>关闭网络连接close()</li></ul></li><li><strong>注意：</strong><ul><li>INADDR_ANY表示本机任意地址，一般服务器端都可以这样写</li><li>accept中接收的是客户端的地址，返回对应当前客户端的一个clisock文件描述符，表示当前客户端的tcp连接</li><li>send和recv中接收的是新建立的客户端的sock地址</li></ul></li></ul></li><li><strong>UDP</strong><ul><li><strong>服务端：</strong>socket -&gt; bind -&gt; recvfrom&#x2F;sendto -&gt; close<ul><li>建立套接字文件描述符，使用函数socket()，设置SOCK_DGRAM</li><li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构</li><li>绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定</li><li>接收客户端的数据，使用recvfrom()函数接收客户端的网络数据</li><li>向客户端发送数据，使用sendto()函数向服务器主机发送数据</li><li>关闭套接字，使用close()函数释放资源</li></ul></li><li><strong>客户端：</strong>socket -&gt; sendto&#x2F;recvfrom -&gt; close<ul><li>建立套接字文件描述符，socket()</li><li>设置服务器地址和端口，struct sockaddr</li><li>向服务器发送数据，sendto()</li><li>接收服务器的数据，recvfrom()</li><li>关闭套接字，close()</li></ul></li><li><strong>注意：</strong><ul><li>sendto和recvfrom的第56个参数是sock地址<ul><li>服务器端的recvfrom和sendto都是cli地址</li><li>客户端sendto是服务器端的地址，最后一个参数是指针，recvfrom是新建的from地址，最后一个参数是整型</li></ul></li><li>UDP不用listen，accept，因为UDP无连接</li><li>UDP通过sendto函数完成套接字的地址分配工作<ul><li>第一阶段：向UDP套接字注册IP和端口号</li><li>第二阶段：传输数据</li><li>第三阶段：删除UDP套接字中注册的目标地址信息</li></ul></li><li>每次调用sendto函数都重复上述过程，每次都变更地址，因此可以重复利用同一UDP套接字向不同的目标传输数据</li></ul></li></ul></li></ul><h2 id="2-TCP中的accept和connect和listen的关系"><a href="#2-TCP中的accept和connect和listen的关系" class="headerlink" title="2.TCP中的accept和connect和listen的关系"></a>2.TCP中的accept和connect和listen的关系</h2><ul><li><strong>listen</strong><ul><li><strong>listen功能</strong><ul><li>listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求</li><li>参数 backlog 的作用是设置内核中连接队列的长度</li><li>根据TCP状态转换图，调用listen导致套接字从CLOSED状态转换成LISTEN状态</li></ul></li><li><strong>是否阻塞</strong><ul><li>listen()函数不会阻塞，它将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束</li></ul></li><li><strong>backlog的作用</strong><ul><li>backlog是队列的长度，内核为任何一个给定的监听套接口维护两个队列：<ul><li>未完成连接队列（incomplete connection queue），每个这样的 SYN 分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些套接口处于 SYN_RCVD 状态</li><li>已完成连接队列（completed connection queue），每个已完成 TCP 三次握手过程的客户对应其中一项。这些套接口处于 ESTABLISHED 状态</li></ul></li><li>当有一个客户端主动连接（connect()），Linux 内核就自动完成TCP 三次握手，该项就从未完成连接队列移到已完成连接队列的队尾，将建立好的链接自动存储到队列中，如此重复</li><li>backlog 参数历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5</li></ul></li></ul></li><li><strong>connect</strong><ul><li><strong>connect功能</strong><ul><li>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。</li><li>connect之后是三次握手</li></ul></li><li><strong>是否阻塞</strong><ul><li>通常的情况，客户端的connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）</li></ul></li></ul></li><li><strong>accept</strong><ul><li><strong>accept功能</strong><ul><li>accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接(<strong>三次握手之后</strong>)</li></ul></li><li><strong>是否阻塞</strong><ul><li>如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止</li><li>如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT</li></ul></li></ul></li></ul><h2 id="3-UDP中的connect"><a href="#3-UDP中的connect" class="headerlink" title="3.UDP中的connect"></a>3.UDP中的connect</h2><p><strong>UDP的connect和TCP的connect完全不同，UDP不会引起三次握手</strong></p><ul><li><strong>未连接的UDP传输数据</strong><ul><li>第一阶段：向UDP套接字注册IP和端口号</li><li>第二阶段：传输数据</li><li>第三阶段：删除UDP套接字中注册的目标地址信息</li></ul></li><li><strong>已连接的UDP传输数据</strong><ul><li>第一阶段：向UDP套接字注册IP和端口号</li><li>第二阶段：传输数据</li><li>第三阶段：传输数据</li></ul></li><li>可以提高传输效率</li><li>采用connect的UDP发送接受报文可以调用send,write和recv,read操作，也可以调用sendto,recvfrom，此时需要将第五和第六个参数置为NULL或0</li><li>由已连接的UDP套接口引发的异步错误，返回给他们所在的进程。相反我们说过，未连接UDP套接口不接收任何异步错误给一个UDP套接口，connect后的udp套接口write可以检测发送数据成功与否，直接sendto无法检测</li><li>多次调用connect拥有一个已连接UDP套接口的进程的作用<ul><li>指定新的IP地址和端口号</li><li>断开套接口</li></ul></li></ul><h2 id="4-服务端大量TIMEWAIT或CLOSEWAIT状态"><a href="#4-服务端大量TIMEWAIT或CLOSEWAIT状态" class="headerlink" title="4.服务端大量TIMEWAIT或CLOSEWAIT状态"></a>4.服务端大量TIMEWAIT或CLOSEWAIT状态</h2><p>首先通过TCP的四次挥手过程分析确定两个状态的出现背景。TIMEWAIT是大量tcp短连接导致的，确保对方收到最后发出的ACK，一般为2MSL；CLOSEWAIT是tcp连接不关闭导致的，出现在close()函数之前</p><ul><li><strong>TIMEWAIT</strong><ul><li>可以通过设置SOCKET选项SO_REUSEADDR来重用处于TIMEWAIT的sock地址，对应于内核中的tcp_tw_reuse，这个参数不是“消除” TIME_WAIT的，而是说当资源不够时，可以重用TIME_WAIT的连接</li><li>修改ipv4.ip_local_port_range，增大可用端口范围，来承受更多TIME</li><li>设置SOCK选项SO_LINGER选项，这样会直接消除TIMEWAIT</li></ul></li><li><strong>CLOSEWAIT</strong><ul><li>客户端主动关闭，而服务端没有close关闭连接，则服务端产生大量CLOSEWAIT，一般都是业务代码有问题</li></ul></li></ul><h2 id="5-优雅关闭和半关闭"><a href="#5-优雅关闭和半关闭" class="headerlink" title="5.优雅关闭和半关闭"></a>5.优雅关闭和半关闭</h2><ul><li><strong>概念</strong><ul><li>一个文件描述符关联一个文件，这里是网络套接字</li><li>close会关闭用户应用程序中的socket句柄，释放相关资源，从而触发关闭TCP连接</li><li>关闭TCP连接，是关闭网络套接字，断开连接</li><li>close只是减少引用计数，只有当引用计数为0的时候，才发送fin，真正关闭连接</li><li>shutdown不同，只要以SHUT_WR&#x2F;SHUT_RDWR方式调用即发送FIN包</li><li>shutdown后要调用close</li><li>保持连接的某一端想关闭连接了，<strong>但它需要确保要发送的数据全部发送完毕以后才断开连接</strong>，此种情况下需要使用优雅关闭，一种是shutdown，一种是设置SO_LINGER的close</li><li>半关闭，是关闭写端，但可以读对方的数据，这种只能通过shutdown实现</li></ul></li><li><strong>close函数会关闭文件描述符，不会立马关闭网络套接字，除非引用计数为0，则会触发调用关闭TCP连接</strong><ul><li>检查接收缓冲区是否有数据未读(不包括FIN包)，如果有数据未读，协议栈会发送RST包，而不是FIN包。如果套接字设置了SO_LINGER选项，并且lingertime设置为0，这种情况下也会发送RST包来终止连接。其他情况下，会检查套接字的状态，只有在套接字的状态是TCP_ESTABLISHED、TCP_SYN_RECV和TCP_CLOSE_WAIT的状态下，才会发送FIN包</li><li>若有多个进程调用同一个网络套接字，会将网络套接字的文件描述符+1，close调用只是将当前套接字的文件描述符-1，只会对当前的进程有效，只会关闭当前进程的文件描述符，其他进程同样可以访问该套接字</li><li>close函数的默认行为是，关闭一个socket，close将立即返回，TCP模块尝试把该socket对应的TCP缓冲区中的残留数据发送给对方，并不保证能到达对方</li><li>close行为可以通过SO_LINGER修改</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">struct linger&#123;<br>    int l_onoff;    //开启或关闭该选项<br>    int l_linger;   //滞留时间<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">* l_onoff为0，该选项不起作用，采用默认close行为 * l_onoff不为0，l_linger为0，close立即返回，TCP模块丢弃被关闭的socket对应的TCP缓冲区中的数据，给对方发送RST复位信号，这样可以异常终止连接，且完全消除了TIME_WAIT状态 * l_linger不为0，阻塞socket，被关闭的socket对应TCP缓冲区，若还有数据，close会阻塞，进程睡眠，直到收到对方的确认或等待l_linger时间，若超时仍未收到确认，则close返回-1设置errno为EWOULDBLOCK* l_linger不为0，非阻塞socket，close立即返回，需要根据返回值和errno判断残留数据是够发送完毕</code></pre><ul><li><strong>shutdown没有采用引用计数的机制，会影响所有进程的网络套接字，可以只关闭套接字的读端或写端，也可全部关闭，用于实现半关闭，会直接发送FIN包</strong><ul><li>SHUT_RD，关闭sockfd上的读端，不能再对sockfd文件描述符进行读操作，且接收缓冲区中的所有数据都会丢弃</li><li>SHUT_WR，关闭写端，确保发送缓冲区中的数据会在真正关闭连接之前会发送出去，不能对其进行写操作，连接处于半关闭状态</li><li>SHUT_RDWR，同时关闭sockfd的读写</li></ul></li></ul><h2 id="6-send和recv的阻塞和非阻塞情况"><a href="#6-send和recv的阻塞和非阻塞情况" class="headerlink" title="6.send和recv的阻塞和非阻塞情况"></a>6.send和recv的阻塞和非阻塞情况</h2><ul><li><p><strong>send</strong><br>send函数返回100，并不是将100个字节的数据发送到网络上或对端，而是发送到了协议栈的写缓冲区，至于什么时候发送，由协议栈决定</p><ul><li><strong>阻塞</strong><ul><li>一直等待，直到写缓冲区有空闲<ul><li>成功写返回发送数据长度</li><li>失败返回-1</li></ul></li></ul></li><li><strong>非阻塞</strong><ul><li>不等待，立即返回，成功返回数据长度</li><li>返回-1，判断错误码<ul><li>若错误码为EAGAIN或EWOULDBLOCK则表示写缓冲区不空闲</li><li>若错误码为ERROR，则表示失败</li></ul></li></ul></li></ul></li><li><p><strong>recv</strong></p><ul><li><strong>阻塞</strong><ul><li>一直等待，直到读缓冲区有数据<ul><li>成功写返回数据长度</li><li>失败返回-1</li></ul></li></ul></li><li><strong>非阻塞</strong><ul><li>不等待，立即返回，成功返回数据长度</li><li>返回-1，判断错误码<ul><li>若错误码为EAGAIN或EWOULDBLOCK则表示读缓冲区没数据</li><li>若错误码为ERROR，则表示失败</li></ul></li><li>返回0<ul><li>对端关闭连接</li></ul></li></ul></li></ul></li></ul><h2 id="7-网络字节序和主机序"><a href="#7-网络字节序和主机序" class="headerlink" title="7.网络字节序和主机序"></a>7.网络字节序和主机序</h2><p>字节序分为大端字节序和小端字节序，大端字节序也称网络字节序，小端字节序也称为主机字节序</p><ul><li><strong>大端字节序</strong><ul><li>一个整数的高位字节存储在低位地址，低位字节存储在高位地址</li></ul></li><li><strong>小端字节序</strong><ul><li>高位字节存储在高位地址，低位字节存储在低位地址</li></ul></li><li><strong>转换API</strong><ul><li>htonl 主机序转网络序，长整型，用于转换IP地址</li><li>htons 主机序转网络序，短整型，用于转换端口号</li><li>ntohl 网络序转主机序</li><li>ntohs 网络序转主机序</li></ul></li></ul><h2 id="8-为什么忽略SIGPIPE信号"><a href="#8-为什么忽略SIGPIPE信号" class="headerlink" title="8.为什么忽略SIGPIPE信号"></a>8.为什么忽略SIGPIPE信号</h2><ul><li>假设server和client 已经建立了连接，server调用了close, 发送FIN 段给client（其实不一定会发送FIN段，后面再说），此时server不能再通过socket发送和接收数据，此时client调用read，如果接收到FIN 段会返回0</li><li>但client此时还是可以write 给server的，write调用只负责把数据交给TCP发送缓冲区就可以成功返回了，所以不会出错，而server收到数据后应答一个RST段，表示服务器已经不能接收数据，连接重置，client收到RST段后无法立刻通知应用层，只把这个状态保存在TCP协议层</li><li>如果client再次调用write发数据给server，由于TCP协议层已经处于RST状态了，因此不会将数据发出，而是发一个SIGPIPE信号给应用层，SIGPIPE信号的缺省处理动作是终止程序</li><li>有时候代码中需要连续多次调用write，可能还来不及调用read得知对方已关闭了连接就被SIGPIPE信号终止掉了，这就需要在初始化时调用sigaction处理SIGPIPE信号，对于这个信号的处理我们通常忽略即可</li><li>往一个读端关闭的管道或者读端关闭的socket连接中写入数据，会引发SIGPIPE信号。当系统受到该信号会结束进程是，但我们不希望因为错误的写操作导致程序退出</li><li>通过sigaction函数设置信号，将handler设置为SIG_IGN将其忽略</li><li>通过send函数的MSG_NOSIGNAL来禁止写操作触发SIGPIPE信号</li></ul><h1 id="三、Linux工具与命令"><a href="#三、Linux工具与命令" class="headerlink" title="三、Linux工具与命令"></a>三、Linux工具与命令</h1><h2 id="1-Linux基本目录结构"><a href="#1-Linux基本目录结构" class="headerlink" title="1.Linux基本目录结构"></a>1.Linux基本目录结构</h2><ul><li>&#x2F;bin，binaries存放二进制可执行文件</li><li>&#x2F;usr，unix shared resources用于存放共享的系统资源</li><li>&#x2F;sbin，super user binaries存放二进制可执行文件，只有root才能访问</li><li>&#x2F;etc，etcetera存放系统的配置文件</li><li>&#x2F;boot，存放启动linux和引导文件的目录</li><li>&#x2F;lib，存放着系统最基本的动态连接共享库</li><li>&#x2F;dev，存放linux的设备文件，比如显示器，键盘等</li><li>&#x2F;mnt，用户可以在这个目录下挂在其他临时文件系统</li><li>&#x2F;media，linux系统会自动识别一些设备，例如U盘、光驱等等，linux会把识别的设备挂载到这个目录下</li><li>&#x2F;opt，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</li><li><strong>&#x2F;proc，proc被称为虚拟文件系统，它是一个控制中心，可以通过更改其中某些文件改变内核运行状态，它也是内核提空给我们的查询中心，用户可以通过它查看系统硬件及当前运行的进程信息</strong><ul><li>&#x2F;proc&#x2F;loadavg，前三列分别保存最近1分钟，5分钟，及15分钟的平均负载</li><li>&#x2F;proc&#x2F;meminfo，当前内存使用信息</li><li>&#x2F;proc&#x2F;cpuinfo ， CPU的详细信息</li><li>&#x2F;proc&#x2F;diskstats， 磁盘I&#x2F;O统计信息列表</li><li>&#x2F;proc&#x2F;net&#x2F;dev ， 网络流入流出统计信息</li><li>&#x2F;proc&#x2F;filesystems， 支持的文件系统</li><li>&#x2F;proc&#x2F;cmdline ， 启动时传递至内核的启动参数，通常由grub进行传递</li><li>&#x2F;proc&#x2F;mounts ， 系统当前挂在的文件系统</li><li>&#x2F;proc&#x2F;uptime ， 系统运行时间</li><li>&#x2F;poc&#x2F;version ， 当前运行的内核版本号等信息</li></ul></li></ul><h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h2><ul><li><p><strong>文件查找：find</strong></p><ul><li><p>按名查找： </p><ul><li>查找具体文件（一般方式）</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">find</span> . -name <span class="hljs-regexp">*.cpp</span><br></code></pre></td></tr></table></figure><ul><li>查找具体文件（正则方式）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># -regex为正则查找，-iregex为忽略大小写的正则查找 </span><br>find <span class="hljs-operator">-regex</span> <span class="hljs-string">&quot;.*.cpp<span class="hljs-variable">$</span>&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>定制查找：</p><ul><li>按类型查找</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">f</span>(file)为文件，<span class="hljs-built_in">d</span>(dictionary)为目录，<span class="hljs-built_in">l</span>(link)为链接<br>find . -type f<br></code></pre></td></tr></table></figure><ul><li>按时间查找</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta"># atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta"># mtime为修改时间</span><br><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">type</span> f -atime -<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><ul><li>按大小查找</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"># -size后接文件大小，单位可以为<span class="hljs-built_in">k</span>(kb)，<span class="hljs-built_in">m</span>(MB)，<span class="hljs-built_in">g</span>(GB)<br>find . -type f -size -<span class="hljs-number">1</span>k<br></code></pre></td></tr></table></figure><ul><li>按权限查询</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># -perm后接权限</span><br><span class="hljs-title">find</span> . -<span class="hljs-class"><span class="hljs-keyword">type</span> -perm 644</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>文本搜索：grep</strong></p><ul><li><p>模式匹配</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 匹配<span class="hljs-keyword">test</span>.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容<br>grep <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure></li><li><p>多个模式匹配</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 匹配<span class="hljs-keyword">test</span>.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容<br>grep -<span class="hljs-keyword">e</span> <span class="hljs-string">&quot;using&quot;</span> -<span class="hljs-keyword">e</span> <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure></li><li><p>输出信息</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br>grep -n <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>排序：sort</strong></p><ul><li>文件内容行排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 排序在内存进行，不改变文件</span><br><span class="hljs-comment"># -n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-comment"># -k N表示按各行第N列进行排序</span><br><span class="hljs-comment"># -r(reverse)为逆序排序</span><br><br><span class="hljs-built_in">sort</span> -n -k 1 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li><li><p><strong>转换：tr</strong></p><ul><li><p>字符替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># 将打开文件中所有目标字符替换</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>字符删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># -d删除(delete)</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>字符压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># -s位于后部</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27; &#x27;</span> -s<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>按列切分文本：cut</strong></p><ul><li><p>截取特定列</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 截取的内存进行，不改变文件</span><br><span class="hljs-comment"># -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-comment"># 数字为具体列范围</span><br><span class="hljs-attribute">cut</span> -f <span class="hljs-number">1</span>,<span class="hljs-number">2</span> test<br></code></pre></td></tr></table></figure></li><li><p>指定界定符</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 截取的内存进行，不改变文件</span><br><span class="hljs-meta"># -d后接界定符</span><br>cut -f <span class="hljs-number">2</span> -d <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>按列拼接文本：paste</strong></p><ul><li><p>按列拼接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br>paste test1 test2<br></code></pre></td></tr></table></figure></li><li><p>指定界定符拼接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在内存中拼接，不改变文件</span><br><span class="hljs-comment"># 按照-d之后给出的界定符拼接</span><br><span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><strong>统计行和字符：wc</strong><ul><li><p>基本统计 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><span class="hljs-built_in">wc</span> -l <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>ls</strong></p><ul><li><code>ls -lrt</code> 递归显示文件的详细信息并按照时间排序</li></ul></li><li><p><strong>tail</strong></p><ul><li><p><code>tail -n 100</code> 显示文件尾，指定显示行数，默认10行</p></li><li><p>查看文件尾部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-comment"># 查看日志时常用</span><br><span class="hljs-built_in">tail</span> -f <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>chmod</strong></p><ul><li><p><code>chmod 777 filename</code> 修改文件的权限为用户，用户组，其他人有所有权限</p></li><li><p>更改文件权限</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-comment"># 文件可以有三种权限，r(read)，w(write)，x(execute)</span><br><span class="hljs-comment"># 这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-comment"># 这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br>chmod u+r <span class="hljs-built_in">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>rm</strong></p><ul><li><code>rm -r</code> 递归删除子目录</li><li><code>rm -f</code> 强制删除</li></ul></li><li><p><strong>vim的三种模式</strong></p><ul><li>命令模式(一般模式，通过yy进行赋值)</li><li>编辑模式，通过i或者a</li><li>末行模式，冒号</li></ul><p><a href="http://coolshell.cn/articles/5426.html">详见</a></p></li><li><p><strong>创建链接：ln</strong></p><ul><li><p>创建硬链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><span class="hljs-built_in">ln</span> file1 file2<br></code></pre></td></tr></table></figure></li><li><p>创建软（符号链接）链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-comment"># 相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-comment"># 类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><span class="hljs-built_in">ln</span> -s file1 file2<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-磁盘及内存命令"><a href="#3-磁盘及内存命令" class="headerlink" title="3.磁盘及内存命令"></a>3.磁盘及内存命令</h2><ul><li>文件大小和占用空间大小是不一样的，因为要对齐</li><li>显示每个文件和目录的磁盘使用空间<ul><li><strong>(disk used) du -h</strong></li></ul></li><li>显示磁盘分区上可以使用的磁盘空间<ul><li><strong>(disk free) df -h</strong></li></ul></li><li><strong>显示内存使用情况：free</strong><ul><li>可获得内存及交换区的总量，已使用量，空闲量等信息</li><li>Mem是物理内存的使用情况</li><li>Swap是交换空间的使用情况</li><li>total是物理内存和交换空间的总大小</li><li>used是物理内存和交换空间已经被使用的大小</li><li>free是物理内存和交换空间可用空间（从内核和系统的角度看，真正尚未被使用的物理内存数量）</li><li>shared 列显示被共享使用的物理内存大小</li><li>buff&#x2F;cache 列显示被 buffer 和 cache 使用的物理内存大小（其实是内存为缓存磁盘数据设置的缓冲区）</li><li>available 列显示还可以被应用程序使用的物理内存大小，当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求，理想来说available &#x3D; free + buffer + cache</li></ul></li></ul><h2 id="4-监控性能指标：sar"><a href="#4-监控性能指标：sar" class="headerlink" title="4.监控性能指标：sar"></a>4.监控性能指标：sar</h2><p>监控CPU </p><ul><li>监控CPU负载</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-comment"># 这里&quot;1&quot;表示采样时间间隔是1秒，这里&quot;2&quot;表示采样次数为2</span><br><span class="hljs-attribute">sar</span> -q <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>监控CPU使用率</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 可以显示CPU使用情况</span><br><span class="hljs-comment"># 参数意义同上</span><br><span class="hljs-attribute">sar</span> -u <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>监控内存</p><ul><li>查询内存</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 可以显示内存使用情况</span><br><span class="hljs-comment"># 参数意义同上 </span><br><span class="hljs-attribute">sar</span> -r <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>页面交换查询</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-comment"># 可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br> <span class="hljs-comment"># 参数意义同上</span><br><span class="hljs-attribute">sar</span> -W <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="5-进程命令"><a href="#5-进程命令" class="headerlink" title="5.进程命令"></a>5.进程命令</h2><ul><li><p><strong>ps</strong></p><ul><li>当前运行的进程的快照，指定ps命令的那个时刻的那些进程</li><li><code>ps -aux</code> 查看所有的在内存中的进程信息</li><li><code>ps -ajx</code> 查看进程组相关信息，可以追踪进程之间的血缘关系</li><li><code>ps -ef</code> 线城市所有进程信息，并显示程序间的关系</li><li><code>ps -u username</code> 显示指定用户username信息</li></ul></li><li><p><strong>top</strong></p><ul><li>实时显示系统中各个进程的资源占用情况，按”q”退出top命令</li><li><code>top -H -p pid</code>显示对应pid的所有线程资源使用情况</li><li><code>load average</code> 表示系统最近1min,5min,15min的平均负载，越大表示负载越来越小</li><li>%MEM物理内存占用比</li><li>Cpu(s)和%CPU<ul><li>Cpu(s)表示的是所有用户进程占用整个cpu的平均值</li><li>%CPU显示的是进程占用一个核的百分比，而不是整个cpu（8核）的百分比，有时候可能大于100，那是因为该进程启用了多线程占用了多个核心，所以有时候我们看该值得时候会超过100%，但不会超过总核数*100</li></ul></li></ul></li><li><p><strong>kill</strong></p><ul><li><p>杀掉进程</p></li><li><p><code>kill -9 pid</code>杀掉指定进程</p></li><li><p>杀死具体进程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加具体进程PID</span><br><span class="hljs-attribute">kill</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li><li><p>杀死某进程相关进程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加上&quot;-9&quot;杀死某进程相关进程</span><br><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>lsof</strong></p><ul><li>列出当前系统打开文件的工具</li><li><code>lsof -i :8600</code> 查看8600端口的运行情况</li><li><code>lsof -u username</code> 查看username打开的文件</li><li><code>lsof -c string</code> 查看包含指定字符的进程所打开的文件</li></ul><ul><li><p>查看某用户打开的文件 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># -u(user)为用户，后接用户名</span><br><span class="hljs-attribute">lsof</span> -u inx<br></code></pre></td></tr></table></figure></li><li><p>查看指定进程打开的文件 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># -p(process)为进程，后接进程PID</span><br><span class="hljs-attribute">lsof</span> -p <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li><li><p>查看指定目录下被进程打开的文件 </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>lsof +d /test<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-网络命令"><a href="#6-网络命令" class="headerlink" title="6.网络命令"></a>6.网络命令</h2><ul><li><p><strong>netstat</strong></p><ul><li><p>用于显示与IP、TCP、UDP、和ICMP协议相关的统计数据，用于检验本机各端口的网络连接情况</p></li><li><p><code>-a</code> 列出所有端口</p></li><li><p><code>-p</code> 显示出进程和PID</p></li><li><p><code>-n</code> 将主机、端口和用户名用数字代替</p></li><li><p><code>netstat -apn | grep port</code> 显示指定端口的状态信息和进程信息</p></li><li><p>网络接口信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 显示网卡信息，可结合ifconfig学习</span><br><span class="hljs-attribute">netstat</span> -i<br></code></pre></td></tr></table></figure></li><li><p>列出端口</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">-a</span>(all)表示所有端口，<span class="hljs-built_in">-t</span>(tcp)表示所有使用中的TCP端口<br># <span class="hljs-built_in">-l</span>(listening)表示正在监听的端口<br>netstat -at<br></code></pre></td></tr></table></figure></li><li><p>显示端口统计信息</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">-s</span>(status)显示各协议信息<br># -加上<span class="hljs-built_in">-t</span>(tcp)显示tcp协议信息，加上<span class="hljs-built_in">-u</span>(udp)显示udp协议信息<br>netstat -s<br></code></pre></td></tr></table></figure></li><li><p>显示使用某协议的应用名</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><span class="hljs-attribute">netstat</span> -pt<br></code></pre></td></tr></table></figure></li><li><p>查找指定进程、端口</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-comment"># 第二个操作可以用lsof替代</span><br>netstat -ap | <span class="hljs-keyword">grep</span> ssh<br>netstat -an | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;:80&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>tcpdump</strong></p><ul><li><code>tcpdump host ip</code> 截获主机发出和收到的数据包</li><li><code>tcpdump port 6666</code> 截获端口上通过的包</li><li><code>tcpdump -i eth0</code> 截获某网卡上的包</li></ul><p><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">详见</a></p></li><li><p><strong>ping</strong></p><ul><li><code>ping ip</code> 用于测试另一台主机是否可达，测试网络是否连通以及时延</li><li>windows下ping是32比特，默认发送4次数据包结束</li><li>linux下ping是64比特，默认不停发送数据包，直到手动停止</li></ul></li><li><p><strong>host</strong></p><ul><li><code>host 域名</code> 返回域名的IP地址</li><li>用来查询DNS记录</li></ul></li><li><p><strong>ifconfig</strong></p><ul><li><p>输出当前系统中所有处于活动状态的网络接口</p></li><li><p><code>ifconfig eth0 ip/24</code> 手工指定网卡的IP地址和广播地址，其中广播地址可以根据掩码计算出来</p></li><li><p><code>ifconfig eth0 up</code> 启动网卡eht0</p></li><li><p><code>ifconfig eth0 down</code> 关闭网卡eht0</p></li><li><p>显示设备信息</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 可以显示已激活的网络设备信息</span><br>ifconfig<br></code></pre></td></tr></table></figure></li><li><p>启动关闭指定网卡</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-comment"># up为打开，down为关闭</span><br><span class="hljs-attribute">ifconfig</span> eth0 up<br></code></pre></td></tr></table></figure></li><li><p>配置IP地址</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 前一个参数为具体网卡，后一个为配置的IP地址</span><br><span class="hljs-attribute">ifconfig</span> eth0 <span class="hljs-number">192.168.1.1</span><br></code></pre></td></tr></table></figure></li><li><p>设置最大传输单元</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">前一个参数为具体网卡，后面为MTU的大小</span><br><span class="hljs-comment"># 设置链路层MTU值，通常为1500</span><br><span class="hljs-string">ifconfig</span> <span class="hljs-string">eth0</span> <span class="hljs-string">mtu</span> <span class="hljs-number">1500</span><br></code></pre></td></tr></table></figure></li><li><p>启用和关闭ARP协议</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>traceroute</strong></p><ul><li><p>文件包途径的IP</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span><br><span class="hljs-attribute">traceroute</span> baidu.com<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>网络Debug分析（网络层&#x2F;传输层）：nc</strong></p><ul><li><p>端口扫描</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 黑客很喜欢</span><br><span class="hljs-comment"># 扫描某服务器端口使用情况</span><br><span class="hljs-comment"># -v(view)显示指令执行过程，-w(wait)设置超时时长</span><br><span class="hljs-comment"># -z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-comment"># 数字为扫描的端口范围 </span><br><span class="hljs-attribute">nc</span> -v -w <span class="hljs-number">1</span> baidu.com  -z <span class="hljs-number">75</span>-<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></li></ul><p><a href="https://www.oschina.net/translate/linux-netcat-command">其他详见</a></p></li><li><p><strong>域名解析工具（应用层DNS协议）：dig</strong></p><ul><li><pre><code class="hljs"># 应用层，DNS# 打印域名解析结果# 打印域名解析过程中涉及的各级DNS服务器地址dig baidu.com<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**网络请求（应用层）：curl**</span><br><br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://www.cnblogs.com/gbyukg/p/3326825.html</span>)<br><br><span class="hljs-section">## 7.调试命令</span><br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**调试工具：gdb**</span><br>  <br><span class="hljs-bullet">  *</span> <span class="hljs-code">`l`</span> 列出函数代码及行数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`b 16`</span> 在16行设置断点<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`b func`</span> 在函数func设置断点<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`r`</span> 运行程序<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`n`</span> 单条执行程序<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`p i`</span> 打印i变量的值<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`bt`</span> 查看函数堆栈<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`finish`</span> 退出函数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`q`</span> 结束调试<br>  <br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</span>)<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**编译器：gcc/g++**</span><br><br><span class="hljs-bullet">  *</span> \- C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程<br><br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html</span>)<br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**跟踪进程中系统调用：strace**</span><br>  <br><span class="hljs-bullet">  *</span> 监控用户空间进程和内核的交互，跟踪系统调用和信号传递<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`strace -c ./test`</span> 统计./test使用的系统调用<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`strace -p pid`</span> 跟踪现有进程<br>  <br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html</span>)<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**跟踪进程栈：pstack**</span><br><br><span class="hljs-bullet">  *</span> [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#</span>)<br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**ipcs**</span><br>  <br><span class="hljs-bullet">  *</span> 用于报告系统的消息队列，信号量和共享内存等使用情况<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -a`</span>用于列出本用户所有相关的ipcs参数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -q`</span>用于列出进程中的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -s`</span>用于列出所有的信号量<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -m`</span>用于列出所有的共享内存信息<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -l`</span>用于列出系统限额，比如共享内存最大限制<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -u`</span>用于列出当前的使用情况<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**进程内存映射：pmap**</span><br><br><span class="hljs-bullet">  *</span> 显示进程内存映射<br><br></code></pre></td></tr></table></figure># -x显示扩展信息，后接进程pid# Address: 内存开始地址# 显示信息：    Kbytes: 占用内存的字节数    RSS: 保留内存的字节数    Dirty: 脏页的字节数（包括共享和私有的）    Mode: 内存的权限：read、write、execute、shared、private    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）    Device: 设备名 (major:minor)pmap -x 12345<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**ipcrm**</span><br>  <br><span class="hljs-bullet">  *</span> 用于移除一个消息队列，或者共享内存段，或者一个信号集，同时会将与ipc对象相关联的数据也一起移除，只有超级管理员，或者ipc对象的创建者才能这样做<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -M shmkey`</span> 移除用shmkey创建的共享内存段<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -m shmid`</span> 移除用shmid标识的共享内存段<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -Q msgkey`</span> 移除用msqkey创建的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -q msqid`</span> 移除用msqid标识的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -S semkey`</span> 移除用semkey创建的信号<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -s semid`</span> 移除用semid标识的信号<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**查看依赖库：ldd**</span><br><br><span class="hljs-bullet">  *</span> 程序依赖库查询<br><br></code></pre></td></tr></table></figure># ldd后接可执行文件# 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址# 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置ldd a.out</code></pre></li></ul></li></ul><h2 id="8-文本处理工具"><a href="#8-文本处理工具" class="headerlink" title="8.文本处理工具"></a>8.文本处理工具</h2><ul><li><p><strong>sed</strong></p><p><a href="http://coolshell.cn/articles/9104.html">详见</a></p></li><li><p><strong>awk</strong></p><p><a href="http://coolshell.cn/articles/9070.html">详见</a></p></li></ul><h1 id="四、Docker"><a href="#四、Docker" class="headerlink" title="四、Docker"></a>四、Docker</h1><!-- GFM-TOC --><ul><li><a href="#docker">Docker</a><ul><li><a href="##1%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">一、解决的问题</a></li><li><a href="##2%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83">二、与虚拟机的比较</a></li><li><a href="##3%E4%BC%98%E5%8A%BF">三、优势</a></li><li><a href="##4%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、使用场景</a></li><li><a href="##5%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8">五、镜像与容器</a></li><li><a href="##%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC --></li></ul></li></ul><h2 id="1、解决的问题"><a href="#1、解决的问题" class="headerlink" title="1、解决的问题"></a>1、解决的问题</h2><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p><p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png" width="400px"/> </div><br><h2 id="2、与虚拟机的比较"><a href="#2、与虚拟机的比较" class="headerlink" title="2、与虚拟机的比较"></a>2、与虚拟机的比较</h2><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png" width="500"/> </div><br><h3 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h3><p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p><p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p><h3 id="占用资源"><a href="#占用资源" class="headerlink" title="占用资源"></a>占用资源</h3><p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p><p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p><h2 id="3、优势"><a href="#3、优势" class="headerlink" title="3、优势"></a>3、优势</h2><p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p><h3 id="更容易迁移"><a href="#更容易迁移" class="headerlink" title="更容易迁移"></a>更容易迁移</h3><p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p><h3 id="更容易维护"><a href="#更容易维护" class="headerlink" title="更容易维护"></a>更容易维护</h3><p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p><h3 id="更容易扩展"><a href="#更容易扩展" class="headerlink" title="更容易扩展"></a>更容易扩展</h3><p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p><h2 id="4、使用场景"><a href="#4、使用场景" class="headerlink" title="4、使用场景"></a>4、使用场景</h2><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p><p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p><h3 id="提供可伸缩的云服务"><a href="#提供可伸缩的云服务" class="headerlink" title="提供可伸缩的云服务"></a>提供可伸缩的云服务</h3><p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p><h3 id="搭建微服务架构"><a href="#搭建微服务架构" class="headerlink" title="搭建微服务架构"></a>搭建微服务架构</h3><p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p><h2 id="5、镜像与容器"><a href="#5、镜像与容器" class="headerlink" title="5、镜像与容器"></a>5、镜像与容器</h2><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p><p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p><p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png"/> </div><br><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li><li><a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php">Docker container vs Virtual machine</a></li><li><a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/">How to Create Docker Container using Dockerfile</a></li><li><a href="http://www.cnblogs.com/sammyliu/p/5877964.html">理解 Docker（2）：Docker 镜像</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html">为什么要使用 Docker？</a></li><li><a href="https://www.docker.com/what-docker">What is Docker</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux C++全套牛客面经-参考</title>
    <link href="/2022/07/09/Linux-C-%E5%85%A8%E5%A5%97%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F-%E5%8F%82%E8%80%83/"/>
    <url>/2022/07/09/Linux-C-%E5%85%A8%E5%A5%97%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F-%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><h1 id="1-语言基础-C-x2F-C"><a href="#1-语言基础-C-x2F-C" class="headerlink" title="1. 语言基础 (C&#x2F;C++)"></a>1. 语言基础 (C&#x2F;C++)</h1><h4 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h4><ul><li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li><li>指针可以有多级，引用只有一级</li><li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li><li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li><li>指针可以为空，引用不可以。</li></ul><h4 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li></ul><h4 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h4><ul><li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li><li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li><li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li></ul><h4 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h4><p>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p><h4 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h4><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p><p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p><h4 id="（5）既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？"><a href="#（5）既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？" class="headerlink" title="（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？"></a>（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</h4><p><a href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p><ul><li>malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。</li><li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</li></ul><h4 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h4><p>包括但不限于：</p><ul><li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</li><li>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</li><li>C++中还有函数重载和引用等概念，C中没有</li></ul><h4 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h4><ul><li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p></li><li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p></li></ul><h4 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p><ul><li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li><li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li><li>C++有指针，Java没有指针，只有引用</li><li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li></ul><h4 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h4><p>包括但不限于：</p><ol><li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li><li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>python的库函数比C++的多，调用起来很方便</li></ol><h4 id="（10）-Struct和class的区别"><a href="#（10）-Struct和class的区别" class="headerlink" title="（10） Struct和class的区别"></a>（10） Struct和class的区别</h4><ul><li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li><li>struct的继承默认是public继承，而class的继承默认是private继承</li><li>class可以用作模板，而struct不能</li></ul><h4 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>  联系：它们都是定义常量的一种方法。</p><p>  区别：</p><ul><li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li><li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li><li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li><li>const可以定义函数而define不可以。</li></ul><h4 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h4><ul><li>const修饰类的成员变量时，表示常量不能被修改</li><li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li></ul><h4 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p><ul><li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p></li><li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p></li><li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p></li></ul><p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p><p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p><h4 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p><p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;&#125; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; <span class="hljs-type">int</span> b; &#125;;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p><h4 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul><h4 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h4><p>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</p><p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p><h4 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h4><ol><li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li><li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li><li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li><li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li><li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li></ol><h4 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h4><ul><li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</li><li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li></ul><h4 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h4><p>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p><p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p><h4 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p><h4 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p><p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。</p><p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+&#x3D;”、“&lt;”等</p><p>vector::iterator和list::iterator都重载了“++”运算符。</p><p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p><p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p><h4 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h4><ul><li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li><li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li></ul><p>详见：<a href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p><h4 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h4><p><a href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p><p>在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。</p><ul><li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li><li>全局&#x2F;静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li><li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li><li>代码区，存放程序的二进制代码</li></ul><p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p><h4 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p><ul><li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li><li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li><li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</li></ul><h4 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p><ul><li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li></ul><h4 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p><p>详见：<a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p><ul><li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li></ul><h4 id="（27）-实现编译器处理虚函数表应该如何处理"><a href="#（27）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（27） 实现编译器处理虚函数表应该如何处理"></a>（27） 实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p><h4 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p><h4 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p><p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p><h4 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p><p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p><h4 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p><p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p><p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p><h4 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h4><p><a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p><p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p><p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p><h4 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p><p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p><p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p><h4 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p><p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p><blockquote><p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p></blockquote><h4 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p><ul><li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li><li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li><li>拷贝构造函数是在发生对象复制的时候调用的。</li></ul><h4 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h4><ul><li><p>对象以值传递的方式传入函数参数 </p><blockquote><p>如 <code> void func(Dog dog)&#123;&#125;;</code></p></blockquote></li><li><p>对象以值传递的方式从函数返回</p><blockquote><p>如 <code> Dog func()&#123; Dog d; return d;&#125;</code></p></blockquote></li><li><p>对象需要通过另外一个对象进行初始化</p></li></ul><p>详见：<a href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p><h4 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p><p>对齐规则：</p><ul><li>第一个成员在与结构体变量偏移量为0的地址</li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li><li>对齐数&#x3D;编译器默认的一个对齐数 与 该成员大小的较小值。</li><li>linux 中默认为4</li><li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li></ul><h4 id="（38）-内存泄露的定义，如何检测与避免？"><a href="#（38）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（38） 内存泄露的定义，如何检测与避免？"></a>（38） 内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p><p>造成内存泄漏的几种原因：</p><p>1）类的构造函数和析构函数中new和delete没有配套</p><p>2）在释放对象数组时没有使用delete[]，使用了delete</p><p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p><p>4）没有正确的清楚嵌套的对象指针</p><p>避免方法：</p><ol><li>malloc&#x2F;free要配套</li><li>使用智能指针；</li><li>将基类的析构函数设为虚函数；</li></ol><h4 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h4><p>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</p><ul><li>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</li><li>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</li><li>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li><li>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</li></ul><h4 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h4><ul><li>通过设置断点进行调试</li><li>打印log进行调试</li><li>打印中间结果进行调试</li></ul><h4 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><ul><li>使用gdb命令对core文件进行调试</li></ul><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> coredumpTest<br><span class="hljs-keyword">vim</span> coredumpTest.cpp<br></code></pre></td></tr></table></figure><p>在编辑器内键入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<span class="hljs-comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-comment">coredumpTest</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">g</span> <span class="hljs-literal">-</span><span class="hljs-comment">o coredumpTest</span><br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./coredumpTest<br></code></pre></td></tr></table></figure><p>使用gdb调试coredump</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gdb <span class="hljs-selector-attr">[可执行文件名]</span> <span class="hljs-selector-attr">[core文件名]</span><br></code></pre></td></tr></table></figure><h4 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p><p>1、内联函数在编译时展开，而宏在预编译时展开</p><p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p><p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p><p>4、宏不是函数，而inline是函数</p><p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p><p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p><p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p><h4 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h4><p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p><p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p><h4 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> A&#123;<br><span class="hljs-built_in">int</span> id;<br><span class="hljs-built_in">string</span> name;<br>FaceImage face;<br><span class="hljs-constructor">A(<span class="hljs-params">int</span>&amp; <span class="hljs-params">inputID</span>,<span class="hljs-params">string</span>&amp; <span class="hljs-params">inputName</span>,FaceImage&amp; <span class="hljs-params">inputFace</span>)</span>:id(inputID),name(inputName),face(inputFace)&#123;&#125; <span class="hljs-comment">// 成员初始化列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p><ul><li>常量成员的初始化，因为常量成员只能初始化不能赋值</li><li>引用类型</li><li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li></ul><p>详见<a href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p><h4 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul><li><p>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p></li><li><p>nullptr<br>：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p></li><li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p></li><li><p>thread类和mutex类</p></li><li><p>新的智能指针 unique_ptr和shared_ptr</p></li><li><p>更多详见：<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></p></li></ul><h4 id="（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（46） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4><p>函数的调用过程：</p><p>1）从栈空间分配存储空间</p><p>2）从实参的存储空间复制值到形参栈空间</p><p>3）进行运算</p><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p><h4 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p><ul><li><p>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</p><blockquote><p>特性与要点：</p><ol><li>它没有运行时类型检查，所以是有安全隐患的。</li><li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li><li>static_cast不能转换const，volatile等属性</li></ol></blockquote></li><li><p>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</p></li><li><p>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p></li><li><p>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。</p></li></ul><h4 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h4><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p><h4 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p><ul><li>预处理： 对预处理命令进行替换等预处理操作</li><li>编译：代码优化和生成汇编代码</li><li>汇编：将汇编代码转化为机器语言</li><li>链接：将目标文件彼此链接起来</li></ul><h4 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h4><p>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</p><p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p><p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p><h4 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h4><ul><li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p></li><li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p></li></ul><h4 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h4><p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p><p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p><h4 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h4 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p><p>1）在函数内部可以对此参数进行修改</p><p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p><p>但是有以下的限制：</p><p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p><p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p><p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p><h4 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h4><p><a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p><p>1）友元函数</p><p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">set_show</span><span class="hljs-params">(<span class="hljs-type">int</span> x, A &amp;a)</span></span>;      <span class="hljs-comment">//该函数是友元函数的声明</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_show</span><span class="hljs-params">(<span class="hljs-type">int</span> x, A &amp;a)</span>  <span class="hljs-comment">//友元函数定义，为了访问类A中的成员</span></span><br><span class="hljs-function"></span>&#123;<br>    a.data = x;<br>    cout &lt;&lt; a.data &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> a;<br><br>    <span class="hljs-built_in">set_show</span>(<span class="hljs-number">1</span>, a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p><p>2）友元类</p><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>;                         <span class="hljs-comment">//这是友元类的声明</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>             <span class="hljs-comment">//友元类定义，为了访问类A中的成员</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_show</span><span class="hljs-params">(<span class="hljs-type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> a;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> c;<br><br>    c.<span class="hljs-built_in">set_show</span>(<span class="hljs-number">1</span>, a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用友元类时注意： </p><p>(1) 友元关系不能被继承。 </p><p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p><p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h5 id="（56）-说一下volatile关键字的作用"><a href="#（56）-说一下volatile关键字的作用" class="headerlink" title="（56） 说一下volatile关键字的作用"></a>（56） 说一下volatile关键字的作用</h5><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p><h4 id="（57）-STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#（57）-STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="（57） STL中的sort()算法是用什么实现的，stable_sort()呢"></a>（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p><h4 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p><ul><li>会</li><li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li><li>当vector在插入的时候，end迭代器肯定会失效</li><li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li></ul><h4 id="（58）为什么C-没有实现垃圾回收？"><a href="#（58）为什么C-没有实现垃圾回收？" class="headerlink" title="（58）为什么C++没有实现垃圾回收？"></a>（58）为什么C++没有实现垃圾回收？</h4><ul><li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p><h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code class="hljs">socket()    创建套接字   bind()      绑定本机端口    connect()   建立连接     （TCP三次握手在调用这个函数时进行）listen()    监听端口accept()    接受连接recv(), read(), recvfrom()  数据接收send(), write(), sendto()   数据发送close(), shutdown() 关闭套接字</code></pre><p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p><p>详见：<a href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close&#x2F;shutdown详解</a></p><p>TCP连接与断开详解： <a href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p><h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul><li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p></li><li><p>OSPF：详见：<a href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p></li></ul><h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq&#x2F;ack机制，重传机制和窗口确认机制。</p><p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p><p>作者：姚冬<br>链接：<a href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul><li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li><li>TCP提供流量控制和拥塞控制，而UDP没有。</li><li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li><li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li><li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li></ul><p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p><h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p><h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p><p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p><p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p><p>详见：<a href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p><h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p><ul><li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li><li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li><li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li><li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。</li></ul><h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如<a href="http://www.baidu.com)/">www.baidu.com）</a></h4><ol><li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li><li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li><li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li><li>服务器对客户端发来的http请求进行处理，并返回响应；</li><li>客户端接收到http响应，将结果渲染展示给用户。</li></ol><h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4><p>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</p><p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p><h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul><li>三次握手</li></ul><p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN&#x3D;1，client_seq&#x3D;任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p><p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p><p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK&#x3D;1这样的消息，同时呢，还包括了client_ack&#x3D;k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231434416.png" alt="三次握手.png"></p><ul><li>四次挥手断开连接：</li></ul><p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p><p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack&#x3D;seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p><p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p><p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437354.png" alt="四次挥手.png"></p><h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p><h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p><p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p><h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p><ul><li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p></li><li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p></li><li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p></li><li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p></li><li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p></li></ul><p>慢启动、拥塞避免、快速重传、快速恢复 </p><h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p><p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p><h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p><p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p><p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p><h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p><h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437398.png" alt="拥塞控制.png"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p><p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p><p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p><p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p><p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd&#x3D;1，进入慢启动阶段</p><h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p><p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p><h4 id="（22）-http-x2F-1-0和http-x2F-1-1的区别"><a href="#（22）-http-x2F-1-0和http-x2F-1-1的区别" class="headerlink" title="（22） http&#x2F;1.0和http&#x2F;1.1的区别"></a>（22） http&#x2F;1.0和http&#x2F;1.1的区别</h4><p>HTTP 协议老的标准是 HTTP&#x2F;1.0 ，目前最通用的标准是 HTTP&#x2F;1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http&#x2F;1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p><p>get和post的区别：</p><ol><li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li><li>get可以保存为书签，可以用缓存来优化，而post不可以</li><li>get把请求附在url上，而post把参数附在http包的包体中</li><li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li><li>post可以传输二进制编码的信息，get的参数一般只支持ASCII</li></ol><h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4><p>详见 <a href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></p><p>常见的状态码有：</p><blockquote><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li><li>400 - 请求无效 </li><li>403 - 禁止访问</li></ul></blockquote><h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4><p>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p><h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p><p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p><ol><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li><li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li><li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li></ol><p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p><p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p><h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p><p>seq &#x3D; C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p><h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p><h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p><ul><li>对称加密：加密和解密使用的密钥是同一个<ul><li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li><li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li></ul></li><li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul><li>优点：安全，不怕泄漏  缺点：速度慢</li><li>常用算法：RSA，ECC，DSA</li></ul></li></ul><h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437935.jpg" alt="数字证书.jpg"></p><p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p><p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p><h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4><ul><li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p></li><li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p></li></ul><ol><li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li><li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li><li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li><li>遍历所有分组后得到的四个变量即为结果。</li></ol><p>详见：<a href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p><ul><li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p></li><li><p>加强安全性：加盐（加随机数）</p></li></ul><h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p><ul><li>使用缓存，如redis等</li><li>使用分布式架构进行处理</li><li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li><li>将静态资源尽可能在客户端进行缓存</li><li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 &#x3D; Engine X）</li></ul><p>数据库端：</p><ul><li>数据库采用主从赋值，读写分离措施</li><li>建立适当的索引</li><li>分库分表</li></ul><h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4><p>详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p><p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p><ul><li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li><li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li><li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li></ul><p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p><h4 id="（35）-TCP-x2F-IP的粘包与避免介绍一下"><a href="#（35）-TCP-x2F-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP&#x2F;IP的粘包与避免介绍一下"></a>（35） TCP&#x2F;IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p><p>导致TCP粘包的原因有三方面：</p><ul><li>发送端等待缓冲区满才进行发送，造成粘包</li><li>接收方来不及接收缓冲区内的数据，造成粘包</li><li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li></ul><p>避免粘包的措施：</p><ul><li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li><li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li><li>设置固定长度的报文或者设置报文头部指示报文的长度。</li></ul><h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li><li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li></ul><h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4><ul><li>靠host主机名区分</li><li>靠端口号区分</li></ul><h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437025.png" alt="DNS查询图解"><br>DNS解析有两种方式：递归查询和迭代查询</p><ul><li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li><li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果</li></ul><h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4><p>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p><p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437119.png" alt="(fig/网络协议层.png"></p><h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p><p><a href="http://c.biancheng.net/view/6388.html">http://c.biancheng.net/view/6388.html</a></p><p><a href="https://blog.csdn.net/wxy_nick/article/details/9190693">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p><p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p><h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul><li>关系型数据库的优点<ol><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ol></li><li>非关系型数据库的优点<ol><li>不需要经过sql层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ol></li></ul><h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4><p>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</p><p>适合使用非关系型数据库的场景：</p><ul><li>日志系统</li><li>地理位置存储</li><li>数据量巨大</li><li>高可用</li></ul><h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4><ul><li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li><li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li><li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li><li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li><li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4><p>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</p><ul><li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li><li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li><li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li><li>全文索引 可以加快模糊查询，不常用</li></ul><p>物理分类：</p><ul><li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li><li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。</li></ul><h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><p><a href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></p><p><a href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p><p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p><ul><li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li><li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li></ul><h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary key</span>(column_list) #添加一个主键索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span> (column_list)      #添加一个普通索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> (column_list)     #添加一个唯一索引<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> index_name <span class="hljs-keyword">on</span> <span class="hljs-built_in">table_name</span> (column_list)   #创建一个普通索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index_name <span class="hljs-keyword">on</span> <span class="hljs-built_in">table_name</span> (column_list)  #创建一个唯一索引<br></code></pre></td></tr></table></figure><p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> index_name    #删除一个普通索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary key</span>         #删除一个主键索引<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> index_name <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> <span class="hljs-built_in">table_name</span><br></code></pre></td></tr></table></figure><h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p><ul><li>经常搜索的列上建索引</li><li>作为主键的列上要建索引</li><li>经常需要连接（where子句）的列上</li><li>经常需要排序的列</li><li>经常需要范围查找的列</li></ul><p>哪些列不适合建索引？</p><ul><li>很少查询的列</li><li>更新很频繁的列</li><li>数据值的取值比较少的列（比如性别）</li></ul><h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4><p>数据库的索引是使用B+树来实现的。</p><p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p><p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p><h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437608.png" alt="Bptree.png"></p><p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p><ol><li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li><li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li><li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li><li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li></ol><p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p><h4 id="（10）-索引最左前缀-x2F-最左匹配"><a href="#（10）-索引最左前缀-x2F-最左匹配" class="headerlink" title="（10） 索引最左前缀&#x2F;最左匹配"></a>（10） 索引最左前缀&#x2F;最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p><h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p><ul><li>分表分库：将数据库表进行水平拆分，减少表的长度</li><li>增加缓存： 在web和DB之间加上一层缓存层</li><li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li></ul><p>并发优化：</p><ul><li>主从读写分离：只在主服务器上写，从服务器上读</li><li>负载均衡集群：通过集群或者分布式的方式解决并发压力</li></ul><h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4><ul><li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li><li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li><li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li><li>CSV</li><li>blackhole</li></ul><h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4><p>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p><p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p><p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p><p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p><p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p><h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p><ul><li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p><blockquote><p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p></blockquote></li><li><p>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p><blockquote><p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p></blockquote></li><li><p>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。</p><blockquote><p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p></blockquote></li></ul><p>避免不可重复读需要锁行，避免幻读则需要锁表。</p><p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p><h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p><p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p><ul><li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li><li>读已提交 Read committed:   可以避免脏读的发生 </li><li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li><li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li></ul><p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p><p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p><h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul><li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li><li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</li></ul><h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p><ul><li><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li></ul><blockquote><p>比如 学生 选课（包括很多课程） 就不符合第一范式</p></blockquote><ul><li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</li></ul><blockquote><p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p></blockquote><ul><li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li></ul><blockquote><p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p></blockquote><ul><li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li></ul><h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4><p>以MYSQL为例，</p><ul><li>按照类型来分有乐观锁和悲观锁</li><li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li><li>根据作用来分有共享锁（读锁）和排他锁（写锁）。</li></ul><h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4><ul><li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p></li><li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p><p><a href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p></li></ul><h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4><ol><li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li>主从读写分离，让主服务器负责写，从服务器负责读。</li><li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li><li>使用分布式架构，分散计算压力。</li></ol><h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4><p>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p><p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p><h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p><p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p><p>乐观锁有三种常用的实现形式：</p><ul><li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li><li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li><li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li></ul><h4 id="（27）对数据库目前最新技术有什么了解吗"><a href="#（27）对数据库目前最新技术有什么了解吗" class="headerlink" title="（27）对数据库目前最新技术有什么了解吗"></a>（27）对数据库目前最新技术有什么了解吗</h4><h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h4 id="（1）-Linux的I-x2F-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-x2F-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p><p><a href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p><p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p><ul><li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p></li><li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p></li><li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p></li><li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p></li><li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</p></li></ul><h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4><h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><p><a href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p><p><a href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p><p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p><p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p><p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p><ul><li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p></li><li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p></li><li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p></li></ul><h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437994.png" alt="select"><br>（2)poll使用链表保存文件描述符，其他的跟select没有什么不同。</p><p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231437094.png" alt="epoll"><br>详见 <a href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p><h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul><li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li><li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li></ul><h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4><p>详见：<a href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p><ol><li>top命令查看linux负载：</li><li>uptime查看linux负载</li><li>w查看linux负载：</li><li>vmstat查看linux负载</li></ol><h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4><p>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</p><h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4><p>详见： <a href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p><ol><li>cat 与 tac</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容<br><br><span class="hljs-built_in">cat</span>语法：<span class="hljs-built_in">cat</span> [-n]  文件名 （-n ： 显示时，连行号一起输出）<br><br><span class="hljs-built_in">tac</span>的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，<span class="hljs-built_in">tac</span>实际上是<span class="hljs-built_in">cat</span>反过来写。这个命令不常用。<br><br><span class="hljs-built_in">tac</span>语法：<span class="hljs-built_in">tac</span> 文件名。<br></code></pre></td></tr></table></figure><ol start="2"><li>more和less（常用）</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs excel">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如<span class="hljs-symbol">:ls</span> -al | more<br><br>more的语法：more 文件名<br><br>Enter 向下<span class="hljs-built_in">n</span>行，需要定义，默认为<span class="hljs-number">1</span>行； <br><br>Ctrl f 向下滚动一屏； <br><br>空格键 向下滚动一屏； <br><br>Ctrl b 返回上一屏； <br><br>= 输出当前行的行号； <br><br><span class="hljs-symbol">:f</span> 输出文件名和当前行的行号； <br><br>v 调用vi编辑器； <br><br>! 命令 调用Shell，并执行命令； <br><br>q 退出more<br><br><br>less的功能和more相似，但是使用more无法向前翻页，只能向后翻。<br><br>less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。<br><br>less的语法：less 文件名<br></code></pre></td></tr></table></figure><ol start="3"><li>head和tail</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">head<span class="hljs-built_in">和tail</span>通常使用在只需要读取文件的前几行或者后几行的情况下使用<span class="hljs-built_in">。head</span>的功能是显示文件的前几行内容<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">head</span>的语法<span class="hljs-built_in">：head</span> [n<span class="hljs-built_in"> number</span>] 文件名 <span class="hljs-built_in">(number</span> 显示行数)<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">tail</span>的功能恰好<span class="hljs-built_in">和head</span>相反，只显示最后几行内容<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">tail</span>的语法:tail [-n<span class="hljs-built_in"> number</span>] 文件名<br></code></pre></td></tr></table></figure><ol start="4"><li>nl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nl</span>的功能和<span class="hljs-built_in">cat</span> -n一样，同样是从第一行输出全部内容，并且把行号显示出来<br><br><span class="hljs-built_in">nl</span>的语法：<span class="hljs-built_in">nl</span> 文件名<br></code></pre></td></tr></table></figure><ol start="5"><li>vim</li></ol><p>这个用的太普遍了，主要是用于编辑。</p><h4 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h4><h4 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h4><h4 id="（18）coredump是什么-怎么才能coredump"><a href="#（18）coredump是什么-怎么才能coredump" class="headerlink" title="（18）coredump是什么 怎么才能coredump"></a>（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><p>coredump产生的条件</p><ol><li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li><li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li><li>使用了线程不安全的函数，读写未加锁保护</li><li>错误使用指针转换</li><li>堆栈溢出</li></ol><h4 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h4><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p><p>实用命令实例</p><p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p><p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p><p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　</p><h4 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h4><p>详见：<a href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p><p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p><ul><li>crontab命令用来对crontab文件进行管理</li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-number">1</span>．命令格式：<br>crontab [-u <span class="hljs-literal">user</span>] <span class="hljs-keyword">file</span><br>crontab [-u <span class="hljs-literal">user</span>] [ -e | -l | -r ]<br><span class="hljs-number">2</span>．命令功能：<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。<br><span class="hljs-number">3</span>．命令参数：<br>-u <span class="hljs-literal">user</span>：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。<br><span class="hljs-keyword">file</span>：<span class="hljs-keyword">file</span>是命令文件的名字,表示将<span class="hljs-keyword">file</span>做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。<br>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。<br>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。<br>-r：从/<span class="hljs-keyword">var</span>/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>-i：在删除用户的crontab文件时给确认提示。<br></code></pre></td></tr></table></figure><ul><li>crontab文件内容</li></ul><p>crond是Linux下的周期性执行系统任务的守护进程，他会根据&#x2F;etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">minute</span>   <span class="hljs-built_in">hour</span>   <span class="hljs-built_in">day</span>   <span class="hljs-built_in">month</span>   <span class="hljs-built_in">week</span>   command<br><br>其中：<br><span class="hljs-built_in">minute</span>： 表示分钟，可以是从<span class="hljs-number">0</span>到<span class="hljs-number">59</span>之间的任何整数。<br><span class="hljs-built_in">hour</span>：表示小时，可以是从<span class="hljs-number">0</span>到<span class="hljs-number">23</span>之间的任何整数。<br><span class="hljs-built_in">day</span>：表示日期，可以是从<span class="hljs-number">1</span>到<span class="hljs-number">31</span>之间的任何整数。<br><span class="hljs-built_in">month</span>：表示月份，可以是从<span class="hljs-number">1</span>到<span class="hljs-number">12</span>之间的任何整数。<br><span class="hljs-built_in">week</span>：表示星期几，可以是从<span class="hljs-number">0</span>到<span class="hljs-number">7</span>之间的任何整数，这里的<span class="hljs-number">0</span>或<span class="hljs-number">7</span>代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。<br>在以上各个字段中，还可以使用以下特殊字符：<br>星号（*）：代表所有可能的值，例如<span class="hljs-built_in">month</span>字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“<span class="hljs-number">2</span><span class="hljs-number">-6</span>”表示“<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“<span class="hljs-number">0</span><span class="hljs-number">-23</span>/<span class="hljs-number">2</span>”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/<span class="hljs-number">10</span>，如果用在<span class="hljs-built_in">minute</span>字段，表示每十分钟执行一次。<br></code></pre></td></tr></table></figure><h4 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h4><ul><li>jobs</li></ul><p>查看当前控制台的后台进程</p><p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p><ul><li>ps</li></ul><p>查看后台进程</p><ul><li>top</li></ul><p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p><p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p><p>退出top：输入q即可</p><h1 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h1><h4 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h4><ul><li>区别</li></ul><ol><li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li><li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li><li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li><li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li></ol><ul><li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。</li></ul><h4 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4><p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p><p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p><h4 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4><ul><li>存储器：内存</li><li>控制器：南桥北桥</li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><h4 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h4><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p><ul><li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438995.png" alt="管道通信.png"></p><p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p><p>管道的底层实现 <a href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p></li><li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p></li><li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p></li><li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p></li><li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li></ul><h4 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h4><p><a href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p><p><a href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p><ul><li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I&#x2F;O繁忙性）。</li><li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li><li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li><li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 &#x3D; （等待时间 + 服务时间） &#x2F; 服务时间 &#x3D; 等待时间 &#x2F; 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li><li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li><li>多级反馈队列(Multilevel Feedback Queue)</li></ul><h4 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4><p>进程的执行需要经过三大步骤：编译，链接和装入。</p><ul><li>编译：将源代码编译成若干模块</li><li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li><li>装入：将模块装入内存运行</li></ul><p><a href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p><p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p><p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p><h4 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h4><p><a href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p><p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p><ul><li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li><li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li></ul><p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p><h4 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h4><p>用到两个数据结构：哈希+双向链表 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt; cache ;<span class="hljs-comment">// 存放键，迭代器</span><br>list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; auxlist; <span class="hljs-comment">// 存放 &lt;键，值&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; l;<span class="hljs-comment">// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span><br>    map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;::iterator &gt; cache;<span class="hljs-comment">// 存放键，迭代器</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        cap=capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> mapitera = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(mapitera==cache.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// found</span><br>            list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;<br>            <span class="hljs-type">int</span> value = (*listItera).second;<br><br>            l.<span class="hljs-built_in">erase</span>(listItera);<br>            l.<span class="hljs-built_in">push_front</span>(&#123;key,value&#125;);<br>            cache[key]=l.<span class="hljs-built_in">begin</span>();<br><br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> itera = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(itera!=cache.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">// exist</span><br>            list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;<br><br>            l.<span class="hljs-built_in">erase</span>(listItera);<br>            l.<span class="hljs-built_in">push_front</span>(&#123;key,value&#125;);<br>            cache[key]=l.<span class="hljs-built_in">begin</span>();<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// not exist</span><br>            <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">size</span>()&gt;=cap)&#123;<br>                pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; oldpair = l.<span class="hljs-built_in">back</span>();<br>                l.<span class="hljs-built_in">pop_back</span>();<br>                cache.<span class="hljs-built_in">erase</span>(oldpair.first);<br>            &#125;<br>            l.<span class="hljs-built_in">push_front</span>(&#123;key,value&#125;);<br>            cache[key]=l.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p><p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p><h4 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h4><ol><li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li><li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br>(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li><li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br>(1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br>(2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li><li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br>(1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br>(2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li></ol><h4 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h4><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p><h4 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4><p><a href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p><p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag&#x3D;1表明该锁已经锁住，flag&#x3D;0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">TestAndSet</span>(&amp;flag,<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">//flag=1;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>  flag=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为while有可能被重入，所以可以用TestandSet()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> <span class="hljs-keyword">new</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old = *ptr;<br>    *ptr = <span class="hljs-keyword">new</span>;<br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p><ul><li>使用全局变量</li><li>使用信号机制</li><li>使用事件</li></ul><p>进程之间同步：<br><a href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p><ul><li>信号量</li><li>管程</li></ul><h4 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h4><p><a href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p><ul><li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li><li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li><li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li><li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li></ul><p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p><h4 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h4><h4 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p><ul><li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li><li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。</li></ul><h4 id="（16）-说一下PCB-x2F-说一下进程地址空间-x2F"><a href="#（16）-说一下PCB-x2F-说一下进程地址空间-x2F" class="headerlink" title="（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;"></a>（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</h4><p><a href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></p><p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p><p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438071.jpeg"></p><p>进程地址空间内有：</p><ul><li>代码段text：存放程序的二进制代码</li><li>初始化的数据Data：已经初始化的变量和数据</li><li>未初始化的数据BSS：还没有初始化的数据</li><li>栈</li><li>堆</li></ul><h4 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h4><p>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p><h4 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p><ul><li>临界区</li><li>信号量</li><li>事件</li><li>互斥量</li></ul><h4 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h4><ul><li>该进程的地址空间</li><li>全局变量</li><li>堆空间</li></ul><p>线程的栈空间是自己独有的</p><h4 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h4><h4 id="（21）-一般情况下在Linux-x2F-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-x2F-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p><h4 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h4><p><a href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p><p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p><h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol><li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p></li><li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p></li><li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p></li><li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p></li></ol><h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p><p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p><h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p><h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul><li><p>三态模型<br>三态模型包括三种状态：</p><ol><li>执行：进程分到CPU时间片，可以执行</li><li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li><li>阻塞：有IO事件或者等待其他资源<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438462.png" alt="三态模型"></li></ol></li><li><p>五态模型</p><ol><li>新建态：进程刚刚创建。</li><li>就绪态：</li><li>运行态：</li><li>等待态：出现等待事件</li><li>终止态：进程结束<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438885.png" alt="五态模型"></li></ol></li><li><p>七态模型</p><ol><li>新建态</li><li>就绪挂起态</li><li>就绪态</li><li>运行态</li><li>等待态</li><li>挂起等待态</li><li>终止态<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438793.png" alt="七态模型"></li></ol></li></ul><h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-x2F-内存分配的原理说一下-x2F-malloc函数底层是怎么实现的？-x2F-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-x2F-内存分配的原理说一下-x2F-malloc函数底层是怎么实现的？-x2F-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</h4><p><a href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p><ul><li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li><li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li></ul><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p><h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p><p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span>&#123;<br>  <span class="hljs-type">short</span> s;<br>  <span class="hljs-type">char</span> c[<span class="hljs-number">2</span>]; <span class="hljs-comment">// sizeof(short)=2;</span><br>&#125;un;<br>un.s=<span class="hljs-number">0x0102</span>;<br><span class="hljs-keyword">if</span>(un.c[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> un.c[<span class="hljs-number">1</span>]==<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;大端&quot;</span>;<br><span class="hljs-keyword">if</span>(un.c[<span class="hljs-number">0</span>]==<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> un.c[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;小端&quot;</span>;<br></code></pre></td></tr></table></figure><p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p><h1 id="6-场景题-x2F-算法题"><a href="#6-场景题-x2F-算法题" class="headerlink" title="6. 场景题&#x2F;算法题"></a>6. 场景题&#x2F;算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p><h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>      <span class="hljs-comment">// initialize</span><br>    &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">nullptr</span>) instance=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>mutex mymutex;<br>condition_variable cv;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mymutex)</span></span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(count&lt;<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">0</span>) cv.<span class="hljs-built_in">wait</span>(lk);<br>        cout&lt;&lt;<span class="hljs-string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;<br>        flag=<span class="hljs-number">1</span>;<br>        cv.<span class="hljs-built_in">notify_all</span>();<br>        count++;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printb</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mymutex)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">1</span>) cv.<span class="hljs-built_in">wait</span>(lk);<br>        cout&lt;&lt;<span class="hljs-string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;<br>        flag=<span class="hljs-number">2</span>;<br>        cv.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printc</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mymutex)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">2</span>) cv.<span class="hljs-built_in">wait</span>(lk);<br>        cout&lt;&lt;<span class="hljs-string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;<br>        flag=<span class="hljs-number">0</span>;<br>        cv.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">th2</span><span class="hljs-params">(printa)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">th1</span><span class="hljs-params">(printb)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">th3</span><span class="hljs-params">(printc)</span></span>;<br><br>    th1.<span class="hljs-built_in">join</span>();<br>    th2.<span class="hljs-built_in">join</span>();<br>    th3.<span class="hljs-built_in">join</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot; main thread &quot;</span>&lt;&lt;endl;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438984.png" alt="二维码登录流程"></p><h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul><li>使用异或&#x2F;加减等方式，下面给出使用异或的实现方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a,<span class="hljs-type">int</span>&amp; b)</span></span>&#123;<br>  a=a^b;<br>  b=a^b;<br>  a=a^b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vec[a]=vec[a]^vec[b];<br>    vec[b]=vec[a]^vec[b];<br>    vec[a]=vec[a]^vec[b];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot=vec[start+(end-start)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(start&lt;end)&#123;<br>        <span class="hljs-keyword">while</span>(start&lt;end <span class="hljs-keyword">and</span> vec[start]&lt;pivot) start++;<br>        <span class="hljs-keyword">while</span>(start&lt;end <span class="hljs-keyword">and</span> vec[end]&gt;pivot) end--;<br>        <span class="hljs-keyword">if</span>(start&lt;end) <span class="hljs-built_in">swap</span>(vec,start,end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start&gt;end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> pivot=<span class="hljs-built_in">partition</span>(vec,start,end);<br>    <span class="hljs-built_in">quickSort</span>(vec,start,pivot<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">quickSort</span>(vec,pivot+<span class="hljs-number">1</span>,end);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4><p>堆排序的基本过程：</p><ul><li>将n个元素的序列构建一个大顶堆或小顶堆</li><li>将堆顶的元素放到序列末尾</li><li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li></ul><p>整体时间复杂度为nlogn</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    arr[a]=arr[a]^arr[b];<br>    arr[b]=arr[a]^arr[b];<br>    arr[a]=arr[a]^arr[b];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxid=index;<br>    <span class="hljs-comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span><br>    <span class="hljs-type">int</span> left=<span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>,right=<span class="hljs-number">2</span>*index+<span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span><br>    <span class="hljs-keyword">if</span>(left&lt;len <span class="hljs-keyword">and</span> arr[left]&lt;arr[maxid]) maxid=left;<br>    <span class="hljs-keyword">if</span>(right&lt;len <span class="hljs-keyword">and</span> arr[right]&lt;arr[maxid]) maxid=right;<br><br>    <span class="hljs-comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span><br>    <span class="hljs-keyword">if</span>(maxid!=index)&#123;<br>        <span class="hljs-built_in">swap</span>(arr,maxid,index);<br>        <span class="hljs-built_in">adjust</span>(arr,len,maxid);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapsort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(len<span class="hljs-number">-1</span><span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">adjust</span>(arr,len,i);<br>    &#125;<br><br>    <span class="hljs-comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">swap</span>(arr,<span class="hljs-number">0</span>,i);<br>        <span class="hljs-built_in">adjust</span>(arr,i,<span class="hljs-number">0</span>);<span class="hljs-comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>&#125;;<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;before: &quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item:arr) cout&lt;&lt;item&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br><br>    <span class="hljs-built_in">heapsort</span>(arr,arr.<span class="hljs-built_in">size</span>());<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;after: &quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>  <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>    <span class="hljs-type">int</span> key=nums[i];<br>    <span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[j]&gt;key)&#123;<br>      nums[j+<span class="hljs-number">1</span>]=nums[j];<br>      j--;<br>    &#125;<br>    nums[j+<span class="hljs-number">1</span>]=key;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul><li>3 种快排基准选择方法：</li></ul><p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p><ul><li>4种优化方式：</li></ul><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p><p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p><p>优化3：优化递归操作</p><p>优化4：使用并行或多线程处理子序列</p><h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* root)</span></span>&#123;<br>  ListNode* pre=<span class="hljs-literal">nullptr</span>,cur=root,nxt;<br>  <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>    nxt=cur-&gt;next;<br>    cur-&gt;next=pre;<br>    pre=cur;cur=nxt;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p><blockquote><p>给定10000个整数，找第K大（第K小）的数<br><br>给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p></blockquote><p><em>解决Top K问题若干种方法</em></p><ul><li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li><li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li><li>使用排序方法，排序后再寻找top K元素。</li><li>使用选择排序的思想，对前K个元素部分排序。</li><li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li></ul><ol><li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li></ol><blockquote><p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p></blockquote><p>C++中的最大最小堆要用标准库的priority_queue来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-built_in">Node</span> (<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> i): <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">idx</span>(i) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Node &amp;n1, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Node &amp;n2) ; <br>&#125;;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Node &amp;n1, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Node &amp;n2) &#123;<br>    <span class="hljs-keyword">return</span> n1.value &lt; n2.value;<br>&#125;<br><br>priority_queue&lt;Node&gt; pq; <span class="hljs-comment">// 此时pq为最大堆</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li></ol><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//此为Java实现</span><br>public <span class="hljs-built_in">int</span> find<span class="hljs-constructor">KthLargest(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>  return quick<span class="hljs-constructor">Select(<span class="hljs-params">nums</span>, <span class="hljs-params">k</span>, 0, <span class="hljs-params">nums</span>.<span class="hljs-params">length</span> - 1)</span>;<br>&#125;<br><br><span class="hljs-comment">// quick select to find the kth-largest element</span><br>public <span class="hljs-built_in">int</span> quick<span class="hljs-constructor">Select(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (left<span class="hljs-operator"> == </span>right) return arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>;<br>  <span class="hljs-built_in">int</span> index = partition(arr, left, right);<br>  <span class="hljs-keyword">if</span> (index - left + <span class="hljs-number">1</span> &gt; k)<br>    return quick<span class="hljs-constructor">Select(<span class="hljs-params">arr</span>, <span class="hljs-params">k</span>, <span class="hljs-params">left</span>, <span class="hljs-params">index</span> - 1)</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index - left + <span class="hljs-number">1</span><span class="hljs-operator"> == </span>k)<br>    return arr<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span>;<br>  <span class="hljs-keyword">else</span><br>    return quick<span class="hljs-constructor">Select(<span class="hljs-params">arr</span>, <span class="hljs-params">k</span> - (<span class="hljs-params">index</span> - <span class="hljs-params">left</span> + 1)</span>, index + <span class="hljs-number">1</span>, right);<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li></ol><h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4><p>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p><p><a href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p><h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">treeNode</span>&#123;<br>    string val;<br>    treeNode* left,*right;<br>    <span class="hljs-built_in">treeNode</span>(string val):<span class="hljs-built_in">val</span>(val)&#123;<br>        left=<span class="hljs-literal">nullptr</span>;<br>        right=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">treeNode* <span class="hljs-title">vec2tree</span><span class="hljs-params">(vector&lt;string&gt;&amp; vec,<span class="hljs-type">int</span>&amp; start)</span></span>&#123;<br>    treeNode* root;<br>    <span class="hljs-keyword">if</span>(vec[start]==<span class="hljs-string">&quot;null&quot;</span>)&#123;<br>        start+=<span class="hljs-number">1</span>;<br>        root=<span class="hljs-literal">nullptr</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">treeNode</span>(vec[start]);<br>        start+=<span class="hljs-number">1</span>;<br>        root-&gt;left=<span class="hljs-built_in">vec2tree</span>(vec,start);<br>        root-&gt;right=<span class="hljs-built_in">vec2tree</span>(vec,start);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tree2vec</span><span class="hljs-params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">tree2vec</span>(root-&gt;left,vec);<br>        <span class="hljs-built_in">tree2vec</span>(root-&gt;right,vec);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;string&gt; vec=&#123;<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>,&amp;start=index;<br>    treeNode* root=<span class="hljs-built_in">vec2tree</span>(vec,start);<br>    <span class="hljs-comment">//displaytree(root);</span><br>    vector&lt;string&gt; mvec;<br>    <span class="hljs-built_in">tree2vec</span>(root,mvec);<br>    <span class="hljs-keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m）</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li></ol><p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p><p>查询时间复杂度是logN</p><h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p><p>应用场景主要是数据库的索引</p><p>查询时间复杂度也是logN<br><a href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p><p><a href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p><h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p><ol><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>叶节点的空节点是黑色的。</li><li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li><li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li></ol><p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p><p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p><h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> limit <span class="hljs-number">1000</span><br><span class="hljs-keyword">from</span> t1<br></code></pre></td></tr></table></figure><h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-x2F-手撕"><a href="#（21）希尔排序说一下-x2F-手撕" class="headerlink" title="（21）希尔排序说一下&#x2F;手撕"></a>（21）希尔排序说一下&#x2F;手撕</h4><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p><h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p><p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int &#x3D; 4字节  &#x3D;4*8比特 &#x3D; 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max&#x2F;32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438074.png"></p><p><strong>移位计算公式：</strong><br>N&#x2F;32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F &#x3D; 00011111)<br><br>模32然后相应位置置为1： a[i] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p><p>所以总的公式为： a[ N&gt;&gt;5 ] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p><p><strong>BitMap算法评价</strong></p><ul><li>优点：<ol><li>运算效率高，不进行比较和移位；</li><li>占用内存少，比如最大的数MAX&#x3D;10000000；只需占用内存为MAX&#x2F;8&#x3D;1250000Byte&#x3D;1.25M。</li></ol></li><li>缺点：<ol><li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li><li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li></ol></li></ul><h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p><p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p><p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p><p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p><p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p><p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="E:/百度云盘下载/面经源文件/fig/布隆过滤器.png"></p><h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//评测题目: </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FIFOQueue</span><br>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(initCap,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-type">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>;<br>condition_variable cv;<br>mutex m;<br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-comment">// isFull</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="hljs-built_in">lk</span>(m);<br>    <span class="hljs-keyword">while</span>(flag==<span class="hljs-literal">true</span>) cv.<span class="hljs-built_in">wait</span>(lk);<br>        end=(end+<span class="hljs-number">1</span>)%initCap;<br>        vec[end]=v;<br>        cv.<span class="hljs-built_in">notifyall</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="hljs-built_in">lk</span>(m);<br>  <span class="hljs-keyword">if</span>(start!=end)&#123;<br>    <span class="hljs-type">int</span> val = vec[start];<br>    start=(start+<span class="hljs-number">1</span>)%initCap;<br>        flag=<span class="hljs-literal">false</span>;<br>    cv.<span class="hljs-built_in">notifyall</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    flag=<span class="hljs-literal">false</span>;<br>    cv.<span class="hljs-built_in">notifyall</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p><h1 id="7-智力题"><a href="#7-智力题" class="headerlink" title="7. 智力题"></a>7. 智力题</h1><h4 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h4><ul><li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100&#x2F;2&#x3D;50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50&#x2F;2&#x3D;25楼扔起，重复。</li><li>动态规划</li></ul><h4 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h4><p>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。</p><h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><h4 id="（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h4><p>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6&#x3D;4）本（这不算在第一回合里面）。</p><h4 id="（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h4><p>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。</p><h4 id="（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h4><p>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4&#x3D;996，996&#x2F;2&#x3D;498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1&#x3D;1499瓶。</p><h4 id="（7）在24小时里面时针分针秒针可以重合几次"><a href="#（7）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（7）在24小时里面时针分针秒针可以重合几次"></a>（7）在24小时里面时针分针秒针可以重合几次</h4><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2&#x3D;22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p><h4 id="（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h4><p>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；</p><h4 id="（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h4><p>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y &#x3D; 550 - x，第y组就是轻的那组</p><h4 id="（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h4><p>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">RandNN</span>= <span class="hljs-function"><span class="hljs-title">N</span>( <span class="hljs-title">RandN</span>()-<span class="hljs-number">1</span> ) + <span class="hljs-title">RandN</span>() ;<span class="hljs-comment">// 生成1到N^2之间的随机数</span></span><br><span class="hljs-function">可以看作是在数轴上撒豆子。<span class="hljs-variable">N</span>是跨度/步长，是<span class="hljs-title">RandN</span>()生成的数的范围长度，<span class="hljs-title">RandN</span>()-<span class="hljs-number">1</span>的目的是生成<span class="hljs-number">0</span>到<span class="hljs-variable">N</span>-<span class="hljs-number">1</span>的数，是跳数。后面+<span class="hljs-title">RandN</span>()的目的是填满中间的空隙</span><br></code></pre></td></tr></table></figure><p>比如<code> Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">rand7</span>()</span>&#123;<br>  <span class="hljs-built_in">int</span> x=INT_MAX;<br>  <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">21</span>)&#123;<br>    x=<span class="hljs-number">5</span>*(rand5()<span class="hljs-number">-1</span>)+rand5();<br>  &#125;<br>  <span class="hljs-keyword">return</span> x%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h4><ul><li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li><li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li><li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li><li>所以一共是5+3+1&#x3D;9场。</li></ul><h4 id="烧-香-x2F-绳子-x2F-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#烧-香-x2F-绳子-x2F-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h4><p>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p><h4 id="掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1&#x3D;999场。</p><h1 id="8-大数据"><a href="#8-大数据" class="headerlink" title="8. 大数据"></a>8. 大数据</h1><h4 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h4><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p><ul><li>HDFS提供分布式的数据存储</li><li>MapReduce负责进行数据运算 </li><li>YARN负责任务调度</li></ul><p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p><h4 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h4><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p><ul><li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li><li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li><li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li><li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a href="https://blog.csdn.net/ASN_forever/article/details/81233547">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li><li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li></ul><h4 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h4><p><a href="https://blog.csdn.net/qq_29186199/article/details/80827085">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p><p><a href="https://blog.csdn.net/student__software/article/details/81486431">https://blog.csdn.net/student__software/article/details/81486431</a></p><p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p><p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p><h4 id="4-为什么kafka吞吐量高？-x2F-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-x2F-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</h4><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p><p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p><h4 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h4><p><a href="https://blog.csdn.net/u011204847/article/details/51010205">https://blog.csdn.net/u011204847/article/details/51010205</a></p><p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p><h4 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h4><p><a href="https://blog.csdn.net/yu0_zhang0/article/details/80569946">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p><p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p><p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p><h4 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h4><p>spark的算子分成transformation和action两类</p><ul><li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li><li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark</li></ul><h4 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h4><p>spark的算子分为两类：transformation和action</p><p>常用的transformation算子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// union 求并集</span><br><span class="hljs-keyword">val</span> rdd8 = rdd6.union(rdd7)<br><br><span class="hljs-comment">// intersection 求交集 </span><br><span class="hljs-keyword">val</span> rdd9 = rdd6.intersection(rdd7)<br><br><span class="hljs-comment">// join 将rdd进行聚合连接，类似数据库的join </span><br><span class="hljs-keyword">val</span> rdd3 = rdd1.join(rdd2)<br><br><span class="hljs-comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span><br><span class="hljs-keyword">val</span> arr1 = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br><span class="hljs-keyword">val</span> arr2 = rdd1.map(_+<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span><br></code></pre></td></tr></table></figure><p>常用的action算子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// reduce 按照一定的方法将元素进行合并 </span><br><span class="hljs-keyword">val</span> rdd2 = rdd1.reduce(_+_)<br><br><span class="hljs-comment">// collect 将RDD转换为数组</span><br>rdd1.collect<br><br><span class="hljs-comment">// top 返回最大的k个元素</span><br>rdd1.top(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h4><p><a href="https://blog.csdn.net/liudashuang2017/article/details/88576274">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p><p>我们可以从三个方面保证kafka不丢失消息</p><ul><li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li><li>在consumer消费者方面，关闭自动提交；</li><li>在broker集群方面，设置复制系数replica.factor为大于等于3</li></ul><h4 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h4><p>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p><h4 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h4><p><a href="https://blog.csdn.net/a1043498776/article/details/54889922">https://blog.csdn.net/a1043498776/article/details/54889922</a></p><ul><li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li><li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438568.png"></li></ul><h4 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h4><p><a href="https://zhuanlan.zhihu.com/p/57124273">https://zhuanlan.zhihu.com/p/57124273</a></p><p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p><h4 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h4><p><a href="https://www.jianshu.com/p/4f1e551553ae">https://www.jianshu.com/p/4f1e551553ae</a> </p><p><a href="https://www.cnblogs.com/wzj4858/p/8204282.html">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p><p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p><ul><li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438752.png"></p><ul><li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205231438845.webp"></li></ul><h4 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h4><p><a href="https://blog.csdn.net/dengxing1234/article/details/73613484">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p><p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p><ul><li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li><li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li></ul><h1 id="9-HR面"><a href="#9-HR面" class="headerlink" title="9. HR面"></a>9. HR面</h1><h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h4><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p><h4 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h4><ul><li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p></li><li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p></li></ul><h4 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h4><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p><p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p><h4 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h4><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p><h4 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h4><h4 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h4><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p><h4 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h4><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p><p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p><h4 id="8-有什么兴趣爱好，画的怎么样-x2F-球打的如何-x2F-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-x2F-球打的如何-x2F-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</h4><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p><h4 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h4><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p><p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p><h4 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h4><h4 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h4><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p><h4 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h4><h4 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h4><h4 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h4><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p><p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p><h4 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h4><p>可以如实说</p><h4 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h4><ul><li>优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。</li><li>劣势：有时候做事情比较急躁，容易导致粗心。</li></ul><h4 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h4><h4 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h4><h4 id="19-最有成就感的事情-x2F-最骄傲的一件事情"><a href="#19-最有成就感的事情-x2F-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情&#x2F;最骄傲的一件事情"></a>19. 最有成就感的事情&#x2F;最骄傲的一件事情</h4><ul><li>本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩</li><li>保研夏令营拿到了四个学校的offer</li></ul><h4 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h4><h4 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h4><p>踏实 认真—</p>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reference</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-Skill-Tree</title>
    <link href="/2022/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Skill-Tree/"/>
    <url>/2022/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote><p>重点在TCP&#x2F;IP协议和HTTP协议。</p></blockquote><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th></tr></thead><tbody><tr><td align="center"><a href="#net">网络层(IP)</a></td><td align="center"><a href="#trans">传输层(TCP&#x2F;UDP)</a></td><td align="center"><a href="#app">应用层(HTTP)</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层(IP)"></a><span id = "net">网络层(IP)</span></h2><blockquote><p>待补充</p></blockquote><hr><h2 id="传输层-TCP-x2F-UDP"><a href="#传输层-TCP-x2F-UDP" class="headerlink" title="传输层(TCP&#x2F;UDP)"></a><span id = "trans">传输层(TCP&#x2F;UDP)</span></h2><h3 id="1-ISO七层模型中表示层和会话层功能是什么？"><a href="#1-ISO七层模型中表示层和会话层功能是什么？" class="headerlink" title="1. ISO七层模型中表示层和会话层功能是什么？"></a>1. ISO七层模型中表示层和会话层功能是什么？</h3><pre><code class="hljs">- 表示层：图像、视频编码解，数据加密。- 会话层：建立会话，如session认证、断点续传。</code></pre><h3 id="2-描述TCP头部？"><a href="#2-描述TCP头部？" class="headerlink" title="2. 描述TCP头部？"></a>2. 描述TCP头部？</h3><pre><code class="hljs">- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。- 标志位（6bit）：    - URG：标志紧急指针是否有效。        - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。        - PSH：提示接收端立即从缓冲读走数据。        - RST：表示要求对方重新建立连接（复位报文段）。        - SYN：表示请求建立一个连接（连接报文段）。        - FIN：表示关闭连接（断开报文段）。- 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</code></pre><h3 id="3-三次握手过程？"><a href="#3-三次握手过程？" class="headerlink" title="3. 三次握手过程？"></a>3. 三次握手过程？</h3><pre><code class="hljs">- 第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt; SYN_SEND）- 第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&gt; SYN_RECV）- 第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt; ESTABLISH，服 -&gt; ESTABLISH）</code></pre><h3 id="4-四次挥手过程？"><a href="#4-四次挥手过程？" class="headerlink" title="4. 四次挥手过程？"></a>4. 四次挥手过程？</h3><pre><code class="hljs">- 第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt; FIN_WAIT_1）- 第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt; CLOSE_WAIT，客 -&gt; FIN_WAIT_2）    - 此处有等待- 第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt; LAST_ACK，客 -&gt; TIME_WAIT）    - 此处有等待- 第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&gt; CLOSED）</code></pre><h3 id="5-为什么握手是三次，挥手是四次？"><a href="#5-为什么握手是三次，挥手是四次？" class="headerlink" title="5. 为什么握手是三次，挥手是四次？"></a>5. 为什么握手是三次，挥手是四次？</h3><pre><code class="hljs">- 对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）- 对于挥手：TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。</code></pre><h3 id="6-TCP连接状态？"><a href="#6-TCP连接状态？" class="headerlink" title="6. TCP连接状态？"></a>6. TCP连接状态？</h3><pre><code class="hljs">- CLOSED：初始状态。- LISTEN：服务器处于监听状态。- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</code></pre><h3 id="7-解释FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？"><a href="#7-解释FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？" class="headerlink" title="7. 解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？"></a>7. 解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</h3><pre><code class="hljs">- FIN_WAIT_2：    - 半关闭状态。        - 发送断开请求一方还有接收数据能力，但已经没有发送数据能力。- CLOSE_WAIT状态：    - 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。        - 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。- TIME_WAIT状态：    - 又叫2MSL等待状态。        - 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。        - 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</code></pre><h3 id="8-解释RTO，RTT和超时重传？"><a href="#8-解释RTO，RTT和超时重传？" class="headerlink" title="8. 解释RTO，RTT和超时重传？"></a>8. 解释RTO，RTT和超时重传？</h3><pre><code class="hljs">- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：      - 发送的数据没能到达接收端，所以对方没有响应。        - 接收端接收到数据，但是ACK报文在返回过程中丢失。        - 接收端拒绝或丢弃数据。- RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。    - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......        - 重传次数到达上限之后停止重传。- RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</code></pre><h3 id="9-流量控制原理？"><a href="#9-流量控制原理？" class="headerlink" title="9. 流量控制原理？"></a>9. 流量控制原理？</h3><pre><code class="hljs">- 目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。    - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。    - 接收窗：用来标记可以接收的数据大小。- TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。- 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</code></pre><h3 id="10-拥塞控制原理？"><a href="#10-拥塞控制原理？" class="headerlink" title="10. 拥塞控制原理？"></a>10. 拥塞控制原理？</h3><pre><code class="hljs">- 拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。- TCP拥塞控制算法：    - 慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。        - 快速重传 &amp; 快速恢复：略。    - 最终拥塞窗口会收敛于稳定值。</code></pre><h3 id="11-如何区分流量控制和拥塞控制？"><a href="#11-如何区分流量控制和拥塞控制？" class="headerlink" title="11. 如何区分流量控制和拥塞控制？"></a>11. 如何区分流量控制和拥塞控制？</h3><pre><code class="hljs">- 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。- 实际最终发送窗口 = min&#123;流控发送窗口，拥塞窗口&#125;。</code></pre><h3 id="12-TCP如何提供可靠数据传输的？"><a href="#12-TCP如何提供可靠数据传输的？" class="headerlink" title="12. TCP如何提供可靠数据传输的？"></a>12. TCP如何提供可靠数据传输的？</h3><pre><code class="hljs">- 建立连接（标志位）：通信前确认通信实体存在。- 序号机制（序号、确认号）：确保了数据是按序、完整到达。- 数据校验（校验和）：CRC校验全部数据。- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。- 窗口机制（窗口）：提供流量控制，避免过量发送。- 拥塞控制：同上。</code></pre><h3 id="13-TCP-soctet交互流程？"><a href="#13-TCP-soctet交互流程？" class="headerlink" title="13. TCP soctet交互流程？"></a>13. TCP soctet交互流程？</h3><pre><code class="hljs">- 服务器：    - 创建socket -&gt; int socket(int domain, int type, int protocol);        - domain：协议域，决定了socket的地址类型，IPv4为AF_INET。              - type：指定socket类型，SOCK_STREAM为TCP连接。              - protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。        - 绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);        - sockfd：socket返回的套接字描述符，类似于文件描述符fd。              - addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// IPv4的sockaddr地址结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> &#123;<br>    <span class="hljs-type">sa_family_t</span> sin_family;    <span class="hljs-comment">// 协议类型，AF_INET</span><br>    <span class="hljs-type">in_port_t</span> sin_port;    <span class="hljs-comment">// 端口号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> sin_addr;    <span class="hljs-comment">// IP地址</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> &#123;<br>    <span class="hljs-type">uint32_t</span> s_addr;<br>&#125;<br></code></pre></td></tr></table></figure>            - addrlen：地址长度。        - 监听端口号 -&gt; int listen(int sockfd, int backlog);        - sockfd：要监听的sock描述字。              - backlog：socket可以排队的最大连接数。        - 接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);        - sockfd：服务器socket描述字。              - addr：指向地址结构指针。              - addrlen：协议地址长度。              - 注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。        - 从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);        - fd：连接描述字。              - buf：缓冲区buf。              - count：缓冲区长度。              - 注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。        - 关闭socket -&gt; int close(int fd);            - fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。            - 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。- 客户机：    - 创建socket -&gt; int socket(int domain, int type, int protocol);    - 连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);        - sockfd客户端的sock描述字。        - addr：服务器的地址。        - addrlen：socket地址长度。    - 向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);        - fd、buf、count：同read中意义。        - 大于0表示写了部分或全部数据，小于0表示出错。    - 关闭oscket -&gt; int close(int fd);        - fd：同服务器端fd。</code></pre><hr><h2 id="应用层-HTTP"><a href="#应用层-HTTP" class="headerlink" title="应用层(HTTP)"></a><span id = "app">应用层(HTTP)</span></h2><p>HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP&#x2F;IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，，服务器根据请求的内容准备数据。所以如果想要完全弄明白HTTP协议，你需要写一个浏览器 + 一个Web服务器，一侧来生成请求信息，一侧生成响应信息。</p><p>从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。</p><h3 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a><strong>HTTP工作流程</strong></h3><p>一次完整的HTTP请求事务包含以下四个环节：</p><ul><li><p>建立起客户机和服务器连接。</p></li><li><p>建立连接后，客户机发送一个请求给服务器。</p></li><li><p>服务器收到请求给予响应信息。</p></li><li><p>客户端浏览器将返回的内容解析并呈现，断开连接。</p></li></ul><h3 id="HTTP协议结构"><a href="#HTTP协议结构" class="headerlink" title="HTTP协议结构"></a><strong>HTTP协议结构</strong></h3><p>请求报文</p><p>对于HTTP请求报文我们可以通过以下两种方式比较直观的看到：一是在浏览器调试模式下（F12）看请求响应信息，二是通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。但无论是用哪种方式查看，得到的请求报文主题体信息都是相同的，对于请求报文，主要包含以下四个部分，每一行数据必须通过”\r\n”分割，这里可以理解为行末标识符。</p><ul><li><p>报文头（只有一行）</p><p>结构：method  uri  version</p><ul><li><p>method</p><p>HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。</p></li><li><p>uri</p><p>用来指代请求的文件，≠URL。</p></li><li><p>version</p><p>HTTP协议的版本，该字段有HTTP&#x2F;1.0和HTTP&#x2F;1.1两种。</p></li></ul></li><li><p>请求头（多行）</p><p>在HTTP&#x2F;1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。</p><ul><li><p>Host：指定请求资源的主机和端口号。端口号默认80。</p></li><li><p>Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP&#x2F;1.1预设功能。</p></li><li><p>Accept：浏览器可接收的MIME类型。假设为text&#x2F;html表示接收服务器回发的数据类型为text&#x2F;html，如果服务器无法返回这种类型，返回406错误。</p></li><li><p>Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。</p></li><li><p>Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。</p></li><li><p>Content-Length：请求消息正文长度。</p></li></ul><p>另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。</p></li><li><p>空行（一行）</p></li><li><p>可选消息体（多行）</p></li></ul><p>响应报文</p><p>响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以”\r\n”来分割。</p><ul><li><p>报文头（一行）</p><p>结构：version status_code status_message</p><ul><li><p>version</p><p>描述所遵循的HTTP版本。</p></li><li><p>status_code</p><p>状态码，指明对请求处理的状态，常见的如下。</p><ul><li><p>200：成功。</p></li><li><p>301：内容已经移动。</p></li><li><p>400：请求不能被服务器理解。</p></li><li><p>403：无权访问该文件。</p></li><li><p>404：不能找到请求文件。</p></li><li><p>500：服务器内部错误。</p></li><li><p>501：服务器不支持请求的方法。</p></li><li><p>505：服务器不支持请求的版本。</p></li></ul></li><li><p>status_message</p><p>显示和状态码等价英文描述。</p></li></ul></li><li><p>响应头（多行）</p><p>这里只罗列部分。</p><ul><li><p>Date：表示信息发送的时间。</p></li><li><p>Server：Web服务器用来处理请求的软件信息。</p></li><li><p>Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。</p></li><li><p>Content-Length：服务器告知浏览器自己响应的对象长度。</p></li><li><p>Content-Type：告知浏览器响应对象类型。</p></li></ul></li><li><p>空行（一行）</p></li><li><p>信息体（多行）</p><p>实际有效数据，通常是HTML格式的文件，该文件被浏览器获取到之后解析呈现在浏览器中。</p></li></ul><h3 id="CGI与环境变量"><a href="#CGI与环境变量" class="headerlink" title="CGI与环境变量"></a><strong>CGI与环境变量</strong></h3><ul><li><p>CGI程序</p><p>服务器为客户端提供动态服务首先需要解决的是得到用户提供的参数再根据参数信息返回。为了和客户端进行交互，服务器需要先创建子进程，之后子进程执行相应的程序去为客户服务。CGI正是帮助我们解决参数获取、输出结果的。</p><p>动态内容获取其实请求报文的头部和请求静态数据时完全相同，但请求的资源从静态的HTML文件变成了后台程序。服务器收到请求后fork()一个子进程，子进程执行请求的程序，这样的程序称为CGI程序（Python、Perl、C++等均可）。通常在服务器中我们会预留一个单独的目录（cgi-bin）用来存放所有的CGI程序，请求报文头部中请求资源的前缀都是&#x2F;cgi-bin，之后加上所请求调用的CGI程序即可。</p><p>所以上述流程就是：客户端请求程序 -&gt; 服务器fork()子进程 -&gt; 执行被请求程序。接下来需要解决的问题就是如何获取客户端发送过来的参数和输出信息怎么传递回客户端。</p></li><li><p>环境变量</p><p>对CGI程序来说，CGI环境变量在创建时被初始化，结束时被销毁。当CGI程序被HTTP服务器调用时，因为是被服务器fork()出来的子进程，所以其继承了其父进程的环境变量，这些环境变量包含了很多基本信息，请求头中和响应头中列出的内容（比如用户Cookie、客户机主机名、客户机IP地址、浏览器信息等），CGI程序所需要的参数也在其中。</p><ul><li><p>GET方法下参数获取</p><p>服务器把接收到的参数数据编码到环境变量QUERY_STRING中，在请求时只需要直接把参数写到URL最后即可，比如”http:127.0.0.1:80&#x2F;cgi-bin&#x2F;test?a&#x3D;1&amp;b&#x3D;2&amp;c&#x3D;3”，表示请求cgi-bin目录下test程序，’?’之后部分为参数，多个参数用’&amp;’分割开。服务器接收到请求后环境变量QUERY_STRING的值即为a&#x3D;1&amp;b&#x3D;2&amp;c&#x3D;3。</p><p>在CGI程序中获取环境变量值的方法是：getenv()，比如我们需要得到上述QUERY_STRING的值，只需要下面这行语句就可以了。</p><pre><code class="hljs">char *value = getenv(&quot;QUERY_STRING&quot;);</code></pre><p>之后对获得的字符串处理一下提取出每个参数信息即可。</p></li><li><p>POST方法下参数获取</p><p>POST方法下，CGI可以直接从服务器标准输入获取数据，不过要先从CONTENT_LENGTH这个环境变量中得到POST参数长度，再获取对应长度内容。</p></li></ul></li></ul><h3 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a><strong>会话机制</strong></h3><pre><code class="hljs">HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。- Cookie    Cookie是客户端保持状态的方法。    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。- Session    Session是服务器保持状态的方法。    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</code></pre>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络编程-Skill-Tree</title>
    <link href="/2022/05/11/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Skill-Tree/"/>
    <url>/2022/05/11/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h1><h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><h3 id="1-网络编程一般步骤？"><a href="#1-网络编程一般步骤？" class="headerlink" title="1. 网络编程一般步骤？"></a>1. 网络编程一般步骤？</h3><pre><code class="hljs">- TCP：    - 服务端：socket -&gt; bind -&gt; listen -&gt; accept -&gt; recv/send -&gt; close。    - 客户端：socket -&gt; connect -&gt; send/recv -&gt; close。- UDP：    - 服务端：socket -&gt; bind -&gt; recvfrom/sendto -&gt; close。    - 客户端：socket -&gt; sendto/recvfrom -&gt; close。</code></pre><h3 id="2-send、sendto区别，recv、recvfrom区别？"><a href="#2-send、sendto区别，recv、recvfrom区别？" class="headerlink" title="2. send、sendto区别，recv、recvfrom区别？"></a>2. send、sendto区别，recv、recvfrom区别？</h3><h2 id="TCP-x2F-UDP"><a href="#TCP-x2F-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><h3 id="1-TCP和UDP区别？"><a href="#1-TCP和UDP区别？" class="headerlink" title="1. TCP和UDP区别？"></a>1. TCP和UDP区别？</h3><pre><code class="hljs">- TCP面向连接（三次握手），通信前需要先建立连接；UDP面向无连接，通信前不需要连接。- TCP通过序号、重传、流量控制、拥塞控制实现可靠传输；UDP不保障可靠传输，尽最大努力交付。- TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。</code></pre><h3 id="2-TCP为什么不是两次握手而是三次？"><a href="#2-TCP为什么不是两次握手而是三次？" class="headerlink" title="2. TCP为什么不是两次握手而是三次？"></a>2. TCP为什么不是两次握手而是三次？</h3><pre><code class="hljs">- 如果仅两次连接可能出现一种情况：客户端发送完连接报文（第一次握手）后由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认定此报文为失效报文，但在两次握手情况下服务端会认为已经建立起了连接，服务端会一直等待客户端发送数据，但因为客户端会认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。</code></pre><h3 id="3-TCP为什么挥手是四次而不是三次？"><a href="#3-TCP为什么挥手是四次而不是三次？" class="headerlink" title="3. TCP为什么挥手是四次而不是三次？"></a>3. TCP为什么挥手是四次而不是三次？</h3><pre><code class="hljs">- TCP是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP进入半关闭状态，此时主动方可以只关闭输出流。- 之所以不是三次而是四次主要是因为被动关闭方将&quot;对主动关闭报文的确认&quot;和&quot;关闭连接&quot;两个操作分两次进行。- &quot;对主动关闭报文的确认&quot;是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓冲中剩下的数据从输出流发回主动关闭方（主动方接收到数据后同样要进行确认），因此要把&quot;确认关闭&quot;和&quot;关闭连接&quot;分两次进行。- **Linux的close实际上是同时关闭输入流和输出流，并不是我们常说的四次握手。半关闭函数为shutdown，它可以用来断开某个具体描述符的TCP输入流或输出流。**</code></pre><h3 id="4-为什么要有TIME-WAIT状态，TIME-WAIT状态过多怎么解决？"><a href="#4-为什么要有TIME-WAIT状态，TIME-WAIT状态过多怎么解决？" class="headerlink" title="4. 为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？"></a>4. 为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？</h3><pre><code class="hljs">- 主动关闭连接一方在发送对被动关闭方关闭连接的确认报文时，有可能因为网络状况不佳，被动关闭方超时未能收到此报文而重发断开连接（FIN）报文，此时如果主动方不等待而是直接进入CLOSED状态，则接收到被动关闭方重发的断开连接的报文会触发RST分组而非ACK分组，当被动关闭一方接收到RST后会认为出错了。所以说处于TIME_WAIT状态就是为了在重新收到断开连接分组情况下进行确认。- 解决方法：    - 可以通过修改sysctl中TIME_WAIT时间来减少此情况（HTTP 1.1也可以减少此状态）。    - 利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。</code></pre><h3 id="5-TCP建立连接及断开连接是状态转换？"><a href="#5-TCP建立连接及断开连接是状态转换？" class="headerlink" title="5. TCP建立连接及断开连接是状态转换？"></a>5. TCP建立连接及断开连接是状态转换？</h3><pre><code class="hljs">- 客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。- 服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</code></pre><h3 id="6-TCP流量控制和拥塞控制的实现？"><a href="#6-TCP流量控制和拥塞控制的实现？" class="headerlink" title="6. TCP流量控制和拥塞控制的实现？"></a>6. TCP流量控制和拥塞控制的实现？</h3><pre><code class="hljs">- 流量控制：TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节，在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限，发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。- 拥塞控制：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象。严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。</code></pre><h3 id="7-TCP重传机制？"><a href="#7-TCP重传机制？" class="headerlink" title="7. TCP重传机制？"></a>7. TCP重传机制？</h3><pre><code class="hljs">- 滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少、尚未确认的字节数、尚待发送的字节数；让接收方知道已经确认收到的字节数。- 选择重传，用于对传输出错的序列进行重传。</code></pre><h3 id="8-三次握手过程？"><a href="#8-三次握手过程？" class="headerlink" title="8. 三次握手过程？"></a>8. 三次握手过程？</h3><pre><code class="hljs">- 主动建立连接方A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号x进行同步，表明在后面传送数据时的第一个数据字节的序号是x + 1。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。- 接收连接方B的TCP收到连接请求报文段后，如同意则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为x + 1，同时也为自己选择一个序号y。- 主动方A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为y + 1，而自己的序号为x + 1。</code></pre><h3 id="9-四次挥手过程？"><a href="#9-四次挥手过程？" class="headerlink" title="9. 四次挥手过程？"></a>9. 四次挥手过程？</h3><pre><code class="hljs">- 主动关闭主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。- 被动关闭主机B的TCP收到释放连接通知后即发出确认，其序号为y，确认号为x + 1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。- 若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为y，但还必须重复上次已发送过的ACK = x + 1。- 主机A必须对此发出确认，将ACK置1，ACK = y + 1，而自己的序号是x + 1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放。</code></pre><h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="1-阻塞和非阻塞I-x2F-O区别？"><a href="#1-阻塞和非阻塞I-x2F-O区别？" class="headerlink" title="1. 阻塞和非阻塞I&#x2F;O区别？"></a>1. 阻塞和非阻塞I&#x2F;O区别？</h3><pre><code class="hljs">- 如果内核缓冲没有数据可读时，read()系统调用会一直等待有数据到来后才从阻塞态中返回，这就是阻塞I/O。- 非阻塞I/O在遇到上述情况时会立即返回给用户态进程一个返回值，并设置errno为EAGAIN。- 对于往缓冲区写的操作同理。</code></pre><h3 id="2-同步和异步区别？"><a href="#2-同步和异步区别？" class="headerlink" title="2. 同步和异步区别？"></a>2. 同步和异步区别？</h3><pre><code class="hljs">- 同步I/O指处理I/O操作的进程和处理I/O操作的进程是同一个。- 异步I/O中I/O操作由操作系统完成，并不由产生I/O的用户进程执行。</code></pre><h3 id="3-Reactor和Proactor区别？"><a href="#3-Reactor和Proactor区别？" class="headerlink" title="3. Reactor和Proactor区别？"></a>3. Reactor和Proactor区别？</h3><pre><code class="hljs">- Reactor模式已经是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。- 异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。</code></pre><h3 id="4-epoll和select及poll区别？"><a href="#4-epoll和select及poll区别？" class="headerlink" title="4. epoll和select及poll区别？"></a>4. epoll和select及poll区别？</h3><pre><code class="hljs">- 文件描述符数量限制：select文件描述符数量受到限制，最大为2048（FD_SETSIZE），可重编内核修改但治标不治本；poll没有最大文件描述符数量限制；epoll没有最大文件描述符数量限制。- 检查机制：select和poll会以遍历方式（轮询机制）检查每一个文件描述符以确定是否有I/O就绪，每次执行时间会随着连接数量的增加而线性增长；epoll则每次返回后只对活跃的文件描述符队列进行操作（每个描述符都通过回调函数实现，只有活跃的描述符会调用回调函数并添加至队列中）。**当大量连接是非活跃连接时epoll相对于select和poll优势比较大，若大多为活跃连接则效率未必高（设计队列维护及红黑树创建）**- 数据传递方式：select和poll需要将FD_SET在内核空间和用户空间来回拷贝；epoll则避免了不必要的数据拷贝。</code></pre><h3 id="5-epoll中ET和LT模式的区别与实现原理？"><a href="#5-epoll中ET和LT模式的区别与实现原理？" class="headerlink" title="5. epoll中ET和LT模式的区别与实现原理？"></a>5. epoll中ET和LT模式的区别与实现原理？</h3><pre><code class="hljs">- LT：默认工作方式，同时支持阻塞I/O和非阻塞I/O，LT模式下，内核告知某一文件描述符读、写是否就绪了，然后你可以对这个就绪的文件描述符进行I/O操作。如果不作任何操作，内核还是会继续通知。这种模式编程出错误可能性较小但由于重复提醒，效率相对较低。传统的select、poll都是这种模型的代表。- ET：高速工作方式（因为减少了epoll_wait触发次数），适合高并发，只支持非阻塞I/O，ET模式下，内核告知某一文件描述符读、写是否就绪了，然后他假设已经知道该文件描述符是否已经就绪，内核不会再为这个文件描述符发更多的就绪通知（epoll_wait不会返回），直到某些操作导致文件描述符状态不再就绪。</code></pre><h3 id="6-ET模式下要注意什么（如何使用ET模式）？"><a href="#6-ET模式下要注意什么（如何使用ET模式）？" class="headerlink" title="6. ET模式下要注意什么（如何使用ET模式）？"></a>6. ET模式下要注意什么（如何使用ET模式）？</h3><pre><code class="hljs">- 对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。    - 解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。- 对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。    - 解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-Linux下进程间通信方式？"><a href="#1-Linux下进程间通信方式？" class="headerlink" title="1. Linux下进程间通信方式？"></a>1. Linux下进程间通信方式？</h3><pre><code class="hljs">- 管道：    - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。    - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</code></pre><h3 id="2-Linux下同步机制？"><a href="#2-Linux下同步机制？" class="headerlink" title="2. Linux下同步机制？"></a>2. Linux下同步机制？</h3><pre><code class="hljs">- POSIX信号量：可用于进程同步，也可用于线程同步。- POSIX互斥锁 + 条件变量：只能用于线程同步。</code></pre><h3 id="3-线程和进程的区别？"><a href="#3-线程和进程的区别？" class="headerlink" title="3. 线程和进程的区别？"></a>3. 线程和进程的区别？</h3><pre><code class="hljs">- 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。- 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。- 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。- 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</code></pre><h3 id="4-介绍虚拟内存？"><a href="#4-介绍虚拟内存？" class="headerlink" title="4. 介绍虚拟内存？"></a>4. 介绍虚拟内存？</h3><h3 id="5-内存分配及碎片管理？"><a href="#5-内存分配及碎片管理？" class="headerlink" title="5. 内存分配及碎片管理？"></a>5. 内存分配及碎片管理？</h3><h3 id="6-有很多小的碎片文件怎么处理？"><a href="#6-有很多小的碎片文件怎么处理？" class="headerlink" title="6. 有很多小的碎片文件怎么处理？"></a>6. 有很多小的碎片文件怎么处理？</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="1-fork系统调用？"><a href="#1-fork系统调用？" class="headerlink" title="1. fork系统调用？"></a>1. fork系统调用？</h3><h3 id="2-什么场景用共享内存，什么场景用匿名管道？"><a href="#2-什么场景用共享内存，什么场景用匿名管道？" class="headerlink" title="2. 什么场景用共享内存，什么场景用匿名管道？"></a>2. 什么场景用共享内存，什么场景用匿名管道？</h3><h3 id="3-有没有用过开源的cgi框架？"><a href="#3-有没有用过开源的cgi框架？" class="headerlink" title="3. 有没有用过开源的cgi框架？"></a>3. 有没有用过开源的cgi框架？</h3><h3 id="4-epoll和select比有什么优势有什么劣势，epoll有什么局限性？"><a href="#4-epoll和select比有什么优势有什么劣势，epoll有什么局限性？" class="headerlink" title="4. epoll和select比有什么优势有什么劣势，epoll有什么局限性？"></a>4. epoll和select比有什么优势有什么劣势，epoll有什么局限性？</h3><pre><code class="hljs">- epoll优势：1. 没有描述符数量限制；2. 通过回调代替轮询；3. 内存映射代替数据在用户和内核空间来回拷贝。- epoll劣势（局限性）：select可以跨平台，epoll只能在Linux上使用。</code></pre><h3 id="5-线程（POSIX）锁有哪些？"><a href="#5-线程（POSIX）锁有哪些？" class="headerlink" title="5. 线程（POSIX）锁有哪些？"></a>5. 线程（POSIX）锁有哪些？</h3><pre><code class="hljs">- 互斥锁（mutex）    - 互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。- 条件变量(cond)- 自旋锁(spin)    - 自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。    - 虽然它的效率比互斥锁高，但是它也有些不足之处：        - 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。        - 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。    - 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。- 读写锁（rwlock）</code></pre><h2 id="TKeed"><a href="#TKeed" class="headerlink" title="TKeed"></a>TKeed</h2><h3 id="1-项目整体架构是什么？请求怎么进来？处理完怎么出去？"><a href="#1-项目整体架构是什么？请求怎么进来？处理完怎么出去？" class="headerlink" title="1. 项目整体架构是什么？请求怎么进来？处理完怎么出去？"></a>1. 项目整体架构是什么？请求怎么进来？处理完怎么出去？</h3><pre><code class="hljs">- 整体架构为：I/O多路复用 + 非阻塞I/O + 线程池，即Reactor反应堆模型。- 处理流程：    - 创建监听描述符并在epoll中注册。    - 监听到新请求，epoll从阻塞中返回并建立新连接。    - 将新建的连接描述符在epoll中注册。    - 当某个连接接收到用户请求数据时，将任务投放到线程池任务队列中。    - 工作线程被条件变量（任务队列不为空）唤醒，并互斥访问线程池。    - 得到任务的线程完成解析及响应。        - 工作线程执行函数为do_request，参数即为task结构。            - 每个task结构在建立连接是被初始化，包含描述符、缓冲区等信息是，并在do_request执行时记录解析结果及状态。</code></pre><h3 id="2-在做压测时，机器配置是什么样的？数据如何？"><a href="#2-在做压测时，机器配置是什么样的？数据如何？" class="headerlink" title="2. 在做压测时，机器配置是什么样的？数据如何？"></a>2. 在做压测时，机器配置是什么样的？数据如何？</h3><pre><code class="hljs">- 本地测试。      - 四核i5处理器 + 128G固态硬盘。</code></pre><h3 id="3-为了QPS（Query-per-second-1秒内完成的请求数量）更高可以做哪些改进？"><a href="#3-为了QPS（Query-per-second-1秒内完成的请求数量）更高可以做哪些改进？" class="headerlink" title="3. 为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？"></a>3. 为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？</h3><pre><code class="hljs">- 对请求结果做缓存。- 多次搜索请求采用异步I/O，改串行为并行。- 调整并发线程数量（通常和CPU核心数相同）。</code></pre><h3 id="4-有没有注意到压测时内存，CPU，I-x2F-O指标？"><a href="#4-有没有注意到压测时内存，CPU，I-x2F-O指标？" class="headerlink" title="4. 有没有注意到压测时内存，CPU，I&#x2F;O指标？"></a>4. 有没有注意到压测时内存，CPU，I&#x2F;O指标？</h3><pre><code class="hljs">- 压测同时打开top -H -p pid查看CPU，I/O，内存信息。</code></pre><h3 id="5-压测时有没有见过TIME-WAIT？怎么样会见到？怎么解决？"><a href="#5-压测时有没有见过TIME-WAIT？怎么样会见到？怎么解决？" class="headerlink" title="5. 压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？"></a>5. 压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？</h3><pre><code class="hljs">- 当服务端关闭连接时会产生TIME_WAIT。- 解决方案：    - HTTP 1.1在同一个TCP连接上尽量传输更多数据。    - 通过修改sysctl配置减小TIME_WAIT时间。</code></pre><h3 id="6-是会主动关闭还是会等待客户端关闭连接"><a href="#6-是会主动关闭还是会等待客户端关闭连接" class="headerlink" title="6. 是会主动关闭还是会等待客户端关闭连接?"></a>6. 是会主动关闭还是会等待客户端关闭连接?</h3><pre><code class="hljs">- 服务端会在完成请求之后关闭连接。</code></pre><h3 id="7-写一个Server需要注意哪些问题？"><a href="#7-写一个Server需要注意哪些问题？" class="headerlink" title="7. 写一个Server需要注意哪些问题？"></a>7. 写一个Server需要注意哪些问题？</h3><pre><code class="hljs">- 只支持request/response，除此之外是否需要支持cgi。- 并发量，QPS，资源占用（内存，CPU，I/O，网络流量等）。    - CPU占用是否过高。    - 内存是否泄露。</code></pre><h3 id="8-项目中遇到什么困难，你是如何解决的？"><a href="#8-项目中遇到什么困难，你是如何解决的？" class="headerlink" title="8. 项目中遇到什么困难，你是如何解决的？"></a>8. 项目中遇到什么困难，你是如何解决的？</h3><pre><code class="hljs">- CPU占用过高。- 压测时，每次最后会挂掉。</code></pre><h3 id="9-做这个项目的目的是什么？"><a href="#9-做这个项目的目的是什么？" class="headerlink" title="9. 做这个项目的目的是什么？"></a>9. 做这个项目的目的是什么？</h3><h3 id="10-定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？"><a href="#10-定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？" class="headerlink" title="10. 定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？"></a>10. 定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？</h3><h3 id="11-如果发生超时，在关闭连接时同时又收到了新的数据怎么办？"><a href="#11-如果发生超时，在关闭连接时同时又收到了新的数据怎么办？" class="headerlink" title="11. 如果发生超时，在关闭连接时同时又收到了新的数据怎么办？"></a>11. 如果发生超时，在关闭连接时同时又收到了新的数据怎么办？</h3><h3 id="12-用什么数据结构存放url，怎么解析的？"><a href="#12-用什么数据结构存放url，怎么解析的？" class="headerlink" title="12. 用什么数据结构存放url，怎么解析的？"></a>12. 用什么数据结构存放url，怎么解析的？</h3><pre><code class="hljs">- 使用tk_request_t结构中buff读取用户请求，buff为循环缓冲（8192 Bytes）。- 每次进入while循环时读取用户请求到buff中循环队列尾位置（plast），之后解析用户请求并响应。- 支持HTTP 1.1，只要有数据就读取 -&gt; 解析 -&gt; 响应。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>海量数据处理-Skill-Tree</title>
    <link href="/2022/05/11/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-Skill-Tree/"/>
    <url>/2022/05/11/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="TOP-N问题"><a href="#TOP-N问题" class="headerlink" title="TOP N问题"></a>TOP N问题</h2><h3 id="1-如何在海量数据中找出重复最多一个。"><a href="#1-如何在海量数据中找出重复最多一个。" class="headerlink" title="1. 如何在海量数据中找出重复最多一个。"></a>1. 如何在海量数据中找出重复最多一个。</h3><ul><li><p>通过hash映射为小文件</p></li><li><p>通过hash_map统计各个小文件重读最多的并记录次数</p></li><li><p>对每个小文件重复最多的进行建立大根堆</p></li></ul><h3 id="2-上亿有重数据，统计最多前N个。"><a href="#2-上亿有重数据，统计最多前N个。" class="headerlink" title="2. 上亿有重数据，统计最多前N个。"></a>2. 上亿有重数据，统计最多前N个。</h3><ul><li><p>内存存不下</p><ul><li><p>通过hash映射为小文件</p></li><li><p>通过hash_map统计各个小文件重读最多的并记录次数</p></li><li><p>对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作</p></li></ul></li><li><p>内存存得下</p><ul><li><p>直接内存通过hash_map统计并建大根堆</p></li><li><p>重复N次取走堆顶并重建堆操作</p></li></ul></li></ul><h3 id="3-海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。"><a href="#3-海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。" class="headerlink" title="3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。"></a>3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。</h3><ul><li><p>将IP % 1000映射到1000个小文件中</p><ul><li><p>相同IP会被映射到同一个文件</p></li><li><p>不会出现累加和更大情况</p></li></ul></li><li><p>分1000次在内存处理小文件，得到频率最大IP（使用map统计）</p></li><li><p>对这1000个IP建立大根堆</p></li></ul><h3 id="4-1000w查询串统计最热门10个（同2）。"><a href="#4-1000w查询串统计最热门10个（同2）。" class="headerlink" title="4. 1000w查询串统计最热门10个（同2）。"></a>4. 1000w查询串统计最热门10个（同2）。</h3><ul><li>同上</li></ul><h3 id="5-1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。"><a href="#5-1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。" class="headerlink" title="5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。"></a>5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。</h3><ul><li><p>将单词 % 5000存入5000小文件</p><ul><li><p>平均各文件约200K</p></li><li><p>对超过1M的文件继续分割直到小于200K</p></li></ul></li><li><p>使用map统计各个词出现的频率</p></li><li><p>对5000词使用堆排序或归并排序</p></li></ul><h2 id="分布式TOP-N问题"><a href="#分布式TOP-N问题" class="headerlink" title="分布式TOP N问题"></a>分布式TOP N问题</h2><h3 id="6-分布在100台电脑的海量数据，统计前十。"><a href="#6-分布在100台电脑的海量数据，统计前十。" class="headerlink" title="6. 分布在100台电脑的海量数据，统计前十。"></a>6. 分布在100台电脑的海量数据，统计前十。</h3><ul><li><p>各数据只出现在一台机器中</p><ul><li><p>先在独立机器得到前十</p><ul><li><p>若可以放入内存直接堆排序</p></li><li><p>若不可全放入内存：哈希分块 -&gt; map统计 -&gt; 归总堆排</p></li></ul></li><li><p>再将100台计算机的TOP10组合起来堆排序</p></li></ul></li><li><p>同一元素可同时出现在不同机器中</p><ul><li>遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来</li></ul></li></ul><h2 id="快速外排序问题"><a href="#快速外排序问题" class="headerlink" title="快速外排序问题"></a>快速外排序问题</h2><h3 id="7-有10个1G文件，每行都是一个可重复用户query，按query频度排序。"><a href="#7-有10个1G文件，每行都是一个可重复用户query，按query频度排序。" class="headerlink" title="7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。"></a>7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。</h3><ul><li><p>顺序读取十个文件并采取哈希，将query写入10个文件中</p></li><li><p>通过hash_map(query, count)统计每个query出现次数，至少2G内存</p></li><li><p>通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件</p></li><li><p>对十个文件进行归并排序（外排序）</p></li></ul><h2 id="公共数据问题"><a href="#公共数据问题" class="headerlink" title="公共数据问题"></a>公共数据问题</h2><h3 id="8-A-B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"><a href="#8-A-B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。" class="headerlink" title="8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"></a>8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。</h3><ul><li><p>对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1……，不对应小文件不会有相同url）</p></li><li><p>通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。</p></li></ul><h3 id="9-1000w有重字符串，对字符串去重。"><a href="#9-1000w有重字符串，对字符串去重。" class="headerlink" title="9. 1000w有重字符串，对字符串去重。"></a>9. 1000w有重字符串，对字符串去重。</h3><ul><li><p>先hash分为多个文件</p></li><li><p>逐个文件检查并插入set中</p></li><li><p>多个set取交集</p></li></ul><h2 id="内存内TOP-N问题"><a href="#内存内TOP-N问题" class="headerlink" title="内存内TOP N问题"></a>内存内TOP N问题</h2><h3 id="10-100w个数字找出最大100个。"><a href="#10-100w个数字找出最大100个。" class="headerlink" title="10. 100w个数字找出最大100个。"></a>10. 100w个数字找出最大100个。</h3><ul><li><p>堆排序法</p><ul><li>建大根堆，取走堆顶并重建堆，重复100次</li></ul></li><li><p>快排法</p><ul><li>使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100</li></ul></li></ul><h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><h3 id="11-在2-5亿数字中找出不重复的整数。"><a href="#11-在2-5亿数字中找出不重复的整数。" class="headerlink" title="11. 在2.5亿数字中找出不重复的整数。"></a>11. 在2.5亿数字中找出不重复的整数。</h3><ul><li><p>使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。</p></li><li><p>或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。</p></li></ul><h3 id="12-如何在40亿数字中快速判断是否有某个数？"><a href="#12-如何在40亿数字中快速判断是否有某个数？" class="headerlink" title="12. 如何在40亿数字中快速判断是否有某个数？"></a>12. 如何在40亿数字中快速判断是否有某个数？</h3><ul><li>位图法标记某个数字是否存在，check标记数组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-Skill-Tree</title>
    <link href="/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Skill-Tree/"/>
    <url>/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>面向进程和线程学习操作系统。</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#thread">进程线程模型</a></td><td align="center"><a href="#con">进程间通信</a></td><td align="center"><a href="#mutex">同步互斥机制</a></td><td align="center"><a href="#mem">存储管理</a></td><td align="center"><a href="#netio">网络I&#x2F;O模型</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a><span id = "thread">进程线程模型</span></h2><p>线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i &#x3D; 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i &#x3D; i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p>对于线程，我认为弄清以下两点非常重要：</p><ul><li><p>线程之间有无先后访问顺序（线程依赖关系）</p></li><li><p>多个线程共享访问同一变量（同步互斥问题）</p></li></ul><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p><ol><li><p>线程创建和结束</p><ul><li><p>背景知识：</p><p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p></li><li><p>相关接口：</p><ul><li><p>创建线程：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);</p><p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p><ul><li><p>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t &#x3D;&#x3D; unsigned long int。</p></li><li><p>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</p></li><li><p>start_routine：线程执行函数的首地址，传入函数指针。</p></li><li><p>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p></li></ul></li><li><p>获得线程ID：pthread_t pthread_self();</p><p>调用时，会打印线程ID。</p></li><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li><p>tid：创建线程时通过指针得到tid值。</p></li><li><p>retval：指向返回值的指针。</p></li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul></li></ul></li><li><p>线程属性值修改</p><ul><li><p>背景知识：</p><p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> etachstate;    <span class="hljs-comment">// 线程分离的状态</span><br>    <span class="hljs-type">int</span> schedpolicy;    <span class="hljs-comment">// 线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;    <span class="hljs-comment">// 线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;    <span class="hljs-comment">// 线程的继承性</span><br>    <span class="hljs-type">int</span> scope;    <span class="hljs-comment">// 线程的作用域</span><br>    <span class="hljs-comment">// 以下为线程栈的设置</span><br>    <span class="hljs-type">size_t</span> guardsize;    <span class="hljs-comment">// 线程栈末尾警戒缓冲大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;    <span class="hljs-comment">// 线程的栈设置</span><br>    <span class="hljs-type">void</span> *    stackaddr;    <span class="hljs-comment">// 线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;    <span class="hljs-comment">// 线程栈大小</span><br>&#125;<span class="hljs-type">pthread_arrt_t</span>;<br></code></pre></td></tr></table></figure></li><li><p>相关接口：</p><p>对上述结构体中各参数大多有：pthread_attr_get***()和pthread_attr_set***()系统调用函数来设置和获取。这里不一一罗列。</p></li></ul></li><li><p>线程同步</p><ul><li><a href="#mutex">详见同步互斥专题</a></li></ul></li></ol><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a><strong>多进程</strong></h3><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><ol><li><p>进程创建与结束</p><ul><li><p>背景知识：</p><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 .&#x2F;program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li><li><p>相关接口：</p><ul><li><p>创建进程：pid_t fork(void);</p><p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid &#x3D;&#x3D; 0</p></li><li><p>结束进程：void exit(int status);</p><ul><li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li></ul></li><li><p>获得PID：pid_t getpid(void);</p><p>返回调用者pid。</p></li><li><p>获得父进程PID：pid_t getppid(void);</p><p>返回父进程pid。</p></li></ul></li><li><p>其他补充：</p><ul><li><p>正常退出方式：exit()、_exit()、return（在main中）。</p><p>exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p><p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p></li><li><p>异常退出方式：abort()、终止信号。</p></li></ul></li></ul></li><li><p>僵尸进程、孤儿进程</p><ul><li><p>背景知识：</p><p>父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。</p></li><li><p>相关接口：</p><ul><li><p>回收进程（1）：pid_t wait(int *status);</p><p>一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。</p><ul><li>status：指向子进程结束状态值。</li></ul></li><li><p>回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);</p><p>返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。</p><ul><li><p>pid：子进程识别码，控制等待哪些子进程。</p><ol><li><p>pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。</p></li><li><p>pid &#x3D; -1，等待任何子进程。</p></li><li><p>pid &#x3D; 0，等待进程组识别码与目前进程相同的任何子进程。</p></li><li><p>pid &gt; 0，等待任何子进程识别码为pid的子进程。</p></li></ol></li><li><p>status：指向返回码的指针。</p></li><li><p>options：选项决定父进程调用waitpid后的状态。</p><ol><li><p>options &#x3D; WNOHANG，即使没有子进程退出也会立即返回。</p></li><li><p>options &#x3D; WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。</p></li></ol></li></ul></li></ul></li></ul></li><li><p>守护进程</p></li></ol><ul><li><p>背景知识：</p><p>守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。</p></li><li><p>操作步骤：</p><ul><li><p>创建子进程，父进程退出：fork() + if(pid &gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。</p></li><li><p>在子进程中创建新会话：setsid()。</p></li><li><p>改变当前目录结构为根：chdir(“&#x2F;“)。</p></li><li><p>重设文件掩码：umask(0)。</p></li><li><p>关闭文件描述符：for(int i &#x3D; 0; i &lt; 65535; ++i){close(i);}。</p></li></ul></li></ul><ol start="4"><li>Linux进程控制</li></ol><ul><li><p>进程地址空间（地址空间）</p><p>虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li><li><p>进程控制块（处理机）</p><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li><li><p>上下文切换</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li></ul><h3 id="线程、进程比较"><a href="#线程、进程比较" class="headerlink" title="线程、进程比较"></a><strong>线程、进程比较</strong></h3><p>关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。</p><ul><li><p>fork()和pthread_create()</p><p>负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。</p></li><li><p>wait()和pthread_join()</p><p>负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。</p></li><li><p>exit()和pthread_exit()</p><p>负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。</p></li></ul><hr><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><span id = "con">进程间通信</span></h2><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h3><ul><li><p>无名管道</p><ul><li><p>无名管道特点：</p><ul><li><p>无名管道是一种特殊的文件，这种文件只存在于内存中。</p></li><li><p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</p></li><li><p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int pipe(int fd[2]);</p><ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li><p>有名管道：</p><ul><li><p>有名管道特点：</p><ul><li><p>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</p></li><li><p>无名管道可以在不具有亲缘关系的进程间进行通信。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int mkfifo(const char *pathname, mode_t mode);</p><ul><li><p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p></li><li><p>mode：和open()中的参数相同。</p></li></ul></li></ul></li></ul></li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a><strong>共享内存</strong></h3><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><ul><li><p>相关接口</p><ul><li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p><p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p><ul><li><p>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</p></li><li><p>size：共享内存容量。</p></li><li><p>flag：权限标志位，和open的mode参数一样。</p></li></ul></li><li><p>连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);</p><p>返回值即共享内存实际地址。</p><ul><li><p>shmid：shmget()返回的标识。</p></li><li><p>addr：决定以什么方式连接地址。</p></li><li><p>flag：访问模式。</p></li></ul></li><li><p>从共享内存分离：int shmdt(const void *shmaddr);</p><p>调用成功返回0，失败返回-1。</p><ul><li>shmaddr：是shmat()返回的地址指针。</li></ul></li></ul></li><li><p>其他补充</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></li></ul><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h3><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，<br>而在进程里使用SYSTEM  V信号量。</p><ul><li><p>相关接口</p><ul><li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p><p>创建成功返回信号量标识符，失败返回-1。</p><ul><li><p>key：进程pid。</p></li><li><p>nsems：创建信号量的个数。</p></li><li><p>semflag：指定信号量读写权限。</p></li></ul></li><li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p><p>struct sembuf结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span>&#123;<br>    <span class="hljs-type">short</span> sem_num;<br>    <span class="hljs-type">short</span> sem_op;<br>    <span class="hljs-type">short</span> sem_flg;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成功返回信号量标识符，失败返回-1。</p><ul><li><p>semid：信号量集标识符，由semget()函数返回。</p></li><li><p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p></li><li><p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p></li></ul></li><li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p><ul><li><p>semid：信号量集标识符。</p></li><li><p>semnum：信号量集数组上的下标，表示某一个信号量。</p></li><li><p>arg：union semun类型。</p></li></ul></li></ul></li></ul><h3 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a><strong>辅助命令</strong></h3><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li><p>ipcs -a：列出共享内存、信号量和消息队列信息。</p></li><li><p>ipcs -l：列出系统限额。</p></li><li><p>ipcs -u：列出当前使用情况。</p></li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a><strong>套接字</strong></h3><ul><li><p><a href="https://github.com/linw7/Skill-Tree/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">详见socket交互流程</a></p></li><li><p><a href="#netio">详见网络I&#x2F;O模型</a></p></li></ul><hr><h2 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a><span id = "mutex">同步互斥机制</span></h2><blockquote><p>待补充</p></blockquote><hr><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a><span id = "mem">存储管理</span></h2><blockquote><p>待补充</p></blockquote><hr><h2 id="网络I-x2F-O模型"><a href="#网络I-x2F-O模型" class="headerlink" title="网络I&#x2F;O模型"></a><span id = "netio">网络I&#x2F;O模型</span></h2><p>在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I&#x2F;O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。</p><p>所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待：</p><ul><li><p>建立连接时等待对方的ACK包（TCP）。</p></li><li><p>等待客户端请求（HTTP）。</p></li><li><p>输入等待：服务器用户数据到达内核缓冲区（read函数等待）。</p></li><li><p>输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。</p></li></ul><p>另外为了能够解释清楚网络I&#x2F;O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：</p><ul><li><p>read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。</p></li><li><p>printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I&#x2F;O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程&#x2F;线程）。</p></li></ul><p>有了上面的基础，我们就可以介绍下面四种网路I&#x2F;O模型。</p><h3 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a><strong>阻塞式</strong></h3><ul><li><p>阻塞表示一旦调用I&#x2F;O函数必须等整个I&#x2F;O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。</p></li><li><p>很显然，阻塞式I&#x2F;O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程&#x2F;线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I&#x2F;O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。</p></li><li><p>多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I&#x2F;O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。</p></li></ul><h3 id="非阻塞I-x2F-O"><a href="#非阻塞I-x2F-O" class="headerlink" title="非阻塞I&#x2F;O"></a><strong>非阻塞I&#x2F;O</strong></h3><ul><li><p>阻塞和非阻塞最大的区别在于调用I&#x2F;O系统调用后，是等整个I&#x2F;O过程完成再把操作权限返回给用户还是会立即返回。</p></li><li><p>可以使用以下语句将句柄fd设置为非阻塞I&#x2F;O：fcntl(fd, F_SETFL, O_NONBLOCK);</p></li><li><p>非阻塞I&#x2F;O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I&#x2F;O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。</p></li><li><p>非阻塞I&#x2F;O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</p></li></ul><h3 id="I-x2F-O多路复用（事件驱动模型）"><a href="#I-x2F-O多路复用（事件驱动模型）" class="headerlink" title="I&#x2F;O多路复用（事件驱动模型）"></a><strong>I&#x2F;O多路复用（事件驱动模型）</strong></h3><p>前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。</p><p>所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I&#x2F;O多路复用就是这么一种模型。Linux下I&#x2F;O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I&#x2F;O范畴。</p><ol><li><p>select</p><ul><li><p>相关接口：</p><p>int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);</p><p>FD_ZERO(int fd, fd_set* fds)    &#x2F;&#x2F;清空集合</p><p>FD_SET(int fd, fd_set* fds)    &#x2F;&#x2F;将给定的描述符加入集合</p><p>FD_ISSET(int fd, fd_set* fds)    &#x2F;&#x2F;将给定的描述符从文件中删除</p><p>FD_CLR(int fd, fd_set* fds)    &#x2F;&#x2F;判断指定描述符是否在集合中</p></li><li><p>参数：<br>maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。</p><p>readfds：指向读文件队列集合（fd_set）的指针。</p><p>writefds：同上，指向读集合的指针。</p><p>writefds：同上，指向错误集合的指针。</p><p>timeout：指向timeval结构指针，用于设置超时。</p></li><li><p>其他：</p><p>判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p></li></ul></li><li><p>poll</p><ul><li><p>相关接口：<br>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p></li><li><p>结构体定义：<br>struct pollfd{<br>int fd;    &#x2F;&#x2F; 文件描述符<br>short events;    &#x2F;&#x2F; 等到的事件<br>short revents;    &#x2F;&#x2F; 实际发生的事件<br>}</p></li><li><p>参数：<br>fds：指向pollfd结构体数组的指针。</p><p>nfds：pollfd数组当前已被使用的最大下标。</p><p>timeout：等待毫秒数。</p></li><li><p>其他：</p><p>判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p></li></ul></li><li><p>epoll</p><ul><li><p>相关接口：<br>int epoll_create(int size);    &#x2F;&#x2F; 创建epoll句柄<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    &#x2F;&#x2F; 事件注册函数<br>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p></li><li><p>结构体定义：<br>struct epoll_event{<br>__uint32_t events;<br>epoll_data_t data;<br>};<br>typedef union epoll_data{<br>void *ptr;<br>int fd;<br>__uint32_t u32;<br>__uint64_t u64;<br>}epoll_data_t;</p></li><li><p>参数：</p><p>size：用来告诉内核要监听的数目。</p><p>epfd：epoll函数的返回值。</p><p>op：表示动作（EPOLL_CTL_ADD&#x2F;EPOLL_CTL_FD&#x2F;EPOLL_CTL_DEL）。</p><p>fd：需要监听的fd。</p><p>events：指向epoll_event的指针，该结构记录监听的事件。</p><p>maxevents：告诉内核events的大小。</p><p>timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。</p></li></ul></li><li><p>select、poll和epoll区别</p><ul><li><p>操作方式及效率：</p><p>select是遍历，需要遍历fd_set每一个比特位（&#x3D; MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。</p></li><li><p>最大连接数：</p><p>select为1024&#x2F;2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p></li><li><p>fd拷贝：</p><p>select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p></li><li><p>其他：</p><p>select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I&#x2F;O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p></li></ul></li></ol><h3 id="异步I-x2F-O模型"><a href="#异步I-x2F-O模型" class="headerlink" title="异步I&#x2F;O模型"></a><strong>异步I&#x2F;O模型</strong></h3><ul><li><p>上面三种I&#x2F;O方式均属于同步I&#x2F;O。</p></li><li><p>从阻塞式I&#x2F;O到非阻塞I&#x2F;O，我们已经做到了调用I&#x2F;O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I&#x2F;O能够立即返回又能不一直轮询的话会更符合我们的预期。</p></li><li><p>之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I&#x2F;O结果。如果内核能够在完成I&#x2F;O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I&#x2F;O就是这么回事。</p></li><li><p>异步I&#x2F;O就是当用户进程发起I&#x2F;O请求后立即返回，直到内核发送一个信号，告知进程I&#x2F;O已完成，在整个过程中，都没有进程被阻塞。看上去异步I&#x2F;O和非阻塞I&#x2F;O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言C++-Skill-Tree</title>
    <link href="/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/"/>
    <url>/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="编程语言-C-x2F-C"><a href="#编程语言-C-x2F-C" class="headerlink" title="编程语言(C&#x2F;C++)"></a>编程语言(C&#x2F;C++)</h1><blockquote><p>都是语言，为什么英语比C++难这么多呢？</p></blockquote><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th></tr></thead><tbody><tr><td align="center"><a href="base">编程基础</a></td><td align="center"><a href="#oop">面向对象基础</a></td><td align="center"><a href="#stl">标准模板库</a></td><td align="center"><a href="#other">编译及调试</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a><span id = "base">编程基础</span></h2><p>C&#x2F;C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。</p><h3 id="1-变量声明和定义区别？"><a href="#1-变量声明和定义区别？" class="headerlink" title="1. 变量声明和定义区别？"></a>1. 变量声明和定义区别？</h3><pre><code class="hljs">- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 - 相同变量可以再多处声明（外部变量extern），但只能在一处定义。</code></pre><h3 id="2-“零值比较”？"><a href="#2-“零值比较”？" class="headerlink" title="2. “零值比较”？"></a>2. “零值比较”？</h3><pre><code class="hljs">- bool类型：if(flag)- int类型：if(flag == 0)- 指针类型：if(flag == null)- float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001))</code></pre><h3 id="3-strlen和sizeof区别？"><a href="#3-strlen和sizeof区别？" class="headerlink" title="3. strlen和sizeof区别？"></a>3. strlen和sizeof区别？</h3><pre><code class="hljs">- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是&#39;\0&#39;的字符串。- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**</code></pre><h3 id="4-同一不同对象可以互相赋值吗？"><a href="#4-同一不同对象可以互相赋值吗？" class="headerlink" title="4. 同一不同对象可以互相赋值吗？"></a>4. 同一不同对象可以互相赋值吗？</h3><pre><code class="hljs">- 可以，但含有指针成员时需要注意。- 对比类的对象赋值时深拷贝和浅拷贝。</code></pre><h3 id="5-结构体内存对齐问题？"><a href="#5-结构体内存对齐问题？" class="headerlink" title="5. 结构体内存对齐问题？"></a>5. 结构体内存对齐问题？</h3><pre><code class="hljs">- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</code></pre><h3 id="6-static作用是什么？在C和C-中有何区别？"><a href="#6-static作用是什么？在C和C-中有何区别？" class="headerlink" title="6. static作用是什么？在C和C++中有何区别？"></a>6. static作用是什么？在C和C++中有何区别？</h3><pre><code class="hljs">- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。- 未初始化时，static变量默认值为0。</code></pre><h3 id="7-结构体和类的区别？"><a href="#7-结构体和类的区别？" class="headerlink" title="7. 结构体和类的区别？"></a>7. 结构体和类的区别？</h3><pre><code class="hljs">- 结构体的默认限定符是public；类是private。</code></pre><ul><li><del>结构体不可以继承，类可以。</del> C++中结构体也可以继承。</li></ul><h3 id="8-malloc和new的区别？"><a href="#8-malloc和new的区别？" class="headerlink" title="8. malloc和new的区别？"></a>8. malloc和new的区别？</h3><pre><code class="hljs">- malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</code></pre><h3 id="9-指针和引用区别？"><a href="#9-指针和引用区别？" class="headerlink" title="9. 指针和引用区别？"></a>9. 指针和引用区别？</h3><ul><li><p>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</p><ul><li><p>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</p></li><li><p>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</p></li><li><p>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</p></li></ul></li></ul><h3 id="10-宏定义和函数有何区别？"><a href="#10-宏定义和函数有何区别？" class="headerlink" title="10. 宏定义和函数有何区别？"></a>10. 宏定义和函数有何区别？</h3><pre><code class="hljs">- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。- 宏函数不要在最后加分号。</code></pre><h3 id="11-宏定义和const区别？"><a href="#11-宏定义和const区别？" class="headerlink" title="11. 宏定义和const区别？"></a>11. 宏定义和const区别？</h3><pre><code class="hljs">- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。- 宏不检查类型；const会检查数据类型。- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</code></pre><h3 id="12-宏定义和typedef区别？"><a href="#12-宏定义和typedef区别？" class="headerlink" title="12. 宏定义和typedef区别？"></a>12. 宏定义和typedef区别？</h3><pre><code class="hljs">- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。- 宏不检查类型；typedef会检查数据类型。- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</code></pre><h3 id="13-宏定义和内联函数-inline-区别？"><a href="#13-宏定义和内联函数-inline-区别？" class="headerlink" title="13. 宏定义和内联函数(inline)区别？"></a>13. 宏定义和内联函数(inline)区别？</h3><pre><code class="hljs">- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。- 内联函数本身是函数，强调函数特性，具有重载等功能。- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</code></pre><h3 id="14-条件编译-ifdef-else-endif作用？"><a href="#14-条件编译-ifdef-else-endif作用？" class="headerlink" title="14. 条件编译#ifdef, #else, #endif作用？"></a>14. 条件编译#ifdef, #else, #endif作用？</h3><pre><code class="hljs">- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。- 用于子程序前加#define DEBUG用于程序调试。- 应对硬件的设置（机器类型等）。- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</code></pre><h3 id="15-区别以下几种变量？"><a href="#15-区别以下几种变量？" class="headerlink" title="15. 区别以下几种变量？"></a>15. 区别以下几种变量？</h3><pre><code class="hljs">    const int a;    int const a;    const int *a;    int *const a;- int const a和const int a均表示定义常量类型a。- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</code></pre><h3 id="16-volatile有什么作用？"><a href="#16-volatile有什么作用？" class="headerlink" title="16. volatile有什么作用？"></a>16. volatile有什么作用？</h3><pre><code class="hljs">- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。- 多线程中被几个任务共享的变量需要定义为volatile类型。</code></pre><h3 id="17-什么是常引用？"><a href="#17-什么是常引用？" class="headerlink" title="17. 什么是常引用？"></a>17. 什么是常引用？</h3><pre><code class="hljs">- 常引用可以理解为常量指针，形式为const typename &amp; refname = varname。- 常引用下，原变量值不会被别名所修改。- 原变量的值可以通过原名修改。- 常引用通常用作只读变量别名或是形参传递。</code></pre><h3 id="18-区别以下指针类型？"><a href="#18-区别以下指针类型？" class="headerlink" title="18. 区别以下指针类型？"></a>18. 区别以下指针类型？</h3><pre><code class="hljs">    int *p[10]    int (*p)[10]    int *p(int)    int (*p)(int)- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</code></pre><h3 id="19-常量指针和指针常量区别？"><a href="#19-常量指针和指针常量区别？" class="headerlink" title="19. 常量指针和指针常量区别？"></a>19. 常量指针和指针常量区别？</h3><pre><code class="hljs">- 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。- 指针常量是一个不能给改变指向的指针。如int *const p。</code></pre><h3 id="20-a和-amp-a有什么区别？"><a href="#20-a和-amp-a有什么区别？" class="headerlink" title="20. a和&amp;a有什么区别？"></a>20. a和&amp;a有什么区别？</h3><pre><code class="hljs">    假设数组int a[10];    int (*p)[10] = &amp;a;- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。- &amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</code></pre><h3 id="21-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="21. 数组名和指针（这里为指向数组首元素的指针）区别？"></a>21. 数组名和指针（这里为指向数组首元素的指针）区别？</h3><pre><code class="hljs">- 二者均可通过增减偏移量来访问数组中的元素。- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</code></pre><h3 id="22-野指针是什么？"><a href="#22-野指针是什么？" class="headerlink" title="22. 野指针是什么？"></a>22. 野指针是什么？</h3><pre><code class="hljs">- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。- 产生原因及解决办法：     - 指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。     - 指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</code></pre><h3 id="23-堆和栈的区别？"><a href="#23-堆和栈的区别？" class="headerlink" title="23. 堆和栈的区别？"></a>23. 堆和栈的区别？</h3><pre><code class="hljs">- 申请方式不同。    - 栈由系统自动分配。    - 堆由程序员手动分配。- 申请大小限制不同。    - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。    - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。- 申请效率不同。    - 栈由系统分配，速度快，不会有碎片。    - 堆由程序员分配，速度慢，且会有碎片。</code></pre><h3 id="24-delete和delete-区别？"><a href="#24-delete和delete-区别？" class="headerlink" title="24. delete和delete[]区别？"></a>24. delete和delete[]区别？</h3><pre><code class="hljs">- delete只会调用一次析构函数。- delete[]会调用数组中每个元素的析构函数。</code></pre><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a><span id = "oop">面向对象基础</span></h2><p>能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。</p><h3 id="1-面向对象三大特性？"><a href="#1-面向对象三大特性？" class="headerlink" title="1. 面向对象三大特性？"></a>1. 面向对象三大特性？</h3><pre><code class="hljs">- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。- 继承性：让某种类型对象获得另一个类型对象的属性和方法。- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</code></pre><h3 id="2-public-x2F-protected-x2F-private的区别？"><a href="#2-public-x2F-protected-x2F-private的区别？" class="headerlink" title="2. public&#x2F;protected&#x2F;private的区别？"></a>2. public&#x2F;protected&#x2F;private的区别？</h3><pre><code class="hljs">- public的变量和函数在类的内部外部都可以访问。- protected的变量和函数只能在类的内部和其派生类中访问。- private修饰的元素只能在类内访问。</code></pre><h3 id="3-对象存储空间？"><a href="#3-对象存储空间？" class="headerlink" title="3. 对象存储空间？"></a>3. 对象存储空间？</h3><pre><code class="hljs">- 非静态成员的数据类型大小之和。- 编译器加入的额外成员变量（如指向虚函数表的指针）。- 为了边缘对齐优化加入的padding。</code></pre><h3 id="4-C-空类有哪些成员函数"><a href="#4-C-空类有哪些成员函数" class="headerlink" title="4. C++空类有哪些成员函数?"></a>4. C++空类有哪些成员函数?</h3><pre><code class="hljs">- 首先，空类大小为1字节。- 默认函数有：    - 构造函数    - 析构函数    - 拷贝构造函数    - 赋值运算符</code></pre><h3 id="5-构造函数能否为虚函数，析构函数呢？"><a href="#5-构造函数能否为虚函数，析构函数呢？" class="headerlink" title="5. 构造函数能否为虚函数，析构函数呢？"></a>5. 构造函数能否为虚函数，析构函数呢？</h3><pre><code class="hljs">- 析构函数：    - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。    - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。    - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。- 构造函数：    - 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</code></pre><h3 id="6-构造函数调用顺序，析构函数呢？"><a href="#6-构造函数调用顺序，析构函数呢？" class="headerlink" title="6. 构造函数调用顺序，析构函数呢？"></a>6. 构造函数调用顺序，析构函数呢？</h3><pre><code class="hljs">- 调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。- 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。- 派生类的构造函数。- 析构函数与之相反。</code></pre><h3 id="7-拷贝构造函数中深拷贝和浅拷贝区别？"><a href="#7-拷贝构造函数中深拷贝和浅拷贝区别？" class="headerlink" title="7. 拷贝构造函数中深拷贝和浅拷贝区别？"></a>7. 拷贝构造函数中深拷贝和浅拷贝区别？</h3><pre><code class="hljs">- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。- 浅拷贝仅仅是拷贝指针字面值。- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</code></pre><h3 id="8-拷贝构造函数和赋值运算符重载的区别？"><a href="#8-拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="8. 拷贝构造函数和赋值运算符重载的区别？"></a>8. 拷贝构造函数和赋值运算符重载的区别？</h3><pre><code class="hljs">- 拷贝构造函数是函数，赋值运算符是运算符重载。- 拷贝构造函数会生成新的类对象，赋值运算符不能。- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现&quot;=&quot;的地方都是使用赋值运算符，如下：        Student s;        Student s1 = s;    // 调用拷贝构造函数        Student s2;        s2 = s;    // 赋值运算符操作**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**</code></pre><h3 id="9-虚函数和纯虚函数区别？"><a href="#9-虚函数和纯虚函数区别？" class="headerlink" title="9. 虚函数和纯虚函数区别？"></a>9. 虚函数和纯虚函数区别？</h3><pre><code class="hljs">- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</code></pre><h3 id="10-覆盖、重载和隐藏的区别？"><a href="#10-覆盖、重载和隐藏的区别？" class="headerlink" title="10. 覆盖、重载和隐藏的区别？"></a>10. 覆盖、重载和隐藏的区别？</h3><pre><code class="hljs"> - 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。 - 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。 - 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</code></pre><h3 id="11-在main执行之前执行的代码可能是什么？"><a href="#11-在main执行之前执行的代码可能是什么？" class="headerlink" title="11. 在main执行之前执行的代码可能是什么？"></a>11. 在main执行之前执行的代码可能是什么？</h3><pre><code class="hljs">- 全局对象的构造函数。</code></pre><h3 id="12-哪几种情况必须用到初始化成员列表？"><a href="#12-哪几种情况必须用到初始化成员列表？" class="headerlink" title="12. 哪几种情况必须用到初始化成员列表？"></a>12. 哪几种情况必须用到初始化成员列表？</h3><pre><code class="hljs">- 初始化一个const成员。- 初始化一个reference成员。- 调用一个基类的构造函数，而该函数有一组参数。- 调用一个数据成员对象的构造函数，而该函数有一组参数。</code></pre><h3 id="13-什么是虚指针？"><a href="#13-什么是虚指针？" class="headerlink" title="13. 什么是虚指针？"></a>13. 什么是虚指针？</h3><pre><code class="hljs">- 虚指针或虚函数指针是虚函数的实现细节。- 虚指针指向虚表结构。</code></pre><h3 id="14-重载和函数模板的区别？"><a href="#14-重载和函数模板的区别？" class="headerlink" title="14. 重载和函数模板的区别？"></a>14. 重载和函数模板的区别？</h3><pre><code class="hljs">- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。</code></pre><h3 id="15-this指针是什么？"><a href="#15-this指针是什么？" class="headerlink" title="15. this指针是什么？"></a>15. this指针是什么？</h3><pre><code class="hljs">- this指针是类的指针，指向对象的首地址。- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</code></pre><h3 id="16-类模板是什么？"><a href="#16-类模板是什么？" class="headerlink" title="16. 类模板是什么？"></a>16. 类模板是什么？</h3><pre><code class="hljs">- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</code></pre><h3 id="17-构造函数和析构函数调用时机？"><a href="#17-构造函数和析构函数调用时机？" class="headerlink" title="17. 构造函数和析构函数调用时机？"></a>17. 构造函数和析构函数调用时机？</h3><pre><code class="hljs">- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</code></pre><hr><h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a><span id = "stl">标准模板库</span></h2><p>STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：</p><ul><li><p>怎么用？</p><p>各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。</p></li><li><p>怎么实现？</p><p>本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。</p></li><li><p>如何避免错误？</p><p>在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。</p></li></ul><p><strong>string</strong></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        vector&lt;T&gt; vec;    插入元素：        vec.push_back(element);        vec.insert(iterator, element);    删除元素：        vec.pop_back();        vec.erase(iterator);    修改元素：        vec[position] = element;    遍历容器：        for(auto it = vec.begin(); it != vec.end(); ++it) &#123;......&#125;    其他：        vec.empty();    //判断是否空        vec.size();    // 实际元素        vec.capacity();    // 容器容量        vec.begin();    // 获得首迭代器        vec.end();    // 获得尾迭代器        vec.clear();    // 清空</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp">模拟Vector实现</a></p><ul><li><p>线性表，数组实现。</p><ul><li><p>支持随机访问。</p></li><li><p>插入删除操作需要大量移动数据。</p></li></ul></li><li><p>需要连续的物理存储空间。</p></li><li><p>每当大小不够时，重新分配内存（*2），并复制原内容。</p></li></ul><p>错误避免：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp">迭代器失效</a></p><ul><li><p>插入元素</p><ul><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ul></li><li><p>删除元素</p><ul><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ul></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        map&lt;T_key, T_value&gt; mymap;    插入元素：        mymap.insert(pair&lt;T_key, T_value&gt;(key, value));    // 同key不插入        mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value));    // 同key不插入        mymap[key] = value;    // 同key覆盖    删除元素：        mymap.erase(key);    // 按值删        mymap.erase(iterator);    // 按迭代器删    修改元素：        mymap[key] = new_value;    遍历容器：          for(auto it = mymap.begin(); it != mymap.end(); ++it) &#123;            cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;          &#125;</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/tree/master/code/RBTree">RBTree实现</a></p><ul><li><p>树状结构，RBTree实现。</p><ul><li><p>插入删除不需要数据复制。</p></li><li><p>操作复杂度仅跟树高有关。</p></li></ul></li><li><p>RBTree本身也是二叉排序树的一种，key值有序，且唯一。</p><ul><li>必须保证key可排序。</li></ul></li></ul><p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p><h3 id="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"><a href="#面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的" class="headerlink" title="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"></a><strong>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的</strong></h3><ol><li><p>它是二叉排序树（继承二叉排序树特显）：</p><ul><li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p></li></ul></li><li><p>它满足如下几点要求：</p><ul><li><p>树中所有节点非红即黑。</p></li><li><p>根节点必为黑节点。</p></li><li><p>红节点的子节点必为黑（黑节点子节点可为黑）。</p></li><li><p>从根到NULL的任何路径上黑结点数相同。</p></li></ul></li><li><p>查找时间一定可以控制在O(logn)。</p></li><li><p>红黑树的节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED = <span class="hljs-number">0</span>,<br>    BLACK = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span>*left, *right, *parent;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> data;<br>    Color color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p></li></ol><p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p><p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><hr><h2 id="编译及调试"><a href="#编译及调试" class="headerlink" title="编译及调试"></a><span id = "other">编译及调试</span></h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h3><p>预处理</p><ul><li><p>展开所有的宏定义，完成字符常量替换。</p></li><li><p>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</p></li><li><p>处理#include指令，将被包含的文件插入到该指令所在位置。</p></li><li><p>过滤掉所有注释语句。</p></li><li><p>添加行号和文件名标识。</p></li><li><p>保留所有#pragma编译器指令。</p></li></ul><p>编译</p><ul><li><p>词法分析。</p></li><li><p>语法分析。</p></li><li><p>语义分析。</p></li><li><p>中间语言生成。</p></li><li><p>目标代码生成与优化。</p></li></ul><p>链接</p><p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p><ul><li><p>静态链接</p><p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。</p><p>既然静态链接是对目标文件的打包，这里介绍些打包命令。</p><pre><code class="hljs">gcc -c test1.c    // 生成test1.ogcc -c test2.c    // 生成test2.car cr libtest.a test1.o test2.o</code></pre><p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li><li><p>动态链接</p><p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p><p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p><pre><code class="hljs">gcc -fPIC -c test1.c gcc -fPIC -c test2.cgcc -shared test1.o test2.o -o libtest.so</code></pre><p>使用动态链接的用法也和静态链接相同。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li></ul><p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是&#x2F;usr&#x2F;lib，我们可以将库文件拷贝到那个目录下再链接。</p><p>比较静态库和动态库我们可以得到二者的优缺点。</p><ul><li><p>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</p></li><li><p>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</p></li><li><p>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</p></li></ul><p>makefile编写</p><p>对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。</p><ul><li><p>基本规则</p><pre><code class="hljs">A:B(tab)&lt;command&gt;</code></pre><p>其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。</p></li><li><p>变量</p><p>makefile的书写非常像shell脚本，可以在文件中定义”变量名 &#x3D; 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><p>符号解析</p><ul><li><p>可重定位目标文件</p><p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p></li><li><p>解析符号表</p><p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p></li></ul><p>重定位</p><ul><li><p>合并节</p><p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p></li><li><p>重定位符号引用</p><p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p></li></ul><p>可执行目标文件</p><ul><li><p>ELF头部</p><p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p></li><li><p>段头部表</p><p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p></li><li><p>其他段</p><p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p></li></ul><p>加载</p><ul><li><p>克隆</p><p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p></li><li><p>重新映射</p><p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p></li><li><p>虚页调入</p><p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux工具-Skill-Tree</title>
    <link href="/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/"/>
    <url>/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a><a href="http://man.linuxde.net/par/2">Linux工具</a></h1><blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C&#x2F;C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I&#x2F;O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#pro">开发及调试</a></td><td align="center"><a href="#file">文件处理</a></td><td align="center"><a href="#sysinfo">性能分析</a></td><td align="center"><a href="#net">网络工具</a></td><td align="center"><a href="#other">其他</a></td></tr></tbody></table><ul><li><p>开发及调试</p><ul><li>编辑器：vim</li><li>编译器：gcc&#x2F;g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li><p>文件处理</p><ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li><p>性能分析</p><ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li><p>网络工具</p><ul><li>网卡配置：ifconfig </li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li><p>其他</p><ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a><span id = "pro">开发及调试</span></h2><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><h3 id="1-编辑器：vim"><a href="#1-编辑器：vim" class="headerlink" title="1.  编辑器：vim"></a>1.  编辑器：vim</h3><pre><code class="hljs">- 服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。- [详见](http://coolshell.cn/articles/5426.html)</code></pre><h3 id="2-编译器：gcc-x2F-g"><a href="#2-编译器：gcc-x2F-g" class="headerlink" title="2. 编译器：gcc&#x2F;g++"></a>2. 编译器：gcc&#x2F;g++</h3><pre><code class="hljs">- C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。- [详见](http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html)</code></pre><h3 id="3-调试工具：gdb"><a href="#3-调试工具：gdb" class="headerlink" title="3. 调试工具：gdb"></a>3. 调试工具：gdb</h3><pre><code class="hljs">- 服务器端调试必备。- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)</code></pre><h3 id="4-查看依赖库：ldd"><a href="#4-查看依赖库：ldd" class="headerlink" title="4. 查看依赖库：ldd"></a>4. 查看依赖库：ldd</h3><pre><code class="hljs">- 程序依赖库查询<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ldd后接可执行文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><br>ldd a.out<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-二进制文件分析：objdump"><a href="#5-二进制文件分析：objdump" class="headerlink" title="5. 二进制文件分析：objdump"></a>5. 二进制文件分析：objdump</h3><pre><code class="hljs">- 反汇编，需要理解汇编语言- [详见](http://man.linuxde.net/objdump)</code></pre><h3 id="6-ELF文件格式分析：readelf"><a href="#6-ELF文件格式分析：readelf" class="headerlink" title="6. ELF文件格式分析：readelf"></a>6. ELF文件格式分析：readelf</h3><pre><code class="hljs">- 可以得到ELF文件各段内容，分析链接、符号表等需要用到- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html)</code></pre><h3 id="7-跟踪进程中系统调用：strace"><a href="#7-跟踪进程中系统调用：strace" class="headerlink" title="7. 跟踪进程中系统调用：strace"></a>7. 跟踪进程中系统调用：strace</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)</code></pre><h3 id="8-跟踪进程栈：pstack"><a href="#8-跟踪进程栈：pstack" class="headerlink" title="8. 跟踪进程栈：pstack"></a>8. 跟踪进程栈：pstack</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#)</code></pre><h3 id="9-进程内存映射：pmap"><a href="#9-进程内存映射：pmap" class="headerlink" title="9. 进程内存映射：pmap"></a>9. 进程内存映射：pmap</h3><pre><code class="hljs">- 显示进程内存映射<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-x显示扩展信息，后接进程pid</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Address: 内存开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示信息：</span><br>    Kbytes: 占用内存的字节数<br>    RSS: 保留内存的字节数<br>    Dirty: 脏页的字节数（包括共享和私有的）<br>    Mode: 内存的权限：read、write、execute、shared、private<br>    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）<br>    Device: 设备名 (major:minor)<br><br>pmap -x 12345<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a><span id = "file">文件处理</span></h2><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><h3 id="1-文件查找：find"><a href="#1-文件查找：find" class="headerlink" title="1. 文件查找：find"></a>1. 文件查找：find</h3><pre><code class="hljs">按名查找：- 查找具体文件（一般方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name *.cpp<br></code></pre></td></tr></table></figure>- 查找具体文件（正则方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-regex为正则查找，-iregex为忽略大小写的正则查找</span> <br>  <br>find -regex &quot;.*.cpp$&quot;<br></code></pre></td></tr></table></figure>定制查找：- 按类型查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">f(file)为文件，d(dictionary)为目录，l(<span class="hljs-built_in">link</span>)为链接</span><br>  <br>find . -type f<br></code></pre></td></tr></table></figure>- 按时间查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mtime为修改时间</span><br>  <br>find . -type f -atime -7<br></code></pre></td></tr></table></figure>- 按大小查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br>  <br>find . -type f -size -1k<br></code></pre></td></tr></table></figure>- 按权限查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-perm后接权限</span><br><br>find . -type -perm 644<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-文本搜索：grep"><a href="#2-文本搜索：grep" class="headerlink" title="2. 文本搜索：grep"></a>2. 文本搜索：grep</h3><pre><code class="hljs">- 模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容</span><br><br>grep &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 多个模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容</span><br><br>grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 输出信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><br>grep -n &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></code></pre><h3 id="3-排序：sort"><a href="#3-排序：sort" class="headerlink" title="3. 排序：sort"></a>3. 排序：sort</h3><pre><code class="hljs">- 文件内容行排序<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-k N表示按各行第N列进行排序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r(reverse)为逆序排序</span><br><br>sort -n -k 1 test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-转换：tr"><a href="#4-转换：tr" class="headerlink" title="4. 转换：tr"></a>4. 转换：tr</h3><pre><code class="hljs">- 字符替换<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将打开文件中所有目标字符替换</span><br><br>cat test | tr &#x27;1&#x27; &#x27;2&#x27;<br></code></pre></td></tr></table></figure>- 字符删除<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d删除(delete)</span><br><br>cat test | tr -d &#x27;1&#x27;<br></code></pre></td></tr></table></figure>- 字符压缩<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s位于后部</span><br><br>cat test | tr &#x27; &#x27; -s<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-按列切分文本：cut"><a href="#5-按列切分文本：cut" class="headerlink" title="5. 按列切分文本：cut"></a>5. 按列切分文本：cut</h3><pre><code class="hljs">- 截取特定列<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为具体列范围</span><br><br>cut -f 1,2 test<br></code></pre></td></tr></table></figure>- 指定界定符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d后接界定符</span><br><br>cut -f 2 -d &#x27;,&#x27; new<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-按列拼接文本：paste"><a href="#6-按列拼接文本：paste" class="headerlink" title="6. 按列拼接文本：paste"></a>6. 按列拼接文本：paste</h3><pre><code class="hljs">- 按列拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br><br>paste test1 test2<br></code></pre></td></tr></table></figure>- 指定界定符拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照-d之后给出的界定符拼接</span><br><br>paste test1 test2 -d &quot;,&quot;<br></code></pre></td></tr></table></figure></code></pre><h3 id="7-统计行和字符：wc"><a href="#7-统计行和字符：wc" class="headerlink" title="7. 统计行和字符：wc"></a>7. 统计行和字符：wc</h3><pre><code class="hljs"> - 基本统计 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><br>wc -l test<br></code></pre></td></tr></table></figure></code></pre><h3 id="8-文本替换：sed"><a href="#8-文本替换：sed" class="headerlink" title="8. 文本替换：sed"></a>8. 文本替换：sed</h3><pre><code class="hljs">- 区别于上面的命令，sed是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9104.html)</code></pre><h3 id="9-数据流处理：awk"><a href="#9-数据流处理：awk" class="headerlink" title="9. 数据流处理：awk"></a>9. 数据流处理：awk</h3><pre><code class="hljs">- 区别于上面的命令，awk是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9070.html)</code></pre><hr><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><span id = "sysinfo">系统信息</span></h2><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I&#x2F;O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><h3 id="1-进程查询：ps"><a href="#1-进程查询：ps" class="headerlink" title="1. 进程查询：ps"></a>1. 进程查询：ps</h3><pre><code class="hljs">- 查看正在运行进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><br>ps -ef<br></code></pre></td></tr></table></figure>- 以完整格式显示所有进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息</span><br><br>ps -ajx<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-进程监控：top"><a href="#2-进程监控：top" class="headerlink" title="2. 进程监控：top"></a>2. 进程监控：top</h3><pre><code class="hljs">- 显示实时进程信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%<span class="hljs-built_in">id</span>表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><br>top<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-打开文件查询：lsof"><a href="#3-打开文件查询：lsof" class="headerlink" title="3. 打开文件查询：lsof"></a>3. 打开文件查询：lsof</h3><ul><li>查看占用某端口的进程</li></ul><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br>   <br>lsof -i:53<br></code></pre></td></tr></table></figure>- 查看某用户打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-u(user)为用户，后接用户名</span><br>   <br>lsof -u inx<br></code></pre></td></tr></table></figure>- 查看指定进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(process)为进程，后接进程PID</span><br>   <br>lsof -p 12345<br></code></pre></td></tr></table></figure>- 查看指定目录下被进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>   <br>lsof +d /test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-内存使用量：free"><a href="#4-内存使用量：free" class="headerlink" title="4. 内存使用量：free"></a>4. 内存使用量：free</h3><pre><code class="hljs">- 内存使用量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><br>free<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-监控性能指标：sar"><a href="#5-监控性能指标：sar" class="headerlink" title="5. 监控性能指标：sar"></a>5. 监控性能指标：sar</h3><pre><code class="hljs">监控CPU- 监控CPU负载<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里<span class="hljs-string">&quot;1&quot;</span>表示采样时间间隔是1秒，这里<span class="hljs-string">&quot;2&quot;</span>表示采样次数为2</span><br><br>sar -q 1 2<br></code></pre></td></tr></table></figure>- 监控CPU使用率<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示CPU使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span><br><br>sar -u 1 2<br></code></pre></td></tr></table></figure>监控内存- 查询内存<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示内存使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span> <br><br>sar -r 1 2<br></code></pre></td></tr></table></figure>- 页面交换查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">参数意义同上</span><br><br>sar -W 1 2<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a><span id = "net">网络工具</span></h2><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><h3 id="1-网卡配置（链路层）：ifconfig"><a href="#1-网卡配置（链路层）：ifconfig" class="headerlink" title="1. 网卡配置（链路层）：ifconfig"></a>1. 网卡配置（链路层）：ifconfig</h3><pre><code class="hljs">- 显示设备信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示已激活的网络设备信息</span><br><br>ifconfig<br></code></pre></td></tr></table></figure>- 启动关闭指定网卡<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">up为打开，down为关闭</span><br><br>ifconfig eth0 up<br></code></pre></td></tr></table></figure>- 配置IP地址<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为配置的IP地址</span><br><br>ifconfig eth0 192.168.1.1<br></code></pre></td></tr></table></figure>- 设置最大传输单元<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">前一个参数为具体网卡，后面为MTU的大小<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置链路层MTU值，通常为1500</span><br><br>ifconfig eth0 mtu 1500<br></code></pre></td></tr></table></figure>- 启用和关闭ARP协议<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat"><a href="#2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat" class="headerlink" title="2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat"></a>2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat</h3><pre><code class="hljs">- 网络接口信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示网卡信息，可结合ifconfig学习</span><br><br>netstat -i<br></code></pre></td></tr></table></figure>- 列出端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-l(listening)表示正在监听的端口</span><br><br>netstat -at<br></code></pre></td></tr></table></figure>- 显示端口统计信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(status)显示各协议信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><br>netstat -s<br></code></pre></td></tr></table></figure>- 显示使用某协议的应用名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><br>netstat -pt<br></code></pre></td></tr></table></figure>- 查找指定进程、端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个操作可以用lsof替代</span><br><br>netstat -ap | grep ssh<br>netstat -an | grep &#x27;:80&#x27;<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-查看路由表（网络层IP协议）：route"><a href="#3-查看路由表（网络层IP协议）：route" class="headerlink" title="3. 查看路由表（网络层IP协议）：route"></a>3. 查看路由表（网络层IP协议）：route</h3><pre><code class="hljs">- 查看路由信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过netstat -r(route)得到同样的路由表</span><br><br>route<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-检查网络连通性（网络层ICMP协议）：ping"><a href="#4-检查网络连通性（网络层ICMP协议）：ping" class="headerlink" title="4. 检查网络连通性（网络层ICMP协议）：ping"></a>4. 检查网络连通性（网络层ICMP协议）：ping</h3><pre><code class="hljs">- 检查是否连通<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">主要功能是检测网络连通性</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><br>ping baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-转发路径（网络层ICMP协议）：traceroute"><a href="#5-转发路径（网络层ICMP协议）：traceroute" class="headerlink" title="5. 转发路径（网络层ICMP协议）：traceroute"></a>5. 转发路径（网络层ICMP协议）：traceroute</h3><pre><code class="hljs">- 文件包途径的IP<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span></span><br><br>traceroute baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-网络Debug分析（网络层-x2F-传输层）：nc"><a href="#6-网络Debug分析（网络层-x2F-传输层）：nc" class="headerlink" title="6. 网络Debug分析（网络层&#x2F;传输层）：nc"></a>6. 网络Debug分析（网络层&#x2F;传输层）：nc</h3><pre><code class="hljs">- 端口扫描<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">黑客很喜欢</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描某服务器端口使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v(view)显示指令执行过程，-w(<span class="hljs-built_in">wait</span>)设置超时时长</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为扫描的端口范围</span> <br><br>nc -v -w 1 baidu.com  -z 75-1000<br></code></pre></td></tr></table></figure>- [其他详见](https://www.oschina.net/translate/linux-netcat-command)</code></pre><h3 id="7-命令行抓包（网络层-x2F-传输层）：tcpdump"><a href="#7-命令行抓包（网络层-x2F-传输层）：tcpdump" class="headerlink" title="7. 命令行抓包（网络层&#x2F;传输层）：tcpdump"></a>7. 命令行抓包（网络层&#x2F;传输层）：tcpdump</h3><pre><code class="hljs">- 抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。- [详见](http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)</code></pre><h3 id="8-域名解析工具（应用层DNS协议）：dig"><a href="#8-域名解析工具（应用层DNS协议）：dig" class="headerlink" title="8. 域名解析工具（应用层DNS协议）：dig"></a>8. 域名解析工具（应用层DNS协议）：dig</h3><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">应用层，DNS</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析过程中涉及的各级DNS服务器地址</span><br><br>dig baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="9-网络请求（应用层）：curl"><a href="#9-网络请求（应用层）：curl" class="headerlink" title="9. 网络请求（应用层）：curl"></a>9. 网络请求（应用层）：curl</h3><pre><code class="hljs">- [详见](http://www.cnblogs.com/gbyukg/p/3326825.html)</code></pre><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><span id = "other">其他</span></h2><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><h3 id="1-终止进程：kill"><a href="#1-终止进程：kill" class="headerlink" title="1. 终止进程：kill"></a>1. 终止进程：kill</h3><pre><code class="hljs">- 杀死具体进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加具体进程PID</span><br><br>kill 12345<br></code></pre></td></tr></table></figure>- 杀死某进程相关进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上<span class="hljs-string">&quot;-9&quot;</span>杀死某进程相关进程</span><br><br>kill -9 12345<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-修改文件权限：chmod"><a href="#2-修改文件权限：chmod" class="headerlink" title="2. 修改文件权限：chmod"></a>2. 修改文件权限：chmod</h3><pre><code class="hljs">- 更改文件权限<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件可以有三种权限，r(<span class="hljs-built_in">read</span>)，w(write)，x(execute)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><br>chmod u+r file<br>chmod 777 file<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-创建链接：ln"><a href="#3-创建链接：ln" class="headerlink" title="3. 创建链接：ln"></a>3. 创建链接：ln</h3><pre><code class="hljs">- 创建硬链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><br>ln file1 file2<br></code></pre></td></tr></table></figure>- 创建软（符号链接）链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><br>ln -s file1 file2<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-显示文件尾：tail"><a href="#4-显示文件尾：tail" class="headerlink" title="4. 显示文件尾：tail"></a>4. 显示文件尾：tail</h3><pre><code class="hljs">- 查看文件尾部<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志时常用</span><br><br>tail -f test<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-版本控制：git"><a href="#5-版本控制：git" class="headerlink" title="5. 版本控制：git"></a>5. 版本控制：git</h3><pre><code class="hljs">- 版本控制最好用的软件，没有之一。至少要知道&quot;git init&quot;，&quot;git add&quot;，&quot;git commit&quot;，&quot;git pull&quot;，&quot;git push&quot;几个命令。- [详见](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/)</code></pre><h3 id="6-设置别名：alias"><a href="#6-设置别名：alias" class="headerlink" title="6. 设置别名：alias"></a>6. 设置别名：alias</h3><pre><code class="hljs">- 常用命令添加别名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;.bashrc&quot;</span>文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><br>alias rm=&#x27;rm -i&#x27;<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed">代码</a></p><h3 id="1-单步调试：gdb"><a href="#1-单步调试：gdb" class="headerlink" title="1. 单步调试：gdb"></a>1. 单步调试：gdb</h3><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><h3 id="2-动态库依赖：ldd"><a href="#2-动态库依赖：ldd" class="headerlink" title="2. 动态库依赖：ldd"></a>2. 动态库依赖：ldd</h3><ul><li><p>命令：ldd .&#x2F;server</p></li><li><p>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</p></li></ul><h3 id="3-性能分析：top"><a href="#3-性能分析：top" class="headerlink" title="3. 性能分析：top"></a>3. 性能分析：top</h3><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><h3 id="4-系统调用：strace"><a href="#4-系统调用：strace" class="headerlink" title="4. 系统调用：strace"></a>4. 系统调用：strace</h3><ul><li><p>命令：strace .&#x2F;server</p></li><li><p>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</p></li></ul><h3 id="5-打印进程：ps"><a href="#5-打印进程：ps" class="headerlink" title="5. 打印进程：ps"></a>5. 打印进程：ps</h3><ul><li><p>命令：ps -ejH</p></li><li><p>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</p></li></ul><h3 id="6-打开文件：lsof"><a href="#6-打开文件：lsof" class="headerlink" title="6. 打开文件：lsof"></a>6. 打开文件：lsof</h3><ul><li><p>lsof -i:3000</p></li><li><p>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</p></li></ul><h3 id="7-修改权限：chmod"><a href="#7-修改权限：chmod" class="headerlink" title="7. 修改权限：chmod"></a>7. 修改权限：chmod</h3><ul><li><p>chmod 000 .&#x2F;index.html</p></li><li><p>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000&#x2F;index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</p></li></ul><h3 id="8-网卡信息：ifconfig"><a href="#8-网卡信息：ifconfig" class="headerlink" title="8. 网卡信息：ifconfig"></a>8. 网卡信息：ifconfig</h3><ul><li><p>ifconfig</p></li><li><p>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</p></li></ul><h3 id="9-抓包分析：tcpdump"><a href="#9-抓包分析：tcpdump" class="headerlink" title="9. 抓包分析：tcpdump"></a>9. 抓包分析：tcpdump</h3><ul><li><p>tcpdump -i eth0 port 3000</p></li><li><p>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式-url</title>
    <link href="/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/"/>
    <url>/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希表和完美哈希"><a href="#哈希表和完美哈希" class="headerlink" title="哈希表和完美哈希"></a><a href="https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html#perfect_hashing">哈希表和完美哈希</a></h2><h2 id="布隆过滤器的原理与实现"><a href="#布隆过滤器的原理与实现" class="headerlink" title="布隆过滤器的原理与实现"></a><a href="https://blog.51cto.com/u_12824426/2555710">布隆过滤器的原理与实现</a></h2><h2 id="布隆过滤器-阿里云开发者社区"><a href="#布隆过滤器-阿里云开发者社区" class="headerlink" title="布隆过滤器-阿里云开发者社区"></a><a href="https://developer.aliyun.com/article/773205">布隆过滤器-阿里云开发者社区</a></h2><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a>分布式面试题</h1><h2 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h2><h2 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h2><h2 id="分布式面试题-1"><a href="#分布式面试题-1" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h2>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-url</title>
    <link href="/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/"/>
    <url>/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手-x2F-四次挥手"><a href="#三次握手-x2F-四次挥手" class="headerlink" title="三次握手&#x2F;四次挥手"></a>三次握手&#x2F;四次挥手</h1><h2 id="TCP的三次握手四次挥手理解及面试题"><a href="#TCP的三次握手四次挥手理解及面试题" class="headerlink" title="TCP的三次握手四次挥手理解及面试题"></a><a href="https://www.cnblogs.com/xp1315458571/articles/11361140.html">TCP的三次握手四次挥手理解及面试题</a></h2><h2 id="三次握手-x2F-四次挥手中的丢失情况及处理机制"><a href="#三次握手-x2F-四次挥手中的丢失情况及处理机制" class="headerlink" title="三次握手&#x2F;四次挥手中的丢失情况及处理机制"></a><a href="https://blog.51cto.com/u_14888059/3812405#:~:text=%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%20SYN-ACK%20%E6%8A%A5%E6%96%87%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9B%9E%E4%B8%80%E4%B8%AA,ACK%20%E6%8A%A5%E6%96%87%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E5%85%A5%E5%88%B0%20ESTABLISH%20%E7%8A%B6%E6%80%81%E3%80%82">三次握手&#x2F;四次挥手中的丢失情况及处理机制</a></h2><h1 id="滑窗-x2F-流控-x2F-拥塞"><a href="#滑窗-x2F-流控-x2F-拥塞" class="headerlink" title="滑窗&#x2F;流控&#x2F;拥塞"></a>滑窗&#x2F;流控&#x2F;拥塞</h1><h2 id="关于TCP乱序和重传的问题"><a href="#关于TCP乱序和重传的问题" class="headerlink" title="关于TCP乱序和重传的问题"></a><a href="https://blog.csdn.net/cws1214/article/details/52430554">关于TCP乱序和重传的问题</a></h2><h2 id="HTTP-与TCP中Keep-Alive机制的区别"><a href="#HTTP-与TCP中Keep-Alive机制的区别" class="headerlink" title="HTTP 与TCP中Keep-Alive机制的区别"></a><a href="https://cloud.tencent.com/developer/article/1430022">HTTP 与TCP中Keep-Alive机制的区别</a></h2><h2 id="HTTP-keep-alive和TCP-keepalive的区别"><a href="#HTTP-keep-alive和TCP-keepalive的区别" class="headerlink" title="HTTP keep-alive和TCP keepalive的区别"></a><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别</a></h2><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-x2F-2协议“多路复用”实现原理"><a href="#HTTP-x2F-2协议“多路复用”实现原理" class="headerlink" title="HTTP&#x2F;2协议“多路复用”实现原理"></a><a href="https://segmentfault.com/a/1190000016975064">HTTP&#x2F;2协议“多路复用”实现原理</a></h2><h2 id="Http发展历程-多路复用"><a href="#Http发展历程-多路复用" class="headerlink" title="Http发展历程-多路复用"></a><a href="https://juejin.cn/post/6844903935648497678">Http发展历程-多路复用</a></h2><h2 id="WebSocket-是什么原理？为什么可以实现持久连接？"><a href="#WebSocket-是什么原理？为什么可以实现持久连接？" class="headerlink" title="WebSocket 是什么原理？为什么可以实现持久连接？"></a><a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理？为什么可以实现持久连接？</a></h2><h2 id="POST-PUT和PATCH的区别"><a href="#POST-PUT和PATCH的区别" class="headerlink" title="POST,PUT和PATCH的区别"></a><a href="https://www.jianshu.com/p/bee85cf4e33a">POST,PUT和PATCH的区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-url</title>
    <link href="/2022/05/07/Redis-url/"/>
    <url>/2022/05/07/Redis-url/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis面试题-笔经面经-牛客网"><a href="#Redis面试题-笔经面经-牛客网" class="headerlink" title="Redis面试题_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/837063?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis面试题_笔经面经_牛客网</a></h2><h2 id="Redis超高频面试题和参考答案汇总！-笔经面经-牛客网"><a href="#Redis超高频面试题和参考答案汇总！-笔经面经-牛客网" class="headerlink" title="Redis超高频面试题和参考答案汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/941154?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis超高频面试题和参考答案汇总！_笔经面经_牛客网</a></h2><h2 id="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"><a href="#最全面的Redis缓存雪崩、击穿、穿透问题解决方案" class="headerlink" title="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"></a><a href="https://segmentfault.com/a/1190000039300423">最全面的Redis缓存雪崩、击穿、穿透问题解决方案</a></h2><h2 id="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"><a href="#Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级" class="headerlink" title="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"></a><a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></h2><h2 id="Redis-主从、哨兵和集群-区别"><a href="#Redis-主从、哨兵和集群-区别" class="headerlink" title="Redis 主从、哨兵和集群 区别"></a><a href="https://blog.csdn.net/u014527619/article/details/88232178">Redis 主从、哨兵和集群 区别</a></h2><h2 id="Memcached与Redis有什么区别"><a href="#Memcached与Redis有什么区别" class="headerlink" title="Memcached与Redis有什么区别"></a><a href="https://segmentfault.com/a/1190000023217491">Memcached与Redis有什么区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-url</title>
    <link href="/2022/05/07/Mysql-url/"/>
    <url>/2022/05/07/Mysql-url/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><h2 id="MySQL超高频面试题汇总！-笔经面经-牛客网"><a href="#MySQL超高频面试题汇总！-笔经面经-牛客网" class="headerlink" title="MySQL超高频面试题汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/922991?type=post&order=jing&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1650335022589">MySQL超高频面试题汇总！_笔经面经_牛客网</a></h2><h2 id="B-树，B树，聚集索引，非聚集索引"><a href="#B-树，B树，聚集索引，非聚集索引" class="headerlink" title="B+树，B树，聚集索引，非聚集索引"></a><a href="https://blog.csdn.net/weixin_30565199/article/details/95851132">B+树，B树，聚集索引，非聚集索引</a></h2><h2 id="MySQL为什么用B-树存储索引？"><a href="#MySQL为什么用B-树存储索引？" class="headerlink" title="MySQL为什么用B+树存储索引？"></a><a href="https://blog.csdn.net/dl674756321/article/details/102987984">MySQL为什么用B+树存储索引？</a></h2><h2 id="高度为3的B-树能存多少行数据"><a href="#高度为3的B-树能存多少行数据" class="headerlink" title="高度为3的B+树能存多少行数据?"></a><a href="https://www.1024sou.com/article/40.html">高度为3的B+树能存多少行数据?</a></h2><h1 id="模糊查询与联合索引"><a href="#模糊查询与联合索引" class="headerlink" title="模糊查询与联合索引"></a>模糊查询与联合索引</h1><h2 id="LIKE-模糊查询概述"><a href="#LIKE-模糊查询概述" class="headerlink" title="LIKE%模糊查询概述"></a><a href="https://blog.csdn.net/weixin_34081595/article/details/93658047?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">LIKE%模糊查询概述</a></h2><h2 id="LIKE-开头的模糊查询的解决方法"><a href="#LIKE-开头的模糊查询的解决方法" class="headerlink" title="LIKE%开头的模糊查询的解决方法"></a><a href="https://blog.csdn.net/qq_42539533/article/details/93137526?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">LIKE%开头的模糊查询的解决方法</a></h2><h2 id="联合索引在B-树上的存储结构及数据查找方式"><a href="#联合索引在B-树上的存储结构及数据查找方式" class="headerlink" title="联合索引在B+树上的存储结构及数据查找方式"></a><a href="https://www.cnblogs.com/ibigboy/p/12373978.html">联合索引在B+树上的存储结构及数据查找方式</a></h2><h2 id="索引最左前缀匹配原则"><a href="#索引最左前缀匹配原则" class="headerlink" title="索引最左前缀匹配原则"></a><a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">索引最左前缀匹配原则</a></h2><h1 id="事务与MVCC机制"><a href="#事务与MVCC机制" class="headerlink" title="事务与MVCC机制"></a>事务与MVCC机制</h1><h2 id="MySql解决幻读-x2F-不可重复读以及MVCC机制"><a href="#MySql解决幻读-x2F-不可重复读以及MVCC机制" class="headerlink" title="MySql解决幻读&#x2F;不可重复读以及MVCC机制"></a><a href="https://blog.csdn.net/qq_42799615/article/details/110942949">MySql解决幻读&#x2F;不可重复读以及MVCC机制</a></h2><h2 id="MySQL-如何解决幻读（MVCC-原理分析）"><a href="#MySQL-如何解决幻读（MVCC-原理分析）" class="headerlink" title="MySQL 如何解决幻读（MVCC 原理分析）"></a><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析）</a></h2><h2 id="从ReadView深入理解MySql-MVCC原理"><a href="#从ReadView深入理解MySql-MVCC原理" class="headerlink" title="从ReadView深入理解MySql MVCC原理"></a><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></h2><h2 id="MySQL间隙锁、Next-Key-Lock主要知识点"><a href="#MySQL间隙锁、Next-Key-Lock主要知识点" class="headerlink" title="MySQL间隙锁、Next-Key Lock主要知识点"></a><a href="https://www.jianshu.com/p/d5c2613cbb81">MySQL间隙锁、Next-Key Lock主要知识点</a></h2><h1 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h1><h2 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a><a href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别（9个不同点）</a></h2><h2 id="Innodb-Purge简介"><a href="#Innodb-Purge简介" class="headerlink" title="Innodb Purge简介"></a><a href="https://juejin.cn/post/6844903686393561096">Innodb Purge简介</a></h2><h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><h2 id="MySQL教程-编程入门教程-牛客网"><a href="#MySQL教程-编程入门教程-牛客网" class="headerlink" title="MySQL教程_编程入门教程_牛客网"></a><a href="https://www.nowcoder.com/tutorial/10006/ac36af02f71d414aa43650a4e682bf36">MySQL教程_编程入门教程_牛客网</a></h2><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="我终于看懂了HBase"><a href="#我终于看懂了HBase" class="headerlink" title="我终于看懂了HBase"></a><a href="https://zhuanlan.zhihu.com/p/145551967">我终于看懂了HBase</a></h2><h2 id="入门HBase，看这一篇就够了"><a href="#入门HBase，看这一篇就够了" class="headerlink" title="入门HBase，看这一篇就够了"></a><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></h2>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-url</title>
    <link href="/2022/05/07/C++-url/"/>
    <url>/2022/05/07/C++-url/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="C-教程-编程入门教程-牛客网"><a href="#C-教程-编程入门教程-牛客网" class="headerlink" title="C++教程_编程入门教程_牛客网"></a><a href="http://c.biancheng.net/cplus/polymorphism/">C++教程_编程入门教程_牛客网</a></h2><h2 id="C-多态与虚函数"><a href="#C-多态与虚函数" class="headerlink" title="C++多态与虚函数"></a><a href="https://www.nowcoder.com/tutorial/10003/a0681e4c80204ac8b3fe367b3eda47f3">C++多态与虚函数</a></h2><h1 id="C-高级特性"><a href="#C-高级特性" class="headerlink" title="C++高级特性"></a>C++高级特性</h1><h2 id="智能指针详解-博客园"><a href="#智能指针详解-博客园" class="headerlink" title="智能指针详解-博客园"></a><a href="https://www.cnblogs.com/linuxandmcu/p/10409723.html">智能指针详解-博客园</a></h2><h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a><a href="http://c.biancheng.net/view/7829.html">C++11右值引用</a></h2><h2 id="右值引用-amp-转移语义-amp-完美转发"><a href="#右值引用-amp-转移语义-amp-完美转发" class="headerlink" title="右值引用 &amp; 转移语义 &amp; 完美转发"></a><a href="https://www.irimsky.top/archives/296/">右值引用 &amp; 转移语义 &amp; 完美转发</a></h2><h1 id="STL原理"><a href="#STL原理" class="headerlink" title="STL原理"></a>STL原理</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="deque容器底层实现原理（深度剖析）"><a href="#deque容器底层实现原理（深度剖析）" class="headerlink" title="deque容器底层实现原理（深度剖析）"></a><a href="http://c.biancheng.net/view/6908.html">deque容器底层实现原理（深度剖析）</a></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-url</title>
    <link href="/2022/05/07/Linux-url/"/>
    <url>/2022/05/07/Linux-url/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h1><h2 id="WebServer项目概述-ZWiley的随记"><a href="#WebServer项目概述-ZWiley的随记" class="headerlink" title="WebServer项目概述 - ZWiley的随记"></a><a href="https://zwiley.github.io/mybook/webserver/0%20%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/">WebServer项目概述 - ZWiley的随记</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（一）"><a href="#WebServer服务器项目可能会被问到的问题（一）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（一）"></a><a href="https://www.nowcoder.com/discuss/934904">WebServer服务器项目可能会被问到的问题（一）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（二）"><a href="#WebServer服务器项目可能会被问到的问题（二）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（二）"></a><a href="https://www.nowcoder.com/discuss/939267?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题（二）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题-三-完结"><a href="#WebServer服务器项目可能会被问到的问题-三-完结" class="headerlink" title="WebServer服务器项目可能会被问到的问题(三)完结"></a><a href="https://www.nowcoder.com/discuss/945403?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题(三)完结</a></h2><h2 id="Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读"><a href="#Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读" class="headerlink" title="Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读"></a><a href="https://read.douban.com/reader/ebook/15233070/?dcs=bookshelf">Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读</a></h2><h2 id="qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器"><a href="#qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器" class="headerlink" title="qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器"></a><a href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器</a></h2><h2 id="彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云"><a href="#彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云" class="headerlink" title="彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云"></a><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云</a></h2><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金"><a href="#虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金" class="headerlink" title="虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金"></a><a href="https://juejin.cn/post/6990237426903957540">虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金</a></h2><h2 id="linux下进程和线程状态查看"><a href="#linux下进程和线程状态查看" class="headerlink" title="linux下进程和线程状态查看"></a><a href="https://blog.csdn.net/huangjin0507/article/details/77848386">linux下进程和线程状态查看</a></h2><h2 id="socket阻塞和非阻塞有哪些影响-CSDN"><a href="#socket阻塞和非阻塞有哪些影响-CSDN" class="headerlink" title="socket阻塞和非阻塞有哪些影响-CSDN"></a><a href="https://blog.csdn.net/mayue_web/article/details/82873115">socket阻塞和非阻塞有哪些影响-CSDN</a></h2><h2 id="句柄和文件描述符-简书"><a href="#句柄和文件描述符-简书" class="headerlink" title="句柄和文件描述符-简书"></a><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符-简书</a></h2><h2 id="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"><a href="#Linux文件存储结构，包括目录项、inode、数据块-C语言中文网" class="headerlink" title="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"></a><a href="http://c.biancheng.net/cpp/html/2780.html">Linux文件存储结构，包括目录项、inode、数据块-C语言中文网</a></h2><h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令与shell-菜鸟教程"><a href="#Linux命令与shell-菜鸟教程" class="headerlink" title="Linux命令与shell- 菜鸟教程"></a><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令与shell- 菜鸟教程</a></h2><h2 id="Linux命令大全教程"><a href="#Linux命令大全教程" class="headerlink" title="Linux命令大全教程"></a><a href="https://www.yiibai.com/linux/lsof.html">Linux命令大全教程</a></h2><h2 id="shell脚本指南"><a href="#shell脚本指南" class="headerlink" title="shell脚本指南"></a><a href="http://c.biancheng.net/view/706.html">shell脚本指南</a></h2><h2 id="linux的top命令参数详解-博客园"><a href="#linux的top命令参数详解-博客园" class="headerlink" title="linux的top命令参数详解-博客园"></a><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html">linux的top命令参数详解-博客园</a></h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校招面经-url</title>
    <link href="/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/"/>
    <url>/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="十道海量数据处理面试题与十个方法大总结"><a href="#十道海量数据处理面试题与十个方法大总结" class="headerlink" title="十道海量数据处理面试题与十个方法大总结"></a><a href="https://blog.csdn.net/v_JULY_v/article/details/6279498?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">十道海量数据处理面试题与十个方法大总结</a></h2><h2 id="海量数据处理-计数排序—牛客"><a href="#海量数据处理-计数排序—牛客" class="headerlink" title="海量数据处理 + 计数排序—牛客"></a><a href="https://www.nowcoder.com/issue/tutorial?zhuanlanId=B0Od3m&uuid=7e01693652144405aee18a17acd2a3f4">海量数据处理 + 计数排序—牛客</a></h2><h2 id=""><a href="#" class="headerlink" title=""></a><a href="/2022/05/11/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-Skill-Tree/" title="‘海量数据处理-Skill-Tree‘">‘海量数据处理-Skill-Tree‘</a></h2><h2 id="海量数据处理-advanced-java"><a href="#海量数据处理-advanced-java" class="headerlink" title="海量数据处理-advanced-java"></a><a href="https://github.com/doocs/advanced-java/tree/main/docs/big-data">海量数据处理-advanced-java</a></h2><h2 id="面试题：从n个数中找出第K大的数"><a href="#面试题：从n个数中找出第K大的数" class="headerlink" title="面试题：从n个数中找出第K大的数"></a><a href="https://blog.csdn.net/orangefly0214/article/details/86527462">面试题：从n个数中找出第K大的数</a></h2><h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="互联网大厂最爱问的智力题总结（带详细答案）"><a href="#互联网大厂最爱问的智力题总结（带详细答案）" class="headerlink" title="互联网大厂最爱问的智力题总结（带详细答案）"></a><a href="https://www.nowcoder.com/discuss/754712?type=1&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack">互联网大厂最爱问的智力题总结（带详细答案）</a></h2><h1 id="常见排序方法实现"><a href="#常见排序方法实现" class="headerlink" title="常见排序方法实现"></a>常见排序方法实现</h1><h2 id="创建堆，堆排序的详细实现过程，C-完整代码"><a href="#创建堆，堆排序的详细实现过程，C-完整代码" class="headerlink" title="创建堆，堆排序的详细实现过程，C++完整代码"></a><a href="https://blog.csdn.net/ahfytao/article/details/47681221">创建堆，堆排序的详细实现过程，C++完整代码</a></h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bigsai/p/13396391.html">桶排序</a></h2><h1 id="C-面经"><a href="#C-面经" class="headerlink" title="C++面经"></a>C++面经</h1><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a><a href="https://xiaolincoding.com/">小林coding</a></h2><h2 id="C-x2F-C-技术面试基础知识总结-huihut"><a href="#C-x2F-C-技术面试基础知识总结-huihut" class="headerlink" title="C&#x2F;C++ 技术面试基础知识总结-huihut"></a><a href="https://interview.huihut.com/#/">C&#x2F;C++ 技术面试基础知识总结-huihut</a></h2><h2 id="阿秀的学习笔记"><a href="#阿秀的学习笔记" class="headerlink" title="阿秀的学习笔记"></a><a href="https://interviewguide.cn/#/README">阿秀的学习笔记</a></h2><h2 id="帅地玩编程"><a href="#帅地玩编程" class="headerlink" title="帅地玩编程"></a><a href="https://www.iamshuaidi.com/">帅地玩编程</a></h2><h2 id="【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网"><a href="#【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网" class="headerlink" title="【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网"></a><a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网</a></h2><h2 id="牛客网收藏面经"><a href="#牛客网收藏面经" class="headerlink" title="牛客网收藏面经"></a><a href="https://www.nowcoder.com/profile/674401673/following-posts">牛客网收藏面经</a></h2><h2 id="GoGoCoder面经"><a href="#GoGoCoder面经" class="headerlink" title="GoGoCoder面经"></a><a href="https://gogocoder.com/face">GoGoCoder面经</a></h2><h2 id="C-工程师精选面经汇总-校招实习社招-牛客网-牛客网"><a href="#C-工程师精选面经汇总-校招实习社招-牛客网-牛客网" class="headerlink" title="C++工程师精选面经汇总_校招实习社招_牛客网_牛客网"></a><a href="https://www.nowcoder.com/discuss/experience?tagId=640">C++工程师精选面经汇总_校招实习社招_牛客网_牛客网</a></h2><h1 id="Java面经"><a href="#Java面经" class="headerlink" title="Java面经"></a>Java面经</h1><h2 id="Java-全栈知识体系"><a href="#Java-全栈知识体系" class="headerlink" title="Java 全栈知识体系"></a><a href="https://pdai.tech/">Java 全栈知识体系</a></h2>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厂笔试参考资料-url</title>
    <link href="/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/"/>
    <url>/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/</url>
    
    <content type="html"><![CDATA[<h1 id="ACM输入输出"><a href="#ACM输入输出" class="headerlink" title="ACM输入输出"></a>ACM输入输出</h1><h2 id="ACM输入方式-C-代码先锋网"><a href="#ACM输入方式-C-代码先锋网" class="headerlink" title="ACM输入方式-C++ - 代码先锋网"></a><a href="https://www.codeleading.com/article/50865910043/">ACM输入方式-C++ - 代码先锋网</a></h2><h2 id="C-使用stringstream与getline-分割字符串"><a href="#C-使用stringstream与getline-分割字符串" class="headerlink" title="C++使用stringstream与getline()分割字符串"></a><a href="https://blog.csdn.net/qq_36743440/article/details/91999615">C++使用stringstream与getline()分割字符串</a></h2><h2 id="C-中的cin以及stringstream"><a href="#C-中的cin以及stringstream" class="headerlink" title="C++中的cin以及stringstream"></a><a href="https://blog.csdn.net/flow_specter/article/details/116503515">C++中的cin以及stringstream</a></h2><h2 id="ACM模式数组构建二叉树"><a href="#ACM模式数组构建二叉树" class="headerlink" title="ACM模式数组构建二叉树"></a><a href="https://blog.csdn.net/m0_47240785/article/details/123406393">ACM模式数组构建二叉树</a></h2><h2 id="完全二叉树的顺序储存结构（C-完整代码）"><a href="#完全二叉树的顺序储存结构（C-完整代码）" class="headerlink" title="完全二叉树的顺序储存结构（C++完整代码）"></a><a href="https://blog.csdn.net/qq_52284035/article/details/118025460">完全二叉树的顺序储存结构（C++完整代码）</a></h2><h1 id="STL基础及模板"><a href="#STL基础及模板" class="headerlink" title="STL基础及模板"></a>STL基础及模板</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="C-STL中Map的按Key排序和按Value排序"><a href="#C-STL中Map的按Key排序和按Value排序" class="headerlink" title="C++ STL中Map的按Key排序和按Value排序"></a><a href="https://blog.csdn.net/iicy266/article/details/11906189">C++ STL中Map的按Key排序和按Value排序</a></h2><h2 id="优先队列详解-ACM例题分析"><a href="#优先队列详解-ACM例题分析" class="headerlink" title="优先队列详解+ACM例题分析"></a><a href="https://blog.csdn.net/qq_38492462/article/details/78631091">优先队列详解+ACM例题分析</a></h2><h1 id="大厂笔试题解"><a href="#大厂笔试题解" class="headerlink" title="大厂笔试题解"></a>大厂笔试题解</h1><h2 id="4-6-华为笔试题解-笔经面经-牛客网"><a href="#4-6-华为笔试题解-笔经面经-牛客网" class="headerlink" title="4.6 华为笔试题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/924780">4.6 华为笔试题解_笔经面经_牛客网</a></h2><h2 id="腾讯2022实习生笔试情况与题解-笔经面经-牛客网"><a href="#腾讯2022实习生笔试情况与题解-笔经面经-牛客网" class="headerlink" title="腾讯2022实习生笔试情况与题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/940859">腾讯2022实习生笔试情况与题解_笔经面经_牛客网</a></h2><h2 id="拓扑排序-知乎"><a href="#拓扑排序-知乎" class="headerlink" title="拓扑排序 - 知乎"></a><a href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序 - 知乎</a></h2>]]></content>
    
    
    <categories>
      
      <category>大厂笔试参考资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Organized-URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件描述符及三种拷贝命令</title>
    <link href="/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-文件描述符概念"><a href="#一-文件描述符概念" class="headerlink" title="一. 文件描述符概念"></a>一. 文件描述符概念</h1><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符</p></blockquote><p><strong>关于文件描述符，Linux内核维护了3个数据结构</strong></p><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137792.png"><br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137233.gif"></p><ul><li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的</li><li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样(概率很低)</li><li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况</li></ul><hr><h1 id="二-Linux文件和目录"><a href="#二-Linux文件和目录" class="headerlink" title="二. Linux文件和目录"></a>二. Linux文件和目录</h1><p>Linux文件是树形结构，inode是平坦结构，通过inode-&gt;i_mode字段，即S_ISREG、S_ISDIR两个宏判断是哪个类型。</p><ul><li><p>普通文件：<strong>inode</strong>里面存储元数据，inode索引到block，block存储数据</p></li><li><p>目录文件：inode索引到block，block中存储许多dirent目录条目，即名字到inode number的映射表<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138975.webp"></p></li></ul><p>目录文件的block区域如下：<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138621.webp"></p><p>内存的树形结构：</p><ul><li>dentry 绑定到唯一一个 inode 结构体；</li><li>dentry 有父，子，兄弟的索引路径，有这个就足够在内存中构建一个树了，并且事实也确实如此；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>  *<span class="hljs-title">d_parent</span>;</span>   <span class="hljs-comment">/* 父节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span>     <span class="hljs-title">d_name</span>;</span>      <span class="hljs-comment">// 名字</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>   *<span class="hljs-title">d_inode</span>;</span>    <span class="hljs-comment">// inode 结构体</span><br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_child</span>;</span>     <span class="hljs-comment">/* 兄弟节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span>   <span class="hljs-comment">/* 子节点 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="三-ln命令"><a href="#三-ln命令" class="headerlink" title="三. ln命令"></a>三. ln命令</h1><ul><li><p>软链接：软链接文件是一个全新的文件，有独立的 inode，有自己的 block ，内容是一段 path 路径，这个路径直接指向源文件；</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139893.webp"></p></li><li><p>硬链接：</p><blockquote><p>硬链接文件其实并没有新建文件（也就是说，没有消耗 inode 和 文件所需的 block 块）；</p><p>硬链接其实是修改了当前目录所在的目录文件，加了一个 dirent 而已，这个 dirent 用一个新的 name 名字指向原来的 inode number；</p><p>由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：<strong>不能跨文件系统。因为，不同文件系统的 inode 管理都是独立的。</strong></p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139421.webp"></p><p>总结：<strong>硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化。新的 name 指向原来的 inode。</strong></p><hr><h1 id="四-mv命令"><a href="#四-mv命令" class="headerlink" title="四. mv命令"></a>四. mv命令</h1><ul><li>源文件和目标文件在同一文件系统下：</li></ul><blockquote><p>mv 命令的核心操作是系统调用 rename ，rename 从内核实现来说只涉及到元数据的操作，只涉及到 dirent 的增删；</p><p><strong>inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。</strong></p></blockquote><br><ul><li>源文件和目标文件不在同一文件系统下：</li></ul><blockquote><p> 系统调用 rename 的时候，如果<strong>源</strong>和<strong>目的</strong>不在同一文件系统时，会报告 EXDEV 的错误码，提示该调用不能跨文件系统。</p></blockquote><p><strong>这个时候操作分成两步走，先 copy ，后 remove：</strong></p><ol><li><p>走不了 rename ，那么就退化成 copy ，也就是真正的拷贝。读取源文件，写入目标位置，生成一个全新的目标文件副本；</p><blockquote><p>这里调用的 copy_reg 的函数封装；</p><p>ln，mv，cp 是在 coreutils 库里的命令，公用函数本身就是可以复用的；</p></blockquote></li><li><p>删除源文件，使用 rm 函数删除；</p></li></ol><hr><h1 id="五-cp命令"><a href="#五-cp命令" class="headerlink" title="五. cp命令"></a>五. cp命令</h1><p><a href="https://juejin.cn/post/6939328247922425869">深度剖析 Linux cp 的秘密-博客</a></p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h1><ol><li>目录文件是一种特殊的文件，可以理解成存储的是 dirent 列表。dirent 只是名字到 inode 的映射，这个是树形结构的基础；</li><li>常说目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；</li><li>ln -s 创建软链接文件，软链接文件是一个独立的新文件，有一个新的 inode ，有新的 dentry，文件类型为 link，文件内容就是<strong>一条指向源的路径</strong>，所以<strong>软链的创建可以无视文件系统，跨越山河；</strong></li><li>ln 默认创建硬连接，硬链接文件只在目录文件里添加了一个新 dirent 项 (新name:原inode)，文件 inode 还是和原文件同一个，<strong>所以硬链接不能跨文件系统（因为不同的文件系统是独立的一套 inode 管理方式，不同的文件系统实例对 inode number 的解释各有不同）；</strong></li><li>ln 命令貌似创建出了新文件，但其实不然，ln 只跟元数据相关，涉及到 dirent  的变动，<strong>不涉及到数据的拷贝</strong>，起不到数据备份的目的；</li><li>mv 其实是调用 rename 调用，<strong>在同一个文件系统中不涉及到数据拷贝，只涉及到元数据变更</strong>（ dirent 的增删 ），所以速度也很快。但如果 mv 的源和目的<strong>在不同的文件系统，那么就会退化成真正的 copy ，会涉及到数据拷贝</strong>，这个时候速度相对慢一些，慢成什么样子？就跟 cp 命令一样；</li><li>cp 命令才是真正的数据拷贝命令，速度可能相对慢一些，但是 cp 命令有 –spare 可以优化拷贝速度，针对空洞和全 0 数据，可以跳过，从而<strong>针对稀疏文件可以节省大量磁盘 IO</strong>；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
