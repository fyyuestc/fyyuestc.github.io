<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux工具-Skill-Tree</title>
    <link href="/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/"/>
    <url>/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a><a href="http://man.linuxde.net/par/2">Linux工具</a></h1><blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C&#x2F;C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I&#x2F;O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#pro">开发及调试</a></td><td align="center"><a href="#file">文件处理</a></td><td align="center"><a href="#sysinfo">性能分析</a></td><td align="center"><a href="#net">网络工具</a></td><td align="center"><a href="#other">其他</a></td></tr></tbody></table><ul><li><h2 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a>开发及调试</h2><ul><li>编辑器：vim</li><li>编译器：gcc&#x2F;g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><ul><li>网卡配置：ifconfig </li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="开发及调试-1"><a href="#开发及调试-1" class="headerlink" title="开发及调试"></a><span id = "pro">开发及调试</span></h3><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><ol><li><p>编辑器：vim</p><ul><li>服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。</li><li><a href="http://coolshell.cn/articles/5426.html">详见</a></li></ul></li><li><p>编译器：gcc&#x2F;g++</p><ul><li>C&#x2F;C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。</li><li><a href="http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html">详见</a></li></ul></li><li><p>调试工具：gdb</p><ul><li>服务器端调试必备。</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">详见</a></li></ul></li><li><p>查看依赖库：ldd</p><ul><li>程序依赖库查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ldd后接可执行文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><br>ldd a.out<br></code></pre></td></tr></table></figure></li></ul></li><li><p>二进制文件分析：objdump</p><ul><li>反汇编，需要理解汇编语言</li><li><a href="http://man.linuxde.net/objdump">详见</a></li></ul></li><li><p>ELF文件格式分析：readelf</p><ul><li>可以得到ELF文件各段内容，分析链接、符号表等需要用到</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html">详见</a></li></ul></li><li><p>跟踪进程中系统调用：strace</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html">详见</a></li></ul></li><li><p>跟踪进程栈：pstack</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#">详见</a></li></ul></li><li><p>进程内存映射：pmap</p><ul><li>显示进程内存映射<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-x显示扩展信息，后接进程pid</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Address: 内存开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示信息：</span><br>    Kbytes: 占用内存的字节数<br>    RSS: 保留内存的字节数<br>    Dirty: 脏页的字节数（包括共享和私有的）<br>    Mode: 内存的权限：read、write、execute、shared、private<br>    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）<br>    Device: 设备名 (major:minor)<br><br>pmap -x 12345<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="文件处理-1"><a href="#文件处理-1" class="headerlink" title="文件处理"></a><span id = "file">文件处理</span></h3><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><ol><li><p>文件查找：find</p><p> 按名查找：</p><ul><li><p>查找具体文件（一般方式）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name *.cpp<br></code></pre></td></tr></table></figure></li><li><p>查找具体文件（正则方式）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-regex为正则查找，-iregex为忽略大小写的正则查找</span> <br>  <br>find -regex &quot;.*.cpp$&quot;<br></code></pre></td></tr></table></figure></li></ul><p> 定制查找：</p><ul><li><p>按类型查找</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">f(file)为文件，d(dictionary)为目录，l(<span class="hljs-built_in">link</span>)为链接</span><br>  <br>find . -type f<br></code></pre></td></tr></table></figure></li><li><p>按时间查找</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mtime为修改时间</span><br>  <br>find . -type f -atime -7<br></code></pre></td></tr></table></figure></li><li><p>按大小查找</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br>  <br>find . -type f -size -1k<br></code></pre></td></tr></table></figure></li><li><p>按权限查询</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-perm后接权限</span><br><br>find . -type -perm 644<br></code></pre></td></tr></table></figure></li></ul></li><li><p>文本搜索：grep</p><ul><li><p>模式匹配</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容</span><br><br>grep &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></li><li><p>多个模式匹配</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容</span><br><br>grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></li><li><p>输出信息</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><br>grep -n &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></li></ul></li><li><p>排序：sort</p><ul><li>文件内容行排序 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-k N表示按各行第N列进行排序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r(reverse)为逆序排序</span><br><br>sort -n -k 1 test<br></code></pre></td></tr></table></figure></li></ul></li><li><p>转换：tr</p><ul><li><p>字符替换</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将打开文件中所有目标字符替换</span><br><br>cat test | tr &#x27;1&#x27; &#x27;2&#x27;<br></code></pre></td></tr></table></figure></li><li><p>字符删除</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d删除(delete)</span><br><br>cat test | tr -d &#x27;1&#x27;<br></code></pre></td></tr></table></figure></li><li><p>字符压缩</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s位于后部</span><br><br>cat test | tr &#x27; &#x27; -s<br></code></pre></td></tr></table></figure></li></ul></li><li><p>按列切分文本：cut</p><ul><li><p>截取特定列</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为具体列范围</span><br><br>cut -f 1,2 test<br></code></pre></td></tr></table></figure></li><li><p>指定界定符</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d后接界定符</span><br><br>cut -f 2 -d &#x27;,&#x27; new<br></code></pre></td></tr></table></figure></li></ul></li><li><p>按列拼接文本：paste</p><ul><li>按列拼接 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br><br>paste test1 test2<br></code></pre></td></tr></table></figure></li><li>指定界定符拼接 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照-d之后给出的界定符拼接</span><br><br>paste test1 test2 -d &quot;,&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>统计行和字符：wc</p><ul><li>基本统计  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><br>wc -l test<br></code></pre></td></tr></table></figure></li></ul></li><li><p>文本替换：sed</p><ul><li>区别于上面的命令，sed是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9104.html">详见</a></li></ul></li><li><p>数据流处理：awk</p><ul><li>区别于上面的命令，awk是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9070.html">详见</a></li></ul></li></ol><hr><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><span id = "sysinfo">系统信息</span></h3><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I&#x2F;O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><ol><li><p>进程查询：ps</p><ul><li><p>查看正在运行进程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><br>ps -ef<br></code></pre></td></tr></table></figure></li><li><p>以完整格式显示所有进程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息</span><br><br>ps -ajx<br></code></pre></td></tr></table></figure></li></ul></li><li><p>进程监控：top</p><ul><li>显示实时进程信息 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%<span class="hljs-built_in">id</span>表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><br>top<br></code></pre></td></tr></table></figure></li></ul></li><li><p>打开文件查询：lsof</p><ul><li><p>查看占用某端口的进程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br>   <br>lsof -i:53<br></code></pre></td></tr></table></figure></li><li><p>查看某用户打开的文件 </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-u(user)为用户，后接用户名</span><br>   <br>lsof -u inx<br></code></pre></td></tr></table></figure></li><li><p>查看指定进程打开的文件 </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(process)为进程，后接进程PID</span><br>   <br>lsof -p 12345<br></code></pre></td></tr></table></figure></li><li><p>查看指定目录下被进程打开的文件 </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>   <br>lsof +d /test<br></code></pre></td></tr></table></figure></li></ul></li><li><p>内存使用量：free</p><ul><li>内存使用量 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><br>free<br></code></pre></td></tr></table></figure></li></ul></li><li><p>监控性能指标：sar</p><p> 监控CPU</p><ul><li><p>监控CPU负载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里<span class="hljs-string">&quot;1&quot;</span>表示采样时间间隔是1秒，这里<span class="hljs-string">&quot;2&quot;</span>表示采样次数为2</span><br><br>sar -q 1 2<br></code></pre></td></tr></table></figure></li><li><p>监控CPU使用率</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示CPU使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span><br><br>sar -u 1 2<br></code></pre></td></tr></table></figure></li></ul><p> 监控内存</p><ul><li><p>查询内存</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示内存使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span> <br><br>sar -r 1 2<br></code></pre></td></tr></table></figure></li><li><p>页面交换查询</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">参数意义同上</span><br><br>sar -W 1 2<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="网络工具-1"><a href="#网络工具-1" class="headerlink" title="网络工具"></a><span id = "net">网络工具</span></h3><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><ol><li><p>网卡配置（链路层）：ifconfig </p><ul><li><p>显示设备信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示已激活的网络设备信息</span><br><br>ifconfig<br></code></pre></td></tr></table></figure></li><li><p>启动关闭指定网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">up为打开，down为关闭</span><br><br>ifconfig eth0 up<br></code></pre></td></tr></table></figure></li><li><p>配置IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为配置的IP地址</span><br><br>ifconfig eth0 192.168.1.1<br></code></pre></td></tr></table></figure></li><li><p>设置最大传输单元</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">前一个参数为具体网卡，后面为MTU的大小<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置链路层MTU值，通常为1500</span><br><br>ifconfig eth0 mtu 1500<br></code></pre></td></tr></table></figure></li><li><p>启用和关闭ARP协议</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat</p><ul><li><p>网络接口信息</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示网卡信息，可结合ifconfig学习</span><br><br>netstat -i<br></code></pre></td></tr></table></figure></li><li><p>列出端口</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-l(listening)表示正在监听的端口</span><br><br>netstat -at<br></code></pre></td></tr></table></figure></li><li><p>显示端口统计信息</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(status)显示各协议信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><br>netstat -s<br></code></pre></td></tr></table></figure></li><li><p>显示使用某协议的应用名</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><br>netstat -pt<br></code></pre></td></tr></table></figure></li><li><p>查找指定进程、端口</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个操作可以用lsof替代</span><br><br>netstat -ap | grep ssh<br>netstat -an | grep &#x27;:80&#x27;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>查看路由表（网络层IP协议）：route</p><ul><li>查看路由信息 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过netstat -r(route)得到同样的路由表</span><br><br>route<br></code></pre></td></tr></table></figure></li></ul></li><li><p>检查网络连通性（网络层ICMP协议）：ping</p><ul><li>检查是否连通 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">主要功能是检测网络连通性</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><br>ping baidu.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p>转发路径（网络层ICMP协议）：traceroute</p><ul><li>文件包途径的IP <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span></span><br><br>traceroute baidu.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p>网络Debug分析（网络层&#x2F;传输层）：nc</p><ul><li><p>端口扫描</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">黑客很喜欢</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描某服务器端口使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v(view)显示指令执行过程，-w(<span class="hljs-built_in">wait</span>)设置超时时长</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为扫描的端口范围</span> <br><br>nc -v -w 1 baidu.com  -z 75-1000<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.oschina.net/translate/linux-netcat-command">其他详见</a></p></li></ul></li><li><p>命令行抓包（网络层&#x2F;传输层）：tcpdump</p><ul><li>抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。</li><li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">详见</a></li></ul></li><li><p>域名解析工具（应用层DNS协议）：dig</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">应用层，DNS</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析过程中涉及的各级DNS服务器地址</span><br><br>dig baidu.com<br></code></pre></td></tr></table></figure></li><li><p>网络请求（应用层）：curl</p><ul><li><a href="http://www.cnblogs.com/gbyukg/p/3326825.html">详见</a></li></ul></li></ol><hr><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><span id = "other">其他</span></h3><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><ol><li><p>终止进程：kill</p><ul><li><p>杀死具体进程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加具体进程PID</span><br><br>kill 12345<br></code></pre></td></tr></table></figure></li><li><p>杀死某进程相关进程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上<span class="hljs-string">&quot;-9&quot;</span>杀死某进程相关进程</span><br><br>kill -9 12345<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改文件权限：chmod</p><ul><li>更改文件权限 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件可以有三种权限，r(<span class="hljs-built_in">read</span>)，w(write)，x(execute)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><br>chmod u+r file<br>chmod 777 file<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建链接：ln</p><ul><li><p>创建硬链接</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><br>ln file1 file2<br></code></pre></td></tr></table></figure></li><li><p>创建软（符号链接）链接</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><br>ln -s file1 file2<br></code></pre></td></tr></table></figure></li></ul></li><li><p>显示文件尾：tail</p><ul><li>查看文件尾部 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志时常用</span><br><br>tail -f test<br></code></pre></td></tr></table></figure></li></ul></li><li><p>版本控制：git</p><ul><li>版本控制最好用的软件，没有之一。至少要知道”git init”，”git add”，”git commit”，”git pull”，”git push”几个命令。</li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/">详见</a></li></ul></li><li><p>设置别名：alias</p><ul><li>常用命令添加别名 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;.bashrc&quot;</span>文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><br>alias rm=&#x27;rm -i&#x27;<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed">代码</a></p><ol><li>单步调试：gdb</li></ol><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><ol start="2"><li>动态库依赖：ldd</li></ol><ul><li><p>命令：ldd .&#x2F;server</p></li><li><p>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</p></li></ul><ol start="3"><li>性能分析：top</li></ol><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><ol start="4"><li>系统调用：strace</li></ol><ul><li><p>命令：strace .&#x2F;server</p></li><li><p>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</p></li></ul><ol start="5"><li>打印进程：ps</li></ol><ul><li><p>命令：ps -ejH</p></li><li><p>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</p></li></ul><ol start="6"><li>打开文件：lsof</li></ol><ul><li><p>lsof -i:3000</p></li><li><p>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</p></li></ul><ol start="7"><li>修改权限：chmod</li></ol><ul><li><p>chmod 000 .&#x2F;index.html</p></li><li><p>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000&#x2F;index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</p></li></ul><ol start="8"><li>网卡信息：ifconfig</li></ol><ul><li><p>ifconfig</p></li><li><p>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</p></li></ul><ol start="9"><li>抓包分析：tcpdump</li></ol><ul><li><p>tcpdump -i eth0 port 3000</p></li><li><p>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式-url</title>
    <link href="/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/"/>
    <url>/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希表和完美哈希"><a href="#哈希表和完美哈希" class="headerlink" title="哈希表和完美哈希"></a><a href="https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html#perfect_hashing">哈希表和完美哈希</a></h2><h2 id="布隆过滤器的原理与实现"><a href="#布隆过滤器的原理与实现" class="headerlink" title="布隆过滤器的原理与实现"></a><a href="https://blog.51cto.com/u_12824426/2555710">布隆过滤器的原理与实现</a></h2><h2 id="布隆过滤器-阿里云开发者社区"><a href="#布隆过滤器-阿里云开发者社区" class="headerlink" title="布隆过滤器-阿里云开发者社区"></a><a href="https://developer.aliyun.com/article/773205">布隆过滤器-阿里云开发者社区</a></h2><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a>分布式面试题</h1><h2 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h2><h2 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h2><h2 id="分布式面试题-1"><a href="#分布式面试题-1" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h2>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式</title>
    <link href="/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h1 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h1><h1 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h1><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h1>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-url</title>
    <link href="/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/"/>
    <url>/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手-x2F-四次挥手"><a href="#三次握手-x2F-四次挥手" class="headerlink" title="三次握手&#x2F;四次挥手"></a>三次握手&#x2F;四次挥手</h1><h2 id="TCP的三次握手四次挥手理解及面试题"><a href="#TCP的三次握手四次挥手理解及面试题" class="headerlink" title="TCP的三次握手四次挥手理解及面试题"></a><a href="https://www.cnblogs.com/xp1315458571/articles/11361140.html">TCP的三次握手四次挥手理解及面试题</a></h2><h2 id="三次握手-x2F-四次挥手中的丢失情况及处理机制"><a href="#三次握手-x2F-四次挥手中的丢失情况及处理机制" class="headerlink" title="三次握手&#x2F;四次挥手中的丢失情况及处理机制"></a><a href="https://blog.51cto.com/u_14888059/3812405#:~:text=%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%20SYN-ACK%20%E6%8A%A5%E6%96%87%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9B%9E%E4%B8%80%E4%B8%AA,ACK%20%E6%8A%A5%E6%96%87%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E5%85%A5%E5%88%B0%20ESTABLISH%20%E7%8A%B6%E6%80%81%E3%80%82">三次握手&#x2F;四次挥手中的丢失情况及处理机制</a></h2><h1 id="滑窗-x2F-流控-x2F-拥塞"><a href="#滑窗-x2F-流控-x2F-拥塞" class="headerlink" title="滑窗&#x2F;流控&#x2F;拥塞"></a>滑窗&#x2F;流控&#x2F;拥塞</h1><h2 id="关于TCP乱序和重传的问题"><a href="#关于TCP乱序和重传的问题" class="headerlink" title="关于TCP乱序和重传的问题"></a><a href="https://blog.csdn.net/cws1214/article/details/52430554">关于TCP乱序和重传的问题</a></h2><h2 id="HTTP-与TCP中Keep-Alive机制的区别"><a href="#HTTP-与TCP中Keep-Alive机制的区别" class="headerlink" title="HTTP 与TCP中Keep-Alive机制的区别"></a><a href="https://cloud.tencent.com/developer/article/1430022">HTTP 与TCP中Keep-Alive机制的区别</a></h2><h2 id="HTTP-keep-alive和TCP-keepalive的区别"><a href="#HTTP-keep-alive和TCP-keepalive的区别" class="headerlink" title="HTTP keep-alive和TCP keepalive的区别"></a><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别</a></h2><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-x2F-2协议“多路复用”实现原理"><a href="#HTTP-x2F-2协议“多路复用”实现原理" class="headerlink" title="HTTP&#x2F;2协议“多路复用”实现原理"></a><a href="https://segmentfault.com/a/1190000016975064">HTTP&#x2F;2协议“多路复用”实现原理</a></h2><h2 id="Http发展历程-多路复用"><a href="#Http发展历程-多路复用" class="headerlink" title="Http发展历程-多路复用"></a><a href="https://juejin.cn/post/6844903935648497678">Http发展历程-多路复用</a></h2><h2 id="WebSocket-是什么原理？为什么可以实现持久连接？"><a href="#WebSocket-是什么原理？为什么可以实现持久连接？" class="headerlink" title="WebSocket 是什么原理？为什么可以实现持久连接？"></a><a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理？为什么可以实现持久连接？</a></h2><h2 id="POST-PUT和PATCH的区别"><a href="#POST-PUT和PATCH的区别" class="headerlink" title="POST,PUT和PATCH的区别"></a><a href="https://www.jianshu.com/p/bee85cf4e33a">POST,PUT和PATCH的区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-url</title>
    <link href="/2022/05/07/Redis-url/"/>
    <url>/2022/05/07/Redis-url/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis面试题-笔经面经-牛客网"><a href="#Redis面试题-笔经面经-牛客网" class="headerlink" title="Redis面试题_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/837063?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis面试题_笔经面经_牛客网</a></h2><h2 id="Redis超高频面试题和参考答案汇总！-笔经面经-牛客网"><a href="#Redis超高频面试题和参考答案汇总！-笔经面经-牛客网" class="headerlink" title="Redis超高频面试题和参考答案汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/941154?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis超高频面试题和参考答案汇总！_笔经面经_牛客网</a></h2><h2 id="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"><a href="#最全面的Redis缓存雪崩、击穿、穿透问题解决方案" class="headerlink" title="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"></a><a href="https://segmentfault.com/a/1190000039300423">最全面的Redis缓存雪崩、击穿、穿透问题解决方案</a></h2><h2 id="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"><a href="#Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级" class="headerlink" title="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"></a><a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></h2><h2 id="Redis-主从、哨兵和集群-区别"><a href="#Redis-主从、哨兵和集群-区别" class="headerlink" title="Redis 主从、哨兵和集群 区别"></a><a href="https://blog.csdn.net/u014527619/article/details/88232178">Redis 主从、哨兵和集群 区别</a></h2><h2 id="Memcached与Redis有什么区别"><a href="#Memcached与Redis有什么区别" class="headerlink" title="Memcached与Redis有什么区别"></a><a href="https://segmentfault.com/a/1190000023217491">Memcached与Redis有什么区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-url</title>
    <link href="/2022/05/07/Mysql-url/"/>
    <url>/2022/05/07/Mysql-url/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><h2 id="MySQL超高频面试题汇总！-笔经面经-牛客网"><a href="#MySQL超高频面试题汇总！-笔经面经-牛客网" class="headerlink" title="MySQL超高频面试题汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/922991?type=post&order=jing&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1650335022589">MySQL超高频面试题汇总！_笔经面经_牛客网</a></h2><h2 id="B-树，B树，聚集索引，非聚集索引"><a href="#B-树，B树，聚集索引，非聚集索引" class="headerlink" title="B+树，B树，聚集索引，非聚集索引"></a><a href="https://blog.csdn.net/weixin_30565199/article/details/95851132">B+树，B树，聚集索引，非聚集索引</a></h2><h2 id="MySQL为什么用B-树存储索引？"><a href="#MySQL为什么用B-树存储索引？" class="headerlink" title="MySQL为什么用B+树存储索引？"></a><a href="https://blog.csdn.net/dl674756321/article/details/102987984">MySQL为什么用B+树存储索引？</a></h2><h2 id="高度为3的B-树能存多少行数据"><a href="#高度为3的B-树能存多少行数据" class="headerlink" title="高度为3的B+树能存多少行数据?"></a><a href="https://www.1024sou.com/article/40.html">高度为3的B+树能存多少行数据?</a></h2><h1 id="模糊查询与联合索引"><a href="#模糊查询与联合索引" class="headerlink" title="模糊查询与联合索引"></a>模糊查询与联合索引</h1><h2 id="LIKE-模糊查询概述"><a href="#LIKE-模糊查询概述" class="headerlink" title="LIKE%模糊查询概述"></a><a href="https://blog.csdn.net/weixin_34081595/article/details/93658047?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">LIKE%模糊查询概述</a></h2><h2 id="LIKE-开头的模糊查询的解决方法"><a href="#LIKE-开头的模糊查询的解决方法" class="headerlink" title="LIKE%开头的模糊查询的解决方法"></a><a href="https://blog.csdn.net/qq_42539533/article/details/93137526?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">LIKE%开头的模糊查询的解决方法</a></h2><h2 id="联合索引在B-树上的存储结构及数据查找方式"><a href="#联合索引在B-树上的存储结构及数据查找方式" class="headerlink" title="联合索引在B+树上的存储结构及数据查找方式"></a><a href="https://www.cnblogs.com/ibigboy/p/12373978.html">联合索引在B+树上的存储结构及数据查找方式</a></h2><h2 id="索引最左前缀匹配原则"><a href="#索引最左前缀匹配原则" class="headerlink" title="索引最左前缀匹配原则"></a><a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">索引最左前缀匹配原则</a></h2><h1 id="事务与MVCC机制"><a href="#事务与MVCC机制" class="headerlink" title="事务与MVCC机制"></a>事务与MVCC机制</h1><h2 id="MySql解决幻读-x2F-不可重复读以及MVCC机制"><a href="#MySql解决幻读-x2F-不可重复读以及MVCC机制" class="headerlink" title="MySql解决幻读&#x2F;不可重复读以及MVCC机制"></a><a href="https://blog.csdn.net/qq_42799615/article/details/110942949">MySql解决幻读&#x2F;不可重复读以及MVCC机制</a></h2><h2 id="MySQL-如何解决幻读（MVCC-原理分析）"><a href="#MySQL-如何解决幻读（MVCC-原理分析）" class="headerlink" title="MySQL 如何解决幻读（MVCC 原理分析）"></a><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析）</a></h2><h2 id="从ReadView深入理解MySql-MVCC原理"><a href="#从ReadView深入理解MySql-MVCC原理" class="headerlink" title="从ReadView深入理解MySql MVCC原理"></a><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></h2><h2 id="MySQL间隙锁、Next-Key-Lock主要知识点"><a href="#MySQL间隙锁、Next-Key-Lock主要知识点" class="headerlink" title="MySQL间隙锁、Next-Key Lock主要知识点"></a><a href="https://www.jianshu.com/p/d5c2613cbb81">MySQL间隙锁、Next-Key Lock主要知识点</a></h2><h1 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h1><h2 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a><a href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别（9个不同点）</a></h2><h2 id="Innodb-Purge简介"><a href="#Innodb-Purge简介" class="headerlink" title="Innodb Purge简介"></a><a href="https://juejin.cn/post/6844903686393561096">Innodb Purge简介</a></h2><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="我终于看懂了HBase"><a href="#我终于看懂了HBase" class="headerlink" title="我终于看懂了HBase"></a><a href="https://zhuanlan.zhihu.com/p/145551967">我终于看懂了HBase</a></h2><h2 id="入门HBase，看这一篇就够了"><a href="#入门HBase，看这一篇就够了" class="headerlink" title="入门HBase，看这一篇就够了"></a><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></h2>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++-url</title>
    <link href="/2022/05/07/C++-url/"/>
    <url>/2022/05/07/C++-url/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="C-多态与虚函数"><a href="#C-多态与虚函数" class="headerlink" title="C++多态与虚函数"></a><a href="http://c.biancheng.net/cplus/polymorphism/">C++多态与虚函数</a></h2><h1 id="C-高级特性"><a href="#C-高级特性" class="headerlink" title="C++高级特性"></a>C++高级特性</h1><h2 id="智能指针详解-博客园"><a href="#智能指针详解-博客园" class="headerlink" title="智能指针详解-博客园"></a><a href="https://www.cnblogs.com/linuxandmcu/p/10409723.html">智能指针详解-博客园</a></h2><h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a><a href="http://c.biancheng.net/view/7829.html">C++11右值引用</a></h2><h2 id="右值引用-amp-转移语义-amp-完美转发"><a href="#右值引用-amp-转移语义-amp-完美转发" class="headerlink" title="右值引用 &amp; 转移语义 &amp; 完美转发"></a><a href="https://www.irimsky.top/archives/296/">右值引用 &amp; 转移语义 &amp; 完美转发</a></h2><h1 id="STL原理"><a href="#STL原理" class="headerlink" title="STL原理"></a>STL原理</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="deque容器底层实现原理（深度剖析）"><a href="#deque容器底层实现原理（深度剖析）" class="headerlink" title="deque容器底层实现原理（深度剖析）"></a><a href="http://c.biancheng.net/view/6908.html">deque容器底层实现原理（深度剖析）</a></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-url</title>
    <link href="/2022/05/07/Linux-url/"/>
    <url>/2022/05/07/Linux-url/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h1><h2 id="WebServer项目概述-ZWiley的随记"><a href="#WebServer项目概述-ZWiley的随记" class="headerlink" title="WebServer项目概述 - ZWiley的随记"></a><a href="https://zwiley.github.io/mybook/webserver/0%20%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/">WebServer项目概述 - ZWiley的随记</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（一）"><a href="#WebServer服务器项目可能会被问到的问题（一）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（一）"></a><a href="https://www.nowcoder.com/discuss/934904">WebServer服务器项目可能会被问到的问题（一）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（二）"><a href="#WebServer服务器项目可能会被问到的问题（二）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（二）"></a><a href="https://www.nowcoder.com/discuss/939267?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题（二）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题-三-完结"><a href="#WebServer服务器项目可能会被问到的问题-三-完结" class="headerlink" title="WebServer服务器项目可能会被问到的问题(三)完结"></a><a href="https://www.nowcoder.com/discuss/945403?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题(三)完结</a></h2><h2 id="Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读"><a href="#Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读" class="headerlink" title="Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读"></a><a href="https://read.douban.com/reader/ebook/15233070/?dcs=bookshelf">Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读</a></h2><h2 id="qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器"><a href="#qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器" class="headerlink" title="qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器"></a><a href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器</a></h2><h2 id="彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云"><a href="#彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云" class="headerlink" title="彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云"></a><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云</a></h2><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金"><a href="#虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金" class="headerlink" title="虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金"></a><a href="https://juejin.cn/post/6990237426903957540">虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金</a></h2><h2 id="linux下进程和线程状态查看"><a href="#linux下进程和线程状态查看" class="headerlink" title="linux下进程和线程状态查看"></a><a href="https://blog.csdn.net/huangjin0507/article/details/77848386">linux下进程和线程状态查看</a></h2><h2 id="socket阻塞和非阻塞有哪些影响-CSDN"><a href="#socket阻塞和非阻塞有哪些影响-CSDN" class="headerlink" title="socket阻塞和非阻塞有哪些影响-CSDN"></a><a href="https://blog.csdn.net/mayue_web/article/details/82873115">socket阻塞和非阻塞有哪些影响-CSDN</a></h2><h2 id="句柄和文件描述符-简书"><a href="#句柄和文件描述符-简书" class="headerlink" title="句柄和文件描述符-简书"></a><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符-简书</a></h2><h2 id="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"><a href="#Linux文件存储结构，包括目录项、inode、数据块-C语言中文网" class="headerlink" title="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"></a><a href="http://c.biancheng.net/cpp/html/2780.html">Linux文件存储结构，包括目录项、inode、数据块-C语言中文网</a></h2><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令与shell-菜鸟教程"><a href="#Linux命令与shell-菜鸟教程" class="headerlink" title="Linux命令与shell- 菜鸟教程"></a><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令与shell- 菜鸟教程</a></h2><h2 id="Linux命令大全教程"><a href="#Linux命令大全教程" class="headerlink" title="Linux命令大全教程"></a><a href="https://www.yiibai.com/linux/lsof.html">Linux命令大全教程</a></h2><h2 id="shell脚本指南"><a href="#shell脚本指南" class="headerlink" title="shell脚本指南"></a><a href="http://c.biancheng.net/view/706.html">shell脚本指南</a></h2><h2 id="linux的top命令参数详解-博客园"><a href="#linux的top命令参数详解-博客园" class="headerlink" title="linux的top命令参数详解-博客园"></a><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html">linux的top命令参数详解-博客园</a></h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>校招面经-url</title>
    <link href="/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/"/>
    <url>/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="十道海量数据处理面试题与十个方法大总结"><a href="#十道海量数据处理面试题与十个方法大总结" class="headerlink" title="十道海量数据处理面试题与十个方法大总结"></a><a href="https://blog.csdn.net/v_JULY_v/article/details/6279498?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">十道海量数据处理面试题与十个方法大总结</a></h2><h2 id="面试题：从n个数中找出第K大的数"><a href="#面试题：从n个数中找出第K大的数" class="headerlink" title="面试题：从n个数中找出第K大的数"></a><a href="https://blog.csdn.net/orangefly0214/article/details/86527462">面试题：从n个数中找出第K大的数</a></h2><h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="互联网大厂最爱问的智力题总结（带详细答案）"><a href="#互联网大厂最爱问的智力题总结（带详细答案）" class="headerlink" title="互联网大厂最爱问的智力题总结（带详细答案）"></a><a href="https://www.nowcoder.com/discuss/754712?type=1&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack">互联网大厂最爱问的智力题总结（带详细答案）</a></h2><h1 id="常见排序方法实现"><a href="#常见排序方法实现" class="headerlink" title="常见排序方法实现"></a>常见排序方法实现</h1><h2 id="创建堆，堆排序的详细实现过程，C-完整代码"><a href="#创建堆，堆排序的详细实现过程，C-完整代码" class="headerlink" title="创建堆，堆排序的详细实现过程，C++完整代码"></a><a href="https://blog.csdn.net/ahfytao/article/details/47681221">创建堆，堆排序的详细实现过程，C++完整代码</a></h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bigsai/p/13396391.html">桶排序</a></h2><h1 id="C-面经"><a href="#C-面经" class="headerlink" title="C++面经"></a>C++面经</h1><h2 id="C-x2F-C-技术面试基础知识总结-huihut"><a href="#C-x2F-C-技术面试基础知识总结-huihut" class="headerlink" title="C&#x2F;C++ 技术面试基础知识总结-huihut"></a><a href="https://interview.huihut.com/#/">C&#x2F;C++ 技术面试基础知识总结-huihut</a></h2><h2 id="【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网"><a href="#【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网" class="headerlink" title="【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网"></a><a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网</a></h2><h2 id="牛客网收藏面经"><a href="#牛客网收藏面经" class="headerlink" title="牛客网收藏面经"></a><a href="https://www.nowcoder.com/profile/674401673/following-posts">牛客网收藏面经</a></h2><h2 id="GoGoCoder面经"><a href="#GoGoCoder面经" class="headerlink" title="GoGoCoder面经"></a><a href="https://gogocoder.com/face">GoGoCoder面经</a></h2><h2 id="C-工程师精选面经汇总-校招实习社招-牛客网-牛客网"><a href="#C-工程师精选面经汇总-校招实习社招-牛客网-牛客网" class="headerlink" title="C++工程师精选面经汇总_校招实习社招_牛客网_牛客网"></a><a href="https://www.nowcoder.com/discuss/experience?tagId=640">C++工程师精选面经汇总_校招实习社招_牛客网_牛客网</a></h2><h1 id="Java面经"><a href="#Java面经" class="headerlink" title="Java面经"></a>Java面经</h1><h2 id="Java-全栈知识体系"><a href="#Java-全栈知识体系" class="headerlink" title="Java 全栈知识体系"></a><a href="https://pdai.tech/">Java 全栈知识体系</a></h2>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大厂笔试参考资料-url</title>
    <link href="/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/"/>
    <url>/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/</url>
    
    <content type="html"><![CDATA[<h1 id="ACM输入输出"><a href="#ACM输入输出" class="headerlink" title="ACM输入输出"></a>ACM输入输出</h1><h2 id="ACM输入方式-C-代码先锋网"><a href="#ACM输入方式-C-代码先锋网" class="headerlink" title="ACM输入方式-C++ - 代码先锋网"></a><a href="https://www.codeleading.com/article/50865910043/">ACM输入方式-C++ - 代码先锋网</a></h2><h2 id="C-使用stringstream与getline-分割字符串"><a href="#C-使用stringstream与getline-分割字符串" class="headerlink" title="C++使用stringstream与getline()分割字符串"></a><a href="https://blog.csdn.net/qq_36743440/article/details/91999615">C++使用stringstream与getline()分割字符串</a></h2><h2 id="C-中的cin以及stringstream"><a href="#C-中的cin以及stringstream" class="headerlink" title="C++中的cin以及stringstream"></a><a href="https://blog.csdn.net/flow_specter/article/details/116503515">C++中的cin以及stringstream</a></h2><h2 id="ACM模式数组构建二叉树"><a href="#ACM模式数组构建二叉树" class="headerlink" title="ACM模式数组构建二叉树"></a><a href="https://blog.csdn.net/m0_47240785/article/details/123406393">ACM模式数组构建二叉树</a></h2><h2 id="完全二叉树的顺序储存结构（C-完整代码）"><a href="#完全二叉树的顺序储存结构（C-完整代码）" class="headerlink" title="完全二叉树的顺序储存结构（C++完整代码）"></a><a href="https://blog.csdn.net/qq_52284035/article/details/118025460">完全二叉树的顺序储存结构（C++完整代码）</a></h2><h1 id="STL基础及模板"><a href="#STL基础及模板" class="headerlink" title="STL基础及模板"></a>STL基础及模板</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="C-STL中Map的按Key排序和按Value排序"><a href="#C-STL中Map的按Key排序和按Value排序" class="headerlink" title="C++ STL中Map的按Key排序和按Value排序"></a><a href="https://blog.csdn.net/iicy266/article/details/11906189">C++ STL中Map的按Key排序和按Value排序</a></h2><h2 id="优先队列详解-ACM例题分析"><a href="#优先队列详解-ACM例题分析" class="headerlink" title="优先队列详解+ACM例题分析"></a><a href="https://blog.csdn.net/qq_38492462/article/details/78631091">优先队列详解+ACM例题分析</a></h2><h1 id="大厂笔试题解"><a href="#大厂笔试题解" class="headerlink" title="大厂笔试题解"></a>大厂笔试题解</h1><h2 id="4-6-华为笔试题解-笔经面经-牛客网"><a href="#4-6-华为笔试题解-笔经面经-牛客网" class="headerlink" title="4.6 华为笔试题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/924780">4.6 华为笔试题解_笔经面经_牛客网</a></h2><h2 id="腾讯2022实习生笔试情况与题解-笔经面经-牛客网"><a href="#腾讯2022实习生笔试情况与题解-笔经面经-牛客网" class="headerlink" title="腾讯2022实习生笔试情况与题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/940859">腾讯2022实习生笔试情况与题解_笔经面经_牛客网</a></h2><h2 id="拓扑排序-知乎"><a href="#拓扑排序-知乎" class="headerlink" title="拓扑排序 - 知乎"></a><a href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序 - 知乎</a></h2>]]></content>
    
    
    <categories>
      
      <category>大厂笔试参考资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件描述符及三种拷贝命令</title>
    <link href="/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-文件描述符概念"><a href="#一-文件描述符概念" class="headerlink" title="一. 文件描述符概念"></a>一. 文件描述符概念</h1><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符</p></blockquote><p><strong>关于文件描述符，Linux内核维护了3个数据结构</strong></p><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137792.png"><br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137233.gif"></p><ul><li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的</li><li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样(概率很低)</li><li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况</li></ul><hr><h1 id="二-Linux文件和目录"><a href="#二-Linux文件和目录" class="headerlink" title="二. Linux文件和目录"></a>二. Linux文件和目录</h1><p>Linux文件是树形结构，inode是平坦结构，通过inode-&gt;i_mode字段，即S_ISREG、S_ISDIR两个宏判断是哪个类型。</p><ul><li><p>普通文件：<strong>inode</strong>里面存储元数据，inode索引到block，block存储数据</p></li><li><p>目录文件：inode索引到block，block中存储许多dirent目录条目，即名字到inode number的映射表<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138975.webp"></p></li></ul><p>目录文件的block区域如下：<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138621.webp"></p><p>内存的树形结构：</p><ul><li>dentry 绑定到唯一一个 inode 结构体；</li><li>dentry 有父，子，兄弟的索引路径，有这个就足够在内存中构建一个树了，并且事实也确实如此；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>  *<span class="hljs-title">d_parent</span>;</span>   <span class="hljs-comment">/* 父节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span>     <span class="hljs-title">d_name</span>;</span>      <span class="hljs-comment">// 名字</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>   *<span class="hljs-title">d_inode</span>;</span>    <span class="hljs-comment">// inode 结构体</span><br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_child</span>;</span>     <span class="hljs-comment">/* 兄弟节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span>   <span class="hljs-comment">/* 子节点 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="三-ln命令"><a href="#三-ln命令" class="headerlink" title="三. ln命令"></a>三. ln命令</h1><ul><li><p>软链接：软链接文件是一个全新的文件，有独立的 inode，有自己的 block ，内容是一段 path 路径，这个路径直接指向源文件；</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139893.webp"></p></li><li><p>硬链接：</p><blockquote><p>硬链接文件其实并没有新建文件（也就是说，没有消耗 inode 和 文件所需的 block 块）；</p><p>硬链接其实是修改了当前目录所在的目录文件，加了一个 dirent 而已，这个 dirent 用一个新的 name 名字指向原来的 inode number；</p><p>由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：<strong>不能跨文件系统。因为，不同文件系统的 inode 管理都是独立的。</strong></p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139421.webp"></p><p>总结：<strong>硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化。新的 name 指向原来的 inode。</strong></p><hr><h1 id="四-mv命令"><a href="#四-mv命令" class="headerlink" title="四. mv命令"></a>四. mv命令</h1><ul><li>源文件和目标文件在同一文件系统下：</li></ul><blockquote><p>mv 命令的核心操作是系统调用 rename ，rename 从内核实现来说只涉及到元数据的操作，只涉及到 dirent 的增删；</p><p><strong>inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。</strong></p></blockquote><br><ul><li>源文件和目标文件不在同一文件系统下：</li></ul><blockquote><p> 系统调用 rename 的时候，如果<strong>源</strong>和<strong>目的</strong>不在同一文件系统时，会报告 EXDEV 的错误码，提示该调用不能跨文件系统。</p></blockquote><p><strong>这个时候操作分成两步走，先 copy ，后 remove：</strong></p><ol><li><p>走不了 rename ，那么就退化成 copy ，也就是真正的拷贝。读取源文件，写入目标位置，生成一个全新的目标文件副本；</p><blockquote><p>这里调用的 copy_reg 的函数封装；</p><p>ln，mv，cp 是在 coreutils 库里的命令，公用函数本身就是可以复用的；</p></blockquote></li><li><p>删除源文件，使用 rm 函数删除；</p></li></ol><hr><h1 id="五-cp命令"><a href="#五-cp命令" class="headerlink" title="五. cp命令"></a>五. cp命令</h1><p><a href="https://juejin.cn/post/6939328247922425869">深度剖析 Linux cp 的秘密-博客</a></p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h1><ol><li>目录文件是一种特殊的文件，可以理解成存储的是 dirent 列表。dirent 只是名字到 inode 的映射，这个是树形结构的基础；</li><li>常说目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；</li><li>ln -s 创建软链接文件，软链接文件是一个独立的新文件，有一个新的 inode ，有新的 dentry，文件类型为 link，文件内容就是<strong>一条指向源的路径</strong>，所以<strong>软链的创建可以无视文件系统，跨越山河；</strong></li><li>ln 默认创建硬连接，硬链接文件只在目录文件里添加了一个新 dirent 项 (新name:原inode)，文件 inode 还是和原文件同一个，<strong>所以硬链接不能跨文件系统（因为不同的文件系统是独立的一套 inode 管理方式，不同的文件系统实例对 inode number 的解释各有不同）；</strong></li><li>ln 命令貌似创建出了新文件，但其实不然，ln 只跟元数据相关，涉及到 dirent  的变动，<strong>不涉及到数据的拷贝</strong>，起不到数据备份的目的；</li><li>mv 其实是调用 rename 调用，<strong>在同一个文件系统中不涉及到数据拷贝，只涉及到元数据变更</strong>（ dirent 的增删 ），所以速度也很快。但如果 mv 的源和目的<strong>在不同的文件系统，那么就会退化成真正的 copy ，会涉及到数据拷贝</strong>，这个时候速度相对慢一些，慢成什么样子？就跟 cp 命令一样；</li><li>cp 命令才是真正的数据拷贝命令，速度可能相对慢一些，但是 cp 命令有 –spare 可以优化拷贝速度，针对空洞和全 0 数据，可以跳过，从而<strong>针对稀疏文件可以节省大量磁盘 IO</strong>；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sss</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
