<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>海量数据处理-Skill-Tree</title>
    <link href="/2022/05/11/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-Skill-Tree/"/>
    <url>/2022/05/11/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="TOP-N问题"><a href="#TOP-N问题" class="headerlink" title="TOP N问题"></a>TOP N问题</h2><h3 id="1-如何在海量数据中找出重复最多一个。"><a href="#1-如何在海量数据中找出重复最多一个。" class="headerlink" title="1. 如何在海量数据中找出重复最多一个。"></a>1. 如何在海量数据中找出重复最多一个。</h3><ul><li><p>通过hash映射为小文件</p></li><li><p>通过hash_map统计各个小文件重读最多的并记录次数</p></li><li><p>对每个小文件重复最多的进行建立大根堆</p></li></ul><h3 id="2-上亿有重数据，统计最多前N个。"><a href="#2-上亿有重数据，统计最多前N个。" class="headerlink" title="2. 上亿有重数据，统计最多前N个。"></a>2. 上亿有重数据，统计最多前N个。</h3><ul><li><p>内存存不下</p><ul><li><p>通过hash映射为小文件</p></li><li><p>通过hash_map统计各个小文件重读最多的并记录次数</p></li><li><p>对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作</p></li></ul></li><li><p>内存存得下</p><ul><li><p>直接内存通过hash_map统计并建大根堆</p></li><li><p>重复N次取走堆顶并重建堆操作</p></li></ul></li></ul><h3 id="3-海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。"><a href="#3-海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。" class="headerlink" title="3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。"></a>3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。</h3><ul><li><p>将IP % 1000映射到1000个小文件中</p><ul><li><p>相同IP会被映射到同一个文件</p></li><li><p>不会出现累加和更大情况</p></li></ul></li><li><p>分1000次在内存处理小文件，得到频率最大IP（使用map统计）</p></li><li><p>对这1000个IP建立大根堆</p></li></ul><h3 id="4-1000w查询串统计最热门10个（同2）。"><a href="#4-1000w查询串统计最热门10个（同2）。" class="headerlink" title="4. 1000w查询串统计最热门10个（同2）。"></a>4. 1000w查询串统计最热门10个（同2）。</h3><ul><li>同上</li></ul><h3 id="5-1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。"><a href="#5-1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。" class="headerlink" title="5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。"></a>5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。</h3><ul><li><p>将单词 % 5000存入5000小文件</p><ul><li><p>平均各文件约200K</p></li><li><p>对超过1M的文件继续分割直到小于200K</p></li></ul></li><li><p>使用map统计各个词出现的频率</p></li><li><p>对5000词使用堆排序或归并排序</p></li></ul><h2 id="分布式TOP-N问题"><a href="#分布式TOP-N问题" class="headerlink" title="分布式TOP N问题"></a>分布式TOP N问题</h2><h3 id="6-分布在100台电脑的海量数据，统计前十。"><a href="#6-分布在100台电脑的海量数据，统计前十。" class="headerlink" title="6. 分布在100台电脑的海量数据，统计前十。"></a>6. 分布在100台电脑的海量数据，统计前十。</h3><ul><li><p>各数据只出现在一台机器中</p><ul><li><p>先在独立机器得到前十</p><ul><li><p>若可以放入内存直接堆排序</p></li><li><p>若不可全放入内存：哈希分块 -&gt; map统计 -&gt; 归总堆排</p></li></ul></li><li><p>再将100台计算机的TOP10组合起来堆排序</p></li></ul></li><li><p>同一元素可同时出现在不同机器中</p><ul><li>遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来</li></ul></li></ul><h2 id="快速外排序问题"><a href="#快速外排序问题" class="headerlink" title="快速外排序问题"></a>快速外排序问题</h2><h3 id="7-有10个1G文件，每行都是一个可重复用户query，按query频度排序。"><a href="#7-有10个1G文件，每行都是一个可重复用户query，按query频度排序。" class="headerlink" title="7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。"></a>7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。</h3><ul><li><p>顺序读取十个文件并采取哈希，将query写入10个文件中</p></li><li><p>通过hash_map(query, count)统计每个query出现次数，至少2G内存</p></li><li><p>通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件</p></li><li><p>对十个文件进行归并排序（外排序）</p></li></ul><h2 id="公共数据问题"><a href="#公共数据问题" class="headerlink" title="公共数据问题"></a>公共数据问题</h2><h3 id="8-A-B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"><a href="#8-A-B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。" class="headerlink" title="8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"></a>8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。</h3><ul><li><p>对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1……，不对应小文件不会有相同url）</p></li><li><p>通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。</p></li></ul><h3 id="9-1000w有重字符串，对字符串去重。"><a href="#9-1000w有重字符串，对字符串去重。" class="headerlink" title="9. 1000w有重字符串，对字符串去重。"></a>9. 1000w有重字符串，对字符串去重。</h3><ul><li><p>先hash分为多个文件</p></li><li><p>逐个文件检查并插入set中</p></li><li><p>多个set取交集</p></li></ul><h2 id="内存内TOP-N问题"><a href="#内存内TOP-N问题" class="headerlink" title="内存内TOP N问题"></a>内存内TOP N问题</h2><h3 id="10-100w个数字找出最大100个。"><a href="#10-100w个数字找出最大100个。" class="headerlink" title="10. 100w个数字找出最大100个。"></a>10. 100w个数字找出最大100个。</h3><ul><li><p>堆排序法</p><ul><li>建大根堆，取走堆顶并重建堆，重复100次</li></ul></li><li><p>快排法</p><ul><li>使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100</li></ul></li></ul><h2 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h2><h3 id="11-在2-5亿数字中找出不重复的整数。"><a href="#11-在2-5亿数字中找出不重复的整数。" class="headerlink" title="11. 在2.5亿数字中找出不重复的整数。"></a>11. 在2.5亿数字中找出不重复的整数。</h3><ul><li><p>使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。</p></li><li><p>或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。</p></li></ul><h3 id="12-如何在40亿数字中快速判断是否有某个数？"><a href="#12-如何在40亿数字中快速判断是否有某个数？" class="headerlink" title="12. 如何在40亿数字中快速判断是否有某个数？"></a>12. 如何在40亿数字中快速判断是否有某个数？</h3><ul><li>位图法标记某个数字是否存在，check标记数组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-Skill-Tree</title>
    <link href="/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Skill-Tree/"/>
    <url>/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>面向进程和线程学习操作系统。</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#thread">进程线程模型</a></td><td align="center"><a href="#con">进程间通信</a></td><td align="center"><a href="#mutex">同步互斥机制</a></td><td align="center"><a href="#mem">存储管理</a></td><td align="center"><a href="#netio">网络I&#x2F;O模型</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a><span id = "thread">进程线程模型</span></h2><p>线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i &#x3D; 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i &#x3D; i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p>对于线程，我认为弄清以下两点非常重要：</p><ul><li><p>线程之间有无先后访问顺序（线程依赖关系）</p></li><li><p>多个线程共享访问同一变量（同步互斥问题）</p></li></ul><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p><ol><li><p>线程创建和结束</p><ul><li><p>背景知识：</p><p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p></li><li><p>相关接口：</p><ul><li><p>创建线程：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);</p><p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p><ul><li><p>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t &#x3D;&#x3D; unsigned long int。</p></li><li><p>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</p></li><li><p>start_routine：线程执行函数的首地址，传入函数指针。</p></li><li><p>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p></li></ul></li><li><p>获得线程ID：pthread_t pthread_self();</p><p>调用时，会打印线程ID。</p></li><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li><p>tid：创建线程时通过指针得到tid值。</p></li><li><p>retval：指向返回值的指针。</p></li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul></li></ul></li><li><p>线程属性值修改</p><ul><li><p>背景知识：</p><p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> etachstate;    <span class="hljs-comment">// 线程分离的状态</span><br>    <span class="hljs-type">int</span> schedpolicy;    <span class="hljs-comment">// 线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;    <span class="hljs-comment">// 线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;    <span class="hljs-comment">// 线程的继承性</span><br>    <span class="hljs-type">int</span> scope;    <span class="hljs-comment">// 线程的作用域</span><br>    <span class="hljs-comment">// 以下为线程栈的设置</span><br>    <span class="hljs-type">size_t</span> guardsize;    <span class="hljs-comment">// 线程栈末尾警戒缓冲大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;    <span class="hljs-comment">// 线程的栈设置</span><br>    <span class="hljs-type">void</span> *    stackaddr;    <span class="hljs-comment">// 线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;    <span class="hljs-comment">// 线程栈大小</span><br>&#125;<span class="hljs-type">pthread_arrt_t</span>;<br></code></pre></td></tr></table></figure></li><li><p>相关接口：</p><p>对上述结构体中各参数大多有：pthread_attr_get***()和pthread_attr_set***()系统调用函数来设置和获取。这里不一一罗列。</p></li></ul></li><li><p>线程同步</p><ul><li><a href="#mutex">详见同步互斥专题</a></li></ul></li></ol><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a><strong>多进程</strong></h3><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><ol><li><p>进程创建与结束</p><ul><li><p>背景知识：</p><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 .&#x2F;program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li><li><p>相关接口：</p><ul><li><p>创建进程：pid_t fork(void);</p><p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid &#x3D;&#x3D; 0</p></li><li><p>结束进程：void exit(int status);</p><ul><li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li></ul></li><li><p>获得PID：pid_t getpid(void);</p><p>返回调用者pid。</p></li><li><p>获得父进程PID：pid_t getppid(void);</p><p>返回父进程pid。</p></li></ul></li><li><p>其他补充：</p><ul><li><p>正常退出方式：exit()、_exit()、return（在main中）。</p><p>exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p><p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p></li><li><p>异常退出方式：abort()、终止信号。</p></li></ul></li></ul></li><li><p>僵尸进程、孤儿进程</p><ul><li><p>背景知识：</p><p>父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。</p></li><li><p>相关接口：</p><ul><li><p>回收进程（1）：pid_t wait(int *status);</p><p>一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。</p><ul><li>status：指向子进程结束状态值。</li></ul></li><li><p>回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);</p><p>返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。</p><ul><li><p>pid：子进程识别码，控制等待哪些子进程。</p><ol><li><p>pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。</p></li><li><p>pid &#x3D; -1，等待任何子进程。</p></li><li><p>pid &#x3D; 0，等待进程组识别码与目前进程相同的任何子进程。</p></li><li><p>pid &gt; 0，等待任何子进程识别码为pid的子进程。</p></li></ol></li><li><p>status：指向返回码的指针。</p></li><li><p>options：选项决定父进程调用waitpid后的状态。</p><ol><li><p>options &#x3D; WNOHANG，即使没有子进程退出也会立即返回。</p></li><li><p>options &#x3D; WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。</p></li></ol></li></ul></li></ul></li></ul></li><li><p>守护进程</p></li></ol><ul><li><p>背景知识：</p><p>守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。</p></li><li><p>操作步骤：</p><ul><li><p>创建子进程，父进程退出：fork() + if(pid &gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。</p></li><li><p>在子进程中创建新会话：setsid()。</p></li><li><p>改变当前目录结构为根：chdir(“&#x2F;“)。</p></li><li><p>重设文件掩码：umask(0)。</p></li><li><p>关闭文件描述符：for(int i &#x3D; 0; i &lt; 65535; ++i){close(i);}。</p></li></ul></li></ul><ol start="4"><li>Linux进程控制</li></ol><ul><li><p>进程地址空间（地址空间）</p><p>虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li><li><p>进程控制块（处理机）</p><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li><li><p>上下文切换</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li></ul><h3 id="线程、进程比较"><a href="#线程、进程比较" class="headerlink" title="线程、进程比较"></a><strong>线程、进程比较</strong></h3><p>关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。</p><ul><li><p>fork()和pthread_create()</p><p>负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。</p></li><li><p>wait()和pthread_join()</p><p>负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。</p></li><li><p>exit()和pthread_exit()</p><p>负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。</p></li></ul><hr><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><span id = "con">进程间通信</span></h2><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h3><ul><li><p>无名管道</p><ul><li><p>无名管道特点：</p><ul><li><p>无名管道是一种特殊的文件，这种文件只存在于内存中。</p></li><li><p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</p></li><li><p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int pipe(int fd[2]);</p><ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li><p>有名管道：</p><ul><li><p>有名管道特点：</p><ul><li><p>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</p></li><li><p>无名管道可以在不具有亲缘关系的进程间进行通信。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int mkfifo(const char *pathname, mode_t mode);</p><ul><li><p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p></li><li><p>mode：和open()中的参数相同。</p></li></ul></li></ul></li></ul></li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a><strong>共享内存</strong></h3><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><ul><li><p>相关接口</p><ul><li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p><p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p><ul><li><p>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</p></li><li><p>size：共享内存容量。</p></li><li><p>flag：权限标志位，和open的mode参数一样。</p></li></ul></li><li><p>连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);</p><p>返回值即共享内存实际地址。</p><ul><li><p>shmid：shmget()返回的标识。</p></li><li><p>addr：决定以什么方式连接地址。</p></li><li><p>flag：访问模式。</p></li></ul></li><li><p>从共享内存分离：int shmdt(const void *shmaddr);</p><p>调用成功返回0，失败返回-1。</p><ul><li>shmaddr：是shmat()返回的地址指针。</li></ul></li></ul></li><li><p>其他补充</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></li></ul><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h3><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，<br>而在进程里使用SYSTEM  V信号量。</p><ul><li><p>相关接口</p><ul><li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p><p>创建成功返回信号量标识符，失败返回-1。</p><ul><li><p>key：进程pid。</p></li><li><p>nsems：创建信号量的个数。</p></li><li><p>semflag：指定信号量读写权限。</p></li></ul></li><li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p><p>struct sembuf结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span>&#123;<br>    <span class="hljs-type">short</span> sem_num;<br>    <span class="hljs-type">short</span> sem_op;<br>    <span class="hljs-type">short</span> sem_flg;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成功返回信号量标识符，失败返回-1。</p><ul><li><p>semid：信号量集标识符，由semget()函数返回。</p></li><li><p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p></li><li><p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p></li></ul></li><li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p><ul><li><p>semid：信号量集标识符。</p></li><li><p>semnum：信号量集数组上的下标，表示某一个信号量。</p></li><li><p>arg：union semun类型。</p></li></ul></li></ul></li></ul><h3 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a><strong>辅助命令</strong></h3><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li><p>ipcs -a：列出共享内存、信号量和消息队列信息。</p></li><li><p>ipcs -l：列出系统限额。</p></li><li><p>ipcs -u：列出当前使用情况。</p></li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a><strong>套接字</strong></h3><ul><li><p><a href="https://github.com/linw7/Skill-Tree/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">详见socket交互流程</a></p></li><li><p><a href="#netio">详见网络I&#x2F;O模型</a></p></li></ul><hr><h2 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a><span id = "mutex">同步互斥机制</span></h2><blockquote><p>待补充</p></blockquote><hr><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a><span id = "mem">存储管理</span></h2><blockquote><p>待补充</p></blockquote><hr><h2 id="网络I-x2F-O模型"><a href="#网络I-x2F-O模型" class="headerlink" title="网络I&#x2F;O模型"></a><span id = "netio">网络I&#x2F;O模型</span></h2><p>在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I&#x2F;O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。</p><p>所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待：</p><ul><li><p>建立连接时等待对方的ACK包（TCP）。</p></li><li><p>等待客户端请求（HTTP）。</p></li><li><p>输入等待：服务器用户数据到达内核缓冲区（read函数等待）。</p></li><li><p>输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。</p></li></ul><p>另外为了能够解释清楚网络I&#x2F;O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：</p><ul><li><p>read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。</p></li><li><p>printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I&#x2F;O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程&#x2F;线程）。</p></li></ul><p>有了上面的基础，我们就可以介绍下面四种网路I&#x2F;O模型。</p><h3 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a><strong>阻塞式</strong></h3><ul><li><p>阻塞表示一旦调用I&#x2F;O函数必须等整个I&#x2F;O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。</p></li><li><p>很显然，阻塞式I&#x2F;O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程&#x2F;线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I&#x2F;O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。</p></li><li><p>多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I&#x2F;O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。</p></li></ul><h3 id="非阻塞I-x2F-O"><a href="#非阻塞I-x2F-O" class="headerlink" title="非阻塞I&#x2F;O"></a><strong>非阻塞I&#x2F;O</strong></h3><ul><li><p>阻塞和非阻塞最大的区别在于调用I&#x2F;O系统调用后，是等整个I&#x2F;O过程完成再把操作权限返回给用户还是会立即返回。</p></li><li><p>可以使用以下语句将句柄fd设置为非阻塞I&#x2F;O：fcntl(fd, F_SETFL, O_NONBLOCK);</p></li><li><p>非阻塞I&#x2F;O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I&#x2F;O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。</p></li><li><p>非阻塞I&#x2F;O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</p></li></ul><h3 id="I-x2F-O多路复用（事件驱动模型）"><a href="#I-x2F-O多路复用（事件驱动模型）" class="headerlink" title="I&#x2F;O多路复用（事件驱动模型）"></a><strong>I&#x2F;O多路复用（事件驱动模型）</strong></h3><p>前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。</p><p>所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I&#x2F;O多路复用就是这么一种模型。Linux下I&#x2F;O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I&#x2F;O范畴。</p><ol><li><p>select</p><ul><li><p>相关接口：</p><p>int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);</p><p>FD_ZERO(int fd, fd_set* fds)    &#x2F;&#x2F;清空集合</p><p>FD_SET(int fd, fd_set* fds)    &#x2F;&#x2F;将给定的描述符加入集合</p><p>FD_ISSET(int fd, fd_set* fds)    &#x2F;&#x2F;将给定的描述符从文件中删除</p><p>FD_CLR(int fd, fd_set* fds)    &#x2F;&#x2F;判断指定描述符是否在集合中</p></li><li><p>参数：<br>maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。</p><p>readfds：指向读文件队列集合（fd_set）的指针。</p><p>writefds：同上，指向读集合的指针。</p><p>writefds：同上，指向错误集合的指针。</p><p>timeout：指向timeval结构指针，用于设置超时。</p></li><li><p>其他：</p><p>判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p></li></ul></li><li><p>poll</p><ul><li><p>相关接口：<br>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p></li><li><p>结构体定义：<br>struct pollfd{<br>int fd;    &#x2F;&#x2F; 文件描述符<br>short events;    &#x2F;&#x2F; 等到的事件<br>short revents;    &#x2F;&#x2F; 实际发生的事件<br>}</p></li><li><p>参数：<br>fds：指向pollfd结构体数组的指针。</p><p>nfds：pollfd数组当前已被使用的最大下标。</p><p>timeout：等待毫秒数。</p></li><li><p>其他：</p><p>判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p></li></ul></li><li><p>epoll</p><ul><li><p>相关接口：<br>int epoll_create(int size);    &#x2F;&#x2F; 创建epoll句柄<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    &#x2F;&#x2F; 事件注册函数<br>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p></li><li><p>结构体定义：<br>struct epoll_event{<br>__uint32_t events;<br>epoll_data_t data;<br>};<br>typedef union epoll_data{<br>void *ptr;<br>int fd;<br>__uint32_t u32;<br>__uint64_t u64;<br>}epoll_data_t;</p></li><li><p>参数：</p><p>size：用来告诉内核要监听的数目。</p><p>epfd：epoll函数的返回值。</p><p>op：表示动作（EPOLL_CTL_ADD&#x2F;EPOLL_CTL_FD&#x2F;EPOLL_CTL_DEL）。</p><p>fd：需要监听的fd。</p><p>events：指向epoll_event的指针，该结构记录监听的事件。</p><p>maxevents：告诉内核events的大小。</p><p>timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。</p></li></ul></li><li><p>select、poll和epoll区别</p><ul><li><p>操作方式及效率：</p><p>select是遍历，需要遍历fd_set每一个比特位（&#x3D; MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。</p></li><li><p>最大连接数：</p><p>select为1024&#x2F;2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p></li><li><p>fd拷贝：</p><p>select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p></li><li><p>其他：</p><p>select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I&#x2F;O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p></li></ul></li></ol><h3 id="异步I-x2F-O模型"><a href="#异步I-x2F-O模型" class="headerlink" title="异步I&#x2F;O模型"></a><strong>异步I&#x2F;O模型</strong></h3><ul><li><p>上面三种I&#x2F;O方式均属于同步I&#x2F;O。</p></li><li><p>从阻塞式I&#x2F;O到非阻塞I&#x2F;O，我们已经做到了调用I&#x2F;O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I&#x2F;O能够立即返回又能不一直轮询的话会更符合我们的预期。</p></li><li><p>之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I&#x2F;O结果。如果内核能够在完成I&#x2F;O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I&#x2F;O就是这么回事。</p></li><li><p>异步I&#x2F;O就是当用户进程发起I&#x2F;O请求后立即返回，直到内核发送一个信号，告知进程I&#x2F;O已完成，在整个过程中，都没有进程被阻塞。看上去异步I&#x2F;O和非阻塞I&#x2F;O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言C++-Skill-Tree</title>
    <link href="/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/"/>
    <url>/2022/05/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="编程语言-C-x2F-C"><a href="#编程语言-C-x2F-C" class="headerlink" title="编程语言(C&#x2F;C++)"></a>编程语言(C&#x2F;C++)</h1><blockquote><p>都是语言，为什么英语比C++难这么多呢？</p></blockquote><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th></tr></thead><tbody><tr><td align="center"><a href="base">编程基础</a></td><td align="center"><a href="#oop">面向对象基础</a></td><td align="center"><a href="#stl">标准模板库</a></td><td align="center"><a href="#other">编译及调试</a></td></tr></tbody></table><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a><span id = "base">编程基础</span></h2><p>C&#x2F;C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。</p><h3 id="1-变量声明和定义区别？"><a href="#1-变量声明和定义区别？" class="headerlink" title="1. 变量声明和定义区别？"></a>1. 变量声明和定义区别？</h3><pre><code class="hljs">- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 - 相同变量可以再多处声明（外部变量extern），但只能在一处定义。</code></pre><h3 id="2-“零值比较”？"><a href="#2-“零值比较”？" class="headerlink" title="2. “零值比较”？"></a>2. “零值比较”？</h3><pre><code class="hljs">- bool类型：if(flag)- int类型：if(flag == 0)- 指针类型：if(flag == null)- float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001))</code></pre><h3 id="3-strlen和sizeof区别？"><a href="#3-strlen和sizeof区别？" class="headerlink" title="3. strlen和sizeof区别？"></a>3. strlen和sizeof区别？</h3><pre><code class="hljs">- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是&#39;\0&#39;的字符串。- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**</code></pre><h3 id="4-同一不同对象可以互相赋值吗？"><a href="#4-同一不同对象可以互相赋值吗？" class="headerlink" title="4. 同一不同对象可以互相赋值吗？"></a>4. 同一不同对象可以互相赋值吗？</h3><pre><code class="hljs">- 可以，但含有指针成员时需要注意。- 对比类的对象赋值时深拷贝和浅拷贝。</code></pre><h3 id="5-结构体内存对齐问题？"><a href="#5-结构体内存对齐问题？" class="headerlink" title="5. 结构体内存对齐问题？"></a>5. 结构体内存对齐问题？</h3><pre><code class="hljs">- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</code></pre><h3 id="6-static作用是什么？在C和C-中有何区别？"><a href="#6-static作用是什么？在C和C-中有何区别？" class="headerlink" title="6. static作用是什么？在C和C++中有何区别？"></a>6. static作用是什么？在C和C++中有何区别？</h3><pre><code class="hljs">- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。- 未初始化时，static变量默认值为0。</code></pre><h3 id="7-结构体和类的区别？"><a href="#7-结构体和类的区别？" class="headerlink" title="7. 结构体和类的区别？"></a>7. 结构体和类的区别？</h3><pre><code class="hljs">- 结构体的默认限定符是public；类是private。</code></pre><ul><li><del>结构体不可以继承，类可以。</del> C++中结构体也可以继承。</li></ul><h3 id="8-malloc和new的区别？"><a href="#8-malloc和new的区别？" class="headerlink" title="8. malloc和new的区别？"></a>8. malloc和new的区别？</h3><pre><code class="hljs">- malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</code></pre><h3 id="9-指针和引用区别？"><a href="#9-指针和引用区别？" class="headerlink" title="9. 指针和引用区别？"></a>9. 指针和引用区别？</h3><ul><li><p>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</p><ul><li><p>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</p></li><li><p>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</p></li><li><p>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</p></li></ul></li></ul><h3 id="10-宏定义和函数有何区别？"><a href="#10-宏定义和函数有何区别？" class="headerlink" title="10. 宏定义和函数有何区别？"></a>10. 宏定义和函数有何区别？</h3><pre><code class="hljs">- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。- 宏函数不要在最后加分号。</code></pre><h3 id="11-宏定义和const区别？"><a href="#11-宏定义和const区别？" class="headerlink" title="11. 宏定义和const区别？"></a>11. 宏定义和const区别？</h3><pre><code class="hljs">- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。- 宏不检查类型；const会检查数据类型。- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</code></pre><h3 id="12-宏定义和typedef区别？"><a href="#12-宏定义和typedef区别？" class="headerlink" title="12. 宏定义和typedef区别？"></a>12. 宏定义和typedef区别？</h3><pre><code class="hljs">- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。- 宏不检查类型；typedef会检查数据类型。- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</code></pre><h3 id="13-宏定义和内联函数-inline-区别？"><a href="#13-宏定义和内联函数-inline-区别？" class="headerlink" title="13. 宏定义和内联函数(inline)区别？"></a>13. 宏定义和内联函数(inline)区别？</h3><pre><code class="hljs">- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。- 内联函数本身是函数，强调函数特性，具有重载等功能。- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</code></pre><h3 id="14-条件编译-ifdef-else-endif作用？"><a href="#14-条件编译-ifdef-else-endif作用？" class="headerlink" title="14. 条件编译#ifdef, #else, #endif作用？"></a>14. 条件编译#ifdef, #else, #endif作用？</h3><pre><code class="hljs">- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。- 用于子程序前加#define DEBUG用于程序调试。- 应对硬件的设置（机器类型等）。- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</code></pre><h3 id="15-区别以下几种变量？"><a href="#15-区别以下几种变量？" class="headerlink" title="15. 区别以下几种变量？"></a>15. 区别以下几种变量？</h3><pre><code class="hljs">    const int a;    int const a;    const int *a;    int *const a;- int const a和const int a均表示定义常量类型a。- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</code></pre><h3 id="16-volatile有什么作用？"><a href="#16-volatile有什么作用？" class="headerlink" title="16. volatile有什么作用？"></a>16. volatile有什么作用？</h3><pre><code class="hljs">- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。- 多线程中被几个任务共享的变量需要定义为volatile类型。</code></pre><h3 id="17-什么是常引用？"><a href="#17-什么是常引用？" class="headerlink" title="17. 什么是常引用？"></a>17. 什么是常引用？</h3><pre><code class="hljs">- 常引用可以理解为常量指针，形式为const typename &amp; refname = varname。- 常引用下，原变量值不会被别名所修改。- 原变量的值可以通过原名修改。- 常引用通常用作只读变量别名或是形参传递。</code></pre><h3 id="18-区别以下指针类型？"><a href="#18-区别以下指针类型？" class="headerlink" title="18. 区别以下指针类型？"></a>18. 区别以下指针类型？</h3><pre><code class="hljs">    int *p[10]    int (*p)[10]    int *p(int)    int (*p)(int)- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</code></pre><h3 id="19-常量指针和指针常量区别？"><a href="#19-常量指针和指针常量区别？" class="headerlink" title="19. 常量指针和指针常量区别？"></a>19. 常量指针和指针常量区别？</h3><pre><code class="hljs">- 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。- 指针常量是一个不能给改变指向的指针。如int *const p。</code></pre><h3 id="20-a和-amp-a有什么区别？"><a href="#20-a和-amp-a有什么区别？" class="headerlink" title="20. a和&amp;a有什么区别？"></a>20. a和&amp;a有什么区别？</h3><pre><code class="hljs">    假设数组int a[10];    int (*p)[10] = &amp;a;- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。- &amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</code></pre><h3 id="21-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#21-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="21. 数组名和指针（这里为指向数组首元素的指针）区别？"></a>21. 数组名和指针（这里为指向数组首元素的指针）区别？</h3><pre><code class="hljs">- 二者均可通过增减偏移量来访问数组中的元素。- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</code></pre><h3 id="22-野指针是什么？"><a href="#22-野指针是什么？" class="headerlink" title="22. 野指针是什么？"></a>22. 野指针是什么？</h3><pre><code class="hljs">- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。- 产生原因及解决办法：     - 指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。     - 指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</code></pre><h3 id="23-堆和栈的区别？"><a href="#23-堆和栈的区别？" class="headerlink" title="23. 堆和栈的区别？"></a>23. 堆和栈的区别？</h3><pre><code class="hljs">- 申请方式不同。    - 栈由系统自动分配。    - 堆由程序员手动分配。- 申请大小限制不同。    - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。    - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。- 申请效率不同。    - 栈由系统分配，速度快，不会有碎片。    - 堆由程序员分配，速度慢，且会有碎片。</code></pre><h3 id="24-delete和delete-区别？"><a href="#24-delete和delete-区别？" class="headerlink" title="24. delete和delete[]区别？"></a>24. delete和delete[]区别？</h3><pre><code class="hljs">- delete只会调用一次析构函数。- delete[]会调用数组中每个元素的析构函数。</code></pre><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a><span id = "oop">面向对象基础</span></h2><p>能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。</p><h3 id="1-面向对象三大特性？"><a href="#1-面向对象三大特性？" class="headerlink" title="1. 面向对象三大特性？"></a>1. 面向对象三大特性？</h3><pre><code class="hljs">- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。- 继承性：让某种类型对象获得另一个类型对象的属性和方法。- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</code></pre><h3 id="2-public-x2F-protected-x2F-private的区别？"><a href="#2-public-x2F-protected-x2F-private的区别？" class="headerlink" title="2. public&#x2F;protected&#x2F;private的区别？"></a>2. public&#x2F;protected&#x2F;private的区别？</h3><pre><code class="hljs">- public的变量和函数在类的内部外部都可以访问。- protected的变量和函数只能在类的内部和其派生类中访问。- private修饰的元素只能在类内访问。</code></pre><h3 id="3-对象存储空间？"><a href="#3-对象存储空间？" class="headerlink" title="3. 对象存储空间？"></a>3. 对象存储空间？</h3><pre><code class="hljs">- 非静态成员的数据类型大小之和。- 编译器加入的额外成员变量（如指向虚函数表的指针）。- 为了边缘对齐优化加入的padding。</code></pre><h3 id="4-C-空类有哪些成员函数"><a href="#4-C-空类有哪些成员函数" class="headerlink" title="4. C++空类有哪些成员函数?"></a>4. C++空类有哪些成员函数?</h3><pre><code class="hljs">- 首先，空类大小为1字节。- 默认函数有：    - 构造函数    - 析构函数    - 拷贝构造函数    - 赋值运算符</code></pre><h3 id="5-构造函数能否为虚函数，析构函数呢？"><a href="#5-构造函数能否为虚函数，析构函数呢？" class="headerlink" title="5. 构造函数能否为虚函数，析构函数呢？"></a>5. 构造函数能否为虚函数，析构函数呢？</h3><pre><code class="hljs">- 析构函数：    - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。    - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。    - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。- 构造函数：    - 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</code></pre><h3 id="6-构造函数调用顺序，析构函数呢？"><a href="#6-构造函数调用顺序，析构函数呢？" class="headerlink" title="6. 构造函数调用顺序，析构函数呢？"></a>6. 构造函数调用顺序，析构函数呢？</h3><pre><code class="hljs">- 调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。- 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。- 派生类的构造函数。- 析构函数与之相反。</code></pre><h3 id="7-拷贝构造函数中深拷贝和浅拷贝区别？"><a href="#7-拷贝构造函数中深拷贝和浅拷贝区别？" class="headerlink" title="7. 拷贝构造函数中深拷贝和浅拷贝区别？"></a>7. 拷贝构造函数中深拷贝和浅拷贝区别？</h3><pre><code class="hljs">- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。- 浅拷贝仅仅是拷贝指针字面值。- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</code></pre><h3 id="8-拷贝构造函数和赋值运算符重载的区别？"><a href="#8-拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="8. 拷贝构造函数和赋值运算符重载的区别？"></a>8. 拷贝构造函数和赋值运算符重载的区别？</h3><pre><code class="hljs">- 拷贝构造函数是函数，赋值运算符是运算符重载。- 拷贝构造函数会生成新的类对象，赋值运算符不能。- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现&quot;=&quot;的地方都是使用赋值运算符，如下：        Student s;        Student s1 = s;    // 调用拷贝构造函数        Student s2;        s2 = s;    // 赋值运算符操作**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**</code></pre><h3 id="9-虚函数和纯虚函数区别？"><a href="#9-虚函数和纯虚函数区别？" class="headerlink" title="9. 虚函数和纯虚函数区别？"></a>9. 虚函数和纯虚函数区别？</h3><pre><code class="hljs">- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</code></pre><h3 id="10-覆盖、重载和隐藏的区别？"><a href="#10-覆盖、重载和隐藏的区别？" class="headerlink" title="10. 覆盖、重载和隐藏的区别？"></a>10. 覆盖、重载和隐藏的区别？</h3><pre><code class="hljs"> - 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。 - 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。 - 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</code></pre><h3 id="11-在main执行之前执行的代码可能是什么？"><a href="#11-在main执行之前执行的代码可能是什么？" class="headerlink" title="11. 在main执行之前执行的代码可能是什么？"></a>11. 在main执行之前执行的代码可能是什么？</h3><pre><code class="hljs">- 全局对象的构造函数。</code></pre><h3 id="12-哪几种情况必须用到初始化成员列表？"><a href="#12-哪几种情况必须用到初始化成员列表？" class="headerlink" title="12. 哪几种情况必须用到初始化成员列表？"></a>12. 哪几种情况必须用到初始化成员列表？</h3><pre><code class="hljs">- 初始化一个const成员。- 初始化一个reference成员。- 调用一个基类的构造函数，而该函数有一组参数。- 调用一个数据成员对象的构造函数，而该函数有一组参数。</code></pre><h3 id="13-什么是虚指针？"><a href="#13-什么是虚指针？" class="headerlink" title="13. 什么是虚指针？"></a>13. 什么是虚指针？</h3><pre><code class="hljs">- 虚指针或虚函数指针是虚函数的实现细节。- 虚指针指向虚表结构。</code></pre><h3 id="14-重载和函数模板的区别？"><a href="#14-重载和函数模板的区别？" class="headerlink" title="14. 重载和函数模板的区别？"></a>14. 重载和函数模板的区别？</h3><pre><code class="hljs">- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。</code></pre><h3 id="15-this指针是什么？"><a href="#15-this指针是什么？" class="headerlink" title="15. this指针是什么？"></a>15. this指针是什么？</h3><pre><code class="hljs">- this指针是类的指针，指向对象的首地址。- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</code></pre><h3 id="16-类模板是什么？"><a href="#16-类模板是什么？" class="headerlink" title="16. 类模板是什么？"></a>16. 类模板是什么？</h3><pre><code class="hljs">- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</code></pre><h3 id="17-构造函数和析构函数调用时机？"><a href="#17-构造函数和析构函数调用时机？" class="headerlink" title="17. 构造函数和析构函数调用时机？"></a>17. 构造函数和析构函数调用时机？</h3><pre><code class="hljs">- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</code></pre><hr><h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a><span id = "stl">标准模板库</span></h2><p>STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：</p><ul><li><p>怎么用？</p><p>各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。</p></li><li><p>怎么实现？</p><p>本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。</p></li><li><p>如何避免错误？</p><p>在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。</p></li></ul><p><strong>string</strong></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        vector&lt;T&gt; vec;    插入元素：        vec.push_back(element);        vec.insert(iterator, element);    删除元素：        vec.pop_back();        vec.erase(iterator);    修改元素：        vec[position] = element;    遍历容器：        for(auto it = vec.begin(); it != vec.end(); ++it) &#123;......&#125;    其他：        vec.empty();    //判断是否空        vec.size();    // 实际元素        vec.capacity();    // 容器容量        vec.begin();    // 获得首迭代器        vec.end();    // 获得尾迭代器        vec.clear();    // 清空</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp">模拟Vector实现</a></p><ul><li><p>线性表，数组实现。</p><ul><li><p>支持随机访问。</p></li><li><p>插入删除操作需要大量移动数据。</p></li></ul></li><li><p>需要连续的物理存储空间。</p></li><li><p>每当大小不够时，重新分配内存（*2），并复制原内容。</p></li></ul><p>错误避免：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp">迭代器失效</a></p><ul><li><p>插入元素</p><ul><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ul></li><li><p>删除元素</p><ul><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ul></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>用法：</p><pre><code class="hljs">    定义：        map&lt;T_key, T_value&gt; mymap;    插入元素：        mymap.insert(pair&lt;T_key, T_value&gt;(key, value));    // 同key不插入        mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value));    // 同key不插入        mymap[key] = value;    // 同key覆盖    删除元素：        mymap.erase(key);    // 按值删        mymap.erase(iterator);    // 按迭代器删    修改元素：        mymap[key] = new_value;    遍历容器：          for(auto it = mymap.begin(); it != mymap.end(); ++it) &#123;            cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;          &#125;</code></pre><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/tree/master/code/RBTree">RBTree实现</a></p><ul><li><p>树状结构，RBTree实现。</p><ul><li><p>插入删除不需要数据复制。</p></li><li><p>操作复杂度仅跟树高有关。</p></li></ul></li><li><p>RBTree本身也是二叉排序树的一种，key值有序，且唯一。</p><ul><li>必须保证key可排序。</li></ul></li></ul><p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p><h3 id="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"><a href="#面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的" class="headerlink" title="面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的"></a><strong>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的</strong></h3><ol><li><p>它是二叉排序树（继承二叉排序树特显）：</p><ul><li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p></li></ul></li><li><p>它满足如下几点要求：</p><ul><li><p>树中所有节点非红即黑。</p></li><li><p>根节点必为黑节点。</p></li><li><p>红节点的子节点必为黑（黑节点子节点可为黑）。</p></li><li><p>从根到NULL的任何路径上黑结点数相同。</p></li></ul></li><li><p>查找时间一定可以控制在O(logn)。</p></li><li><p>红黑树的节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED = <span class="hljs-number">0</span>,<br>    BLACK = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span>*left, *right, *parent;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> data;<br>    Color color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p></li></ol><p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p><p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><hr><h2 id="编译及调试"><a href="#编译及调试" class="headerlink" title="编译及调试"></a><span id = "other">编译及调试</span></h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h3><p>预处理</p><ul><li><p>展开所有的宏定义，完成字符常量替换。</p></li><li><p>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</p></li><li><p>处理#include指令，将被包含的文件插入到该指令所在位置。</p></li><li><p>过滤掉所有注释语句。</p></li><li><p>添加行号和文件名标识。</p></li><li><p>保留所有#pragma编译器指令。</p></li></ul><p>编译</p><ul><li><p>词法分析。</p></li><li><p>语法分析。</p></li><li><p>语义分析。</p></li><li><p>中间语言生成。</p></li><li><p>目标代码生成与优化。</p></li></ul><p>链接</p><p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p><ul><li><p>静态链接</p><p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。</p><p>既然静态链接是对目标文件的打包，这里介绍些打包命令。</p><pre><code class="hljs">gcc -c test1.c    // 生成test1.ogcc -c test2.c    // 生成test2.car cr libtest.a test1.o test2.o</code></pre><p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li><li><p>动态链接</p><p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p><p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p><pre><code class="hljs">gcc -fPIC -c test1.c gcc -fPIC -c test2.cgcc -shared test1.o test2.o -o libtest.so</code></pre><p>使用动态链接的用法也和静态链接相同。</p><pre><code class="hljs">gcc -o main main.c -ltest</code></pre></li></ul><p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是&#x2F;usr&#x2F;lib，我们可以将库文件拷贝到那个目录下再链接。</p><p>比较静态库和动态库我们可以得到二者的优缺点。</p><ul><li><p>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</p></li><li><p>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</p></li><li><p>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</p></li></ul><p>makefile编写</p><p>对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。</p><ul><li><p>基本规则</p><pre><code class="hljs">A:B(tab)&lt;command&gt;</code></pre><p>其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。</p></li><li><p>变量</p><p>makefile的书写非常像shell脚本，可以在文件中定义”变量名 &#x3D; 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><p>符号解析</p><ul><li><p>可重定位目标文件</p><p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p></li><li><p>解析符号表</p><p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p></li></ul><p>重定位</p><ul><li><p>合并节</p><p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p></li><li><p>重定位符号引用</p><p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p></li></ul><p>可执行目标文件</p><ul><li><p>ELF头部</p><p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p></li><li><p>段头部表</p><p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p></li><li><p>其他段</p><p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p></li></ul><p>加载</p><ul><li><p>克隆</p><p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p></li><li><p>重新映射</p><p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p></li><li><p>虚页调入</p><p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux工具-Skill-Tree</title>
    <link href="/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/"/>
    <url>/2022/05/10/Linux%E5%B7%A5%E5%85%B7-Skill-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a><a href="http://man.linuxde.net/par/2">Linux工具</a></h1><blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C&#x2F;C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I&#x2F;O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th align="center">Chapter 1</th><th align="center">Chapter 2</th><th align="center">Chapter 3</th><th align="center">Chapter 4</th><th align="center">Chapter 5</th></tr></thead><tbody><tr><td align="center"><a href="#pro">开发及调试</a></td><td align="center"><a href="#file">文件处理</a></td><td align="center"><a href="#sysinfo">性能分析</a></td><td align="center"><a href="#net">网络工具</a></td><td align="center"><a href="#other">其他</a></td></tr></tbody></table><ul><li><p>开发及调试</p><ul><li>编辑器：vim</li><li>编译器：gcc&#x2F;g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li><p>文件处理</p><ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li><p>性能分析</p><ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li><p>网络工具</p><ul><li>网卡配置：ifconfig </li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li><p>其他</p><ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a><span id = "pro">开发及调试</span></h2><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><h3 id="1-编辑器：vim"><a href="#1-编辑器：vim" class="headerlink" title="1.  编辑器：vim"></a>1.  编辑器：vim</h3><pre><code class="hljs">- 服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。- [详见](http://coolshell.cn/articles/5426.html)</code></pre><h3 id="2-编译器：gcc-x2F-g"><a href="#2-编译器：gcc-x2F-g" class="headerlink" title="2. 编译器：gcc&#x2F;g++"></a>2. 编译器：gcc&#x2F;g++</h3><pre><code class="hljs">- C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。- [详见](http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html)</code></pre><h3 id="3-调试工具：gdb"><a href="#3-调试工具：gdb" class="headerlink" title="3. 调试工具：gdb"></a>3. 调试工具：gdb</h3><pre><code class="hljs">- 服务器端调试必备。- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)</code></pre><h3 id="4-查看依赖库：ldd"><a href="#4-查看依赖库：ldd" class="headerlink" title="4. 查看依赖库：ldd"></a>4. 查看依赖库：ldd</h3><pre><code class="hljs">- 程序依赖库查询<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ldd后接可执行文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><br>ldd a.out<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-二进制文件分析：objdump"><a href="#5-二进制文件分析：objdump" class="headerlink" title="5. 二进制文件分析：objdump"></a>5. 二进制文件分析：objdump</h3><pre><code class="hljs">- 反汇编，需要理解汇编语言- [详见](http://man.linuxde.net/objdump)</code></pre><h3 id="6-ELF文件格式分析：readelf"><a href="#6-ELF文件格式分析：readelf" class="headerlink" title="6. ELF文件格式分析：readelf"></a>6. ELF文件格式分析：readelf</h3><pre><code class="hljs">- 可以得到ELF文件各段内容，分析链接、符号表等需要用到- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html)</code></pre><h3 id="7-跟踪进程中系统调用：strace"><a href="#7-跟踪进程中系统调用：strace" class="headerlink" title="7. 跟踪进程中系统调用：strace"></a>7. 跟踪进程中系统调用：strace</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)</code></pre><h3 id="8-跟踪进程栈：pstack"><a href="#8-跟踪进程栈：pstack" class="headerlink" title="8. 跟踪进程栈：pstack"></a>8. 跟踪进程栈：pstack</h3><pre><code class="hljs">- [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#)</code></pre><h3 id="9-进程内存映射：pmap"><a href="#9-进程内存映射：pmap" class="headerlink" title="9. 进程内存映射：pmap"></a>9. 进程内存映射：pmap</h3><pre><code class="hljs">- 显示进程内存映射<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-x显示扩展信息，后接进程pid</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Address: 内存开始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示信息：</span><br>    Kbytes: 占用内存的字节数<br>    RSS: 保留内存的字节数<br>    Dirty: 脏页的字节数（包括共享和私有的）<br>    Mode: 内存的权限：read、write、execute、shared、private<br>    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）<br>    Device: 设备名 (major:minor)<br><br>pmap -x 12345<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a><span id = "file">文件处理</span></h2><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><h3 id="1-文件查找：find"><a href="#1-文件查找：find" class="headerlink" title="1. 文件查找：find"></a>1. 文件查找：find</h3><pre><code class="hljs">按名查找：- 查找具体文件（一般方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name *.cpp<br></code></pre></td></tr></table></figure>- 查找具体文件（正则方式）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-regex为正则查找，-iregex为忽略大小写的正则查找</span> <br>  <br>find -regex &quot;.*.cpp$&quot;<br></code></pre></td></tr></table></figure>定制查找：- 按类型查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">f(file)为文件，d(dictionary)为目录，l(<span class="hljs-built_in">link</span>)为链接</span><br>  <br>find . -type f<br></code></pre></td></tr></table></figure>- 按时间查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mtime为修改时间</span><br>  <br>find . -type f -atime -7<br></code></pre></td></tr></table></figure>- 按大小查找<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br>  <br>find . -type f -size -1k<br></code></pre></td></tr></table></figure>- 按权限查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-perm后接权限</span><br><br>find . -type -perm 644<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-文本搜索：grep"><a href="#2-文本搜索：grep" class="headerlink" title="2. 文本搜索：grep"></a>2. 文本搜索：grep</h3><pre><code class="hljs">- 模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容</span><br><br>grep &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 多个模式匹配<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配test.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容</span><br><br>grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure>- 输出信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><br>grep -n &quot;iostream&quot; test.cpp  <br></code></pre></td></tr></table></figure></code></pre><h3 id="3-排序：sort"><a href="#3-排序：sort" class="headerlink" title="3. 排序：sort"></a>3. 排序：sort</h3><pre><code class="hljs">- 文件内容行排序<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-k N表示按各行第N列进行排序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r(reverse)为逆序排序</span><br><br>sort -n -k 1 test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-转换：tr"><a href="#4-转换：tr" class="headerlink" title="4. 转换：tr"></a>4. 转换：tr</h3><pre><code class="hljs">- 字符替换<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将打开文件中所有目标字符替换</span><br><br>cat test | tr &#x27;1&#x27; &#x27;2&#x27;<br></code></pre></td></tr></table></figure>- 字符删除<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d删除(delete)</span><br><br>cat test | tr -d &#x27;1&#x27;<br></code></pre></td></tr></table></figure>- 字符压缩<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换在内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s位于后部</span><br><br>cat test | tr &#x27; &#x27; -s<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-按列切分文本：cut"><a href="#5-按列切分文本：cut" class="headerlink" title="5. 按列切分文本：cut"></a>5. 按列切分文本：cut</h3><pre><code class="hljs">- 截取特定列<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为具体列范围</span><br><br>cut -f 1,2 test<br></code></pre></td></tr></table></figure>- 指定界定符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">截取的内存进行，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d后接界定符</span><br><br>cut -f 2 -d &#x27;,&#x27; new<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-按列拼接文本：paste"><a href="#6-按列拼接文本：paste" class="headerlink" title="6. 按列拼接文本：paste"></a>6. 按列拼接文本：paste</h3><pre><code class="hljs">- 按列拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br><br>paste test1 test2<br></code></pre></td></tr></table></figure>- 指定界定符拼接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照-d之后给出的界定符拼接</span><br><br>paste test1 test2 -d &quot;,&quot;<br></code></pre></td></tr></table></figure></code></pre><h3 id="7-统计行和字符：wc"><a href="#7-统计行和字符：wc" class="headerlink" title="7. 统计行和字符：wc"></a>7. 统计行和字符：wc</h3><pre><code class="hljs"> - 基本统计 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><br>wc -l test<br></code></pre></td></tr></table></figure></code></pre><h3 id="8-文本替换：sed"><a href="#8-文本替换：sed" class="headerlink" title="8. 文本替换：sed"></a>8. 文本替换：sed</h3><pre><code class="hljs">- 区别于上面的命令，sed是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9104.html)</code></pre><h3 id="9-数据流处理：awk"><a href="#9-数据流处理：awk" class="headerlink" title="9. 数据流处理：awk"></a>9. 数据流处理：awk</h3><pre><code class="hljs">- 区别于上面的命令，awk是可以直接改变被编辑文件内容的。- [详见](http://coolshell.cn/articles/9070.html)</code></pre><hr><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><span id = "sysinfo">系统信息</span></h2><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I&#x2F;O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><h3 id="1-进程查询：ps"><a href="#1-进程查询：ps" class="headerlink" title="1. 进程查询：ps"></a>1. 进程查询：ps</h3><pre><code class="hljs">- 查看正在运行进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><br>ps -ef<br></code></pre></td></tr></table></figure>- 以完整格式显示所有进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">常结合grep筛选信息</span><br><br>ps -ajx<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-进程监控：top"><a href="#2-进程监控：top" class="headerlink" title="2. 进程监控：top"></a>2. 进程监控：top</h3><pre><code class="hljs">- 显示实时进程信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%<span class="hljs-built_in">id</span>表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">%wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><br>top<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-打开文件查询：lsof"><a href="#3-打开文件查询：lsof" class="headerlink" title="3. 打开文件查询：lsof"></a>3. 打开文件查询：lsof</h3><ul><li>查看占用某端口的进程</li></ul><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br>   <br>lsof -i:53<br></code></pre></td></tr></table></figure>- 查看某用户打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-u(user)为用户，后接用户名</span><br>   <br>lsof -u inx<br></code></pre></td></tr></table></figure>- 查看指定进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(process)为进程，后接进程PID</span><br>   <br>lsof -p 12345<br></code></pre></td></tr></table></figure>- 查看指定目录下被进程打开的文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>   <br>lsof +d /test<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-内存使用量：free"><a href="#4-内存使用量：free" class="headerlink" title="4. 内存使用量：free"></a>4. 内存使用量：free</h3><pre><code class="hljs">- 内存使用量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><br>free<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-监控性能指标：sar"><a href="#5-监控性能指标：sar" class="headerlink" title="5. 监控性能指标：sar"></a>5. 监控性能指标：sar</h3><pre><code class="hljs">监控CPU- 监控CPU负载<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里<span class="hljs-string">&quot;1&quot;</span>表示采样时间间隔是1秒，这里<span class="hljs-string">&quot;2&quot;</span>表示采样次数为2</span><br><br>sar -q 1 2<br></code></pre></td></tr></table></figure>- 监控CPU使用率<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示CPU使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span><br><br>sar -u 1 2<br></code></pre></td></tr></table></figure>监控内存- 查询内存<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示内存使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数意义同上</span> <br><br>sar -r 1 2<br></code></pre></td></tr></table></figure>- 页面交换查询 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">参数意义同上</span><br><br>sar -W 1 2<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a><span id = "net">网络工具</span></h2><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><h3 id="1-网卡配置（链路层）：ifconfig"><a href="#1-网卡配置（链路层）：ifconfig" class="headerlink" title="1. 网卡配置（链路层）：ifconfig"></a>1. 网卡配置（链路层）：ifconfig</h3><pre><code class="hljs">- 显示设备信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以显示已激活的网络设备信息</span><br><br>ifconfig<br></code></pre></td></tr></table></figure>- 启动关闭指定网卡<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">up为打开，down为关闭</span><br><br>ifconfig eth0 up<br></code></pre></td></tr></table></figure>- 配置IP地址<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">前一个参数为具体网卡，后一个为配置的IP地址</span><br><br>ifconfig eth0 192.168.1.1<br></code></pre></td></tr></table></figure>- 设置最大传输单元<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">前一个参数为具体网卡，后面为MTU的大小<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置链路层MTU值，通常为1500</span><br><br>ifconfig eth0 mtu 1500<br></code></pre></td></tr></table></figure>- 启用和关闭ARP协议<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat"><a href="#2-查看当前网络连接（链路层-x2F-网络层-x2F-传输层）：netstat" class="headerlink" title="2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat"></a>2. 查看当前网络连接（链路层&#x2F;网络层&#x2F;传输层）：netstat</h3><pre><code class="hljs">- 网络接口信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示网卡信息，可结合ifconfig学习</span><br><br>netstat -i<br></code></pre></td></tr></table></figure>- 列出端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-l(listening)表示正在监听的端口</span><br><br>netstat -at<br></code></pre></td></tr></table></figure>- 显示端口统计信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(status)显示各协议信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><br>netstat -s<br></code></pre></td></tr></table></figure>- 显示使用某协议的应用名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><br>netstat -pt<br></code></pre></td></tr></table></figure>- 查找指定进程、端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个操作可以用lsof替代</span><br><br>netstat -ap | grep ssh<br>netstat -an | grep &#x27;:80&#x27;<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-查看路由表（网络层IP协议）：route"><a href="#3-查看路由表（网络层IP协议）：route" class="headerlink" title="3. 查看路由表（网络层IP协议）：route"></a>3. 查看路由表（网络层IP协议）：route</h3><pre><code class="hljs">- 查看路由信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过netstat -r(route)得到同样的路由表</span><br><br>route<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-检查网络连通性（网络层ICMP协议）：ping"><a href="#4-检查网络连通性（网络层ICMP协议）：ping" class="headerlink" title="4. 检查网络连通性（网络层ICMP协议）：ping"></a>4. 检查网络连通性（网络层ICMP协议）：ping</h3><pre><code class="hljs">- 检查是否连通<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">主要功能是检测网络连通性</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><br>ping baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-转发路径（网络层ICMP协议）：traceroute"><a href="#5-转发路径（网络层ICMP协议）：traceroute" class="headerlink" title="5. 转发路径（网络层ICMP协议）：traceroute"></a>5. 转发路径（网络层ICMP协议）：traceroute</h3><pre><code class="hljs">- 文件包途径的IP<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span></span><br><br>traceroute baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="6-网络Debug分析（网络层-x2F-传输层）：nc"><a href="#6-网络Debug分析（网络层-x2F-传输层）：nc" class="headerlink" title="6. 网络Debug分析（网络层&#x2F;传输层）：nc"></a>6. 网络Debug分析（网络层&#x2F;传输层）：nc</h3><pre><code class="hljs">- 端口扫描<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">黑客很喜欢</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描某服务器端口使用情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v(view)显示指令执行过程，-w(<span class="hljs-built_in">wait</span>)设置超时时长</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">数字为扫描的端口范围</span> <br><br>nc -v -w 1 baidu.com  -z 75-1000<br></code></pre></td></tr></table></figure>- [其他详见](https://www.oschina.net/translate/linux-netcat-command)</code></pre><h3 id="7-命令行抓包（网络层-x2F-传输层）：tcpdump"><a href="#7-命令行抓包（网络层-x2F-传输层）：tcpdump" class="headerlink" title="7. 命令行抓包（网络层&#x2F;传输层）：tcpdump"></a>7. 命令行抓包（网络层&#x2F;传输层）：tcpdump</h3><pre><code class="hljs">- 抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。- [详见](http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)</code></pre><h3 id="8-域名解析工具（应用层DNS协议）：dig"><a href="#8-域名解析工具（应用层DNS协议）：dig" class="headerlink" title="8. 域名解析工具（应用层DNS协议）：dig"></a>8. 域名解析工具（应用层DNS协议）：dig</h3><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">应用层，DNS</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印域名解析过程中涉及的各级DNS服务器地址</span><br><br>dig baidu.com<br></code></pre></td></tr></table></figure></code></pre><h3 id="9-网络请求（应用层）：curl"><a href="#9-网络请求（应用层）：curl" class="headerlink" title="9. 网络请求（应用层）：curl"></a>9. 网络请求（应用层）：curl</h3><pre><code class="hljs">- [详见](http://www.cnblogs.com/gbyukg/p/3326825.html)</code></pre><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><span id = "other">其他</span></h2><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><h3 id="1-终止进程：kill"><a href="#1-终止进程：kill" class="headerlink" title="1. 终止进程：kill"></a>1. 终止进程：kill</h3><pre><code class="hljs">- 杀死具体进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加具体进程PID</span><br><br>kill 12345<br></code></pre></td></tr></table></figure>- 杀死某进程相关进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加上<span class="hljs-string">&quot;-9&quot;</span>杀死某进程相关进程</span><br><br>kill -9 12345<br></code></pre></td></tr></table></figure></code></pre><h3 id="2-修改文件权限：chmod"><a href="#2-修改文件权限：chmod" class="headerlink" title="2. 修改文件权限：chmod"></a>2. 修改文件权限：chmod</h3><pre><code class="hljs">- 更改文件权限<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件可以有三种权限，r(<span class="hljs-built_in">read</span>)，w(write)，x(execute)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><br>chmod u+r file<br>chmod 777 file<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-创建链接：ln"><a href="#3-创建链接：ln" class="headerlink" title="3. 创建链接：ln"></a>3. 创建链接：ln</h3><pre><code class="hljs">- 创建硬链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><br>ln file1 file2<br></code></pre></td></tr></table></figure>- 创建软（符号链接）链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><br>ln -s file1 file2<br></code></pre></td></tr></table></figure></code></pre><h3 id="4-显示文件尾：tail"><a href="#4-显示文件尾：tail" class="headerlink" title="4. 显示文件尾：tail"></a>4. 显示文件尾：tail</h3><pre><code class="hljs">- 查看文件尾部<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志时常用</span><br><br>tail -f test<br></code></pre></td></tr></table></figure></code></pre><h3 id="5-版本控制：git"><a href="#5-版本控制：git" class="headerlink" title="5. 版本控制：git"></a>5. 版本控制：git</h3><pre><code class="hljs">- 版本控制最好用的软件，没有之一。至少要知道&quot;git init&quot;，&quot;git add&quot;，&quot;git commit&quot;，&quot;git pull&quot;，&quot;git push&quot;几个命令。- [详见](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/)</code></pre><h3 id="6-设置别名：alias"><a href="#6-设置别名：alias" class="headerlink" title="6. 设置别名：alias"></a>6. 设置别名：alias</h3><pre><code class="hljs">- 常用命令添加别名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;.bashrc&quot;</span>文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><br>alias rm=&#x27;rm -i&#x27;<br></code></pre></td></tr></table></figure></code></pre><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed">代码</a></p><h3 id="1-单步调试：gdb"><a href="#1-单步调试：gdb" class="headerlink" title="1. 单步调试：gdb"></a>1. 单步调试：gdb</h3><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><h3 id="2-动态库依赖：ldd"><a href="#2-动态库依赖：ldd" class="headerlink" title="2. 动态库依赖：ldd"></a>2. 动态库依赖：ldd</h3><ul><li><p>命令：ldd .&#x2F;server</p></li><li><p>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</p></li></ul><h3 id="3-性能分析：top"><a href="#3-性能分析：top" class="headerlink" title="3. 性能分析：top"></a>3. 性能分析：top</h3><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><h3 id="4-系统调用：strace"><a href="#4-系统调用：strace" class="headerlink" title="4. 系统调用：strace"></a>4. 系统调用：strace</h3><ul><li><p>命令：strace .&#x2F;server</p></li><li><p>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</p></li></ul><h3 id="5-打印进程：ps"><a href="#5-打印进程：ps" class="headerlink" title="5. 打印进程：ps"></a>5. 打印进程：ps</h3><ul><li><p>命令：ps -ejH</p></li><li><p>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</p></li></ul><h3 id="6-打开文件：lsof"><a href="#6-打开文件：lsof" class="headerlink" title="6. 打开文件：lsof"></a>6. 打开文件：lsof</h3><ul><li><p>lsof -i:3000</p></li><li><p>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</p></li></ul><h3 id="7-修改权限：chmod"><a href="#7-修改权限：chmod" class="headerlink" title="7. 修改权限：chmod"></a>7. 修改权限：chmod</h3><ul><li><p>chmod 000 .&#x2F;index.html</p></li><li><p>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000&#x2F;index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</p></li></ul><h3 id="8-网卡信息：ifconfig"><a href="#8-网卡信息：ifconfig" class="headerlink" title="8. 网卡信息：ifconfig"></a>8. 网卡信息：ifconfig</h3><ul><li><p>ifconfig</p></li><li><p>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</p></li></ul><h3 id="9-抓包分析：tcpdump"><a href="#9-抓包分析：tcpdump" class="headerlink" title="9. 抓包分析：tcpdump"></a>9. 抓包分析：tcpdump</h3><ul><li><p>tcpdump -i eth0 port 3000</p></li><li><p>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill-Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式-url</title>
    <link href="/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/"/>
    <url>/2022/05/10/%E5%88%86%E5%B8%83%E5%BC%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希表和完美哈希"><a href="#哈希表和完美哈希" class="headerlink" title="哈希表和完美哈希"></a><a href="https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html#perfect_hashing">哈希表和完美哈希</a></h2><h2 id="布隆过滤器的原理与实现"><a href="#布隆过滤器的原理与实现" class="headerlink" title="布隆过滤器的原理与实现"></a><a href="https://blog.51cto.com/u_12824426/2555710">布隆过滤器的原理与实现</a></h2><h2 id="布隆过滤器-阿里云开发者社区"><a href="#布隆过滤器-阿里云开发者社区" class="headerlink" title="布隆过滤器-阿里云开发者社区"></a><a href="https://developer.aliyun.com/article/773205">布隆过滤器-阿里云开发者社区</a></h2><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a>分布式面试题</h1><h2 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h2><h2 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h2><h2 id="分布式面试题-1"><a href="#分布式面试题-1" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h2>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式</title>
    <link href="/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h1 id="分布式事务面试题"><a href="#分布式事务面试题" class="headerlink" title="分布式事务面试题"></a><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">分布式事务面试题</a></h1><h1 id="分布式技术面试题-md"><a href="#分布式技术面试题-md" class="headerlink" title="分布式技术面试题.md "></a><a href="https://github.com/wangxw2008168/javaweb/blob/master/docs/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98.md">分布式技术面试题.md </a></h1><h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><a href="https://www.pch520.com/article/34#menu_0">分布式面试题</a></h1>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-url</title>
    <link href="/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/"/>
    <url>/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-url/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手-x2F-四次挥手"><a href="#三次握手-x2F-四次挥手" class="headerlink" title="三次握手&#x2F;四次挥手"></a>三次握手&#x2F;四次挥手</h1><h2 id="TCP的三次握手四次挥手理解及面试题"><a href="#TCP的三次握手四次挥手理解及面试题" class="headerlink" title="TCP的三次握手四次挥手理解及面试题"></a><a href="https://www.cnblogs.com/xp1315458571/articles/11361140.html">TCP的三次握手四次挥手理解及面试题</a></h2><h2 id="三次握手-x2F-四次挥手中的丢失情况及处理机制"><a href="#三次握手-x2F-四次挥手中的丢失情况及处理机制" class="headerlink" title="三次握手&#x2F;四次挥手中的丢失情况及处理机制"></a><a href="https://blog.51cto.com/u_14888059/3812405#:~:text=%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%20SYN-ACK%20%E6%8A%A5%E6%96%87%E5%90%8E%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9B%9E%E4%B8%80%E4%B8%AA,ACK%20%E6%8A%A5%E6%96%87%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E5%85%A5%E5%88%B0%20ESTABLISH%20%E7%8A%B6%E6%80%81%E3%80%82">三次握手&#x2F;四次挥手中的丢失情况及处理机制</a></h2><h1 id="滑窗-x2F-流控-x2F-拥塞"><a href="#滑窗-x2F-流控-x2F-拥塞" class="headerlink" title="滑窗&#x2F;流控&#x2F;拥塞"></a>滑窗&#x2F;流控&#x2F;拥塞</h1><h2 id="关于TCP乱序和重传的问题"><a href="#关于TCP乱序和重传的问题" class="headerlink" title="关于TCP乱序和重传的问题"></a><a href="https://blog.csdn.net/cws1214/article/details/52430554">关于TCP乱序和重传的问题</a></h2><h2 id="HTTP-与TCP中Keep-Alive机制的区别"><a href="#HTTP-与TCP中Keep-Alive机制的区别" class="headerlink" title="HTTP 与TCP中Keep-Alive机制的区别"></a><a href="https://cloud.tencent.com/developer/article/1430022">HTTP 与TCP中Keep-Alive机制的区别</a></h2><h2 id="HTTP-keep-alive和TCP-keepalive的区别"><a href="#HTTP-keep-alive和TCP-keepalive的区别" class="headerlink" title="HTTP keep-alive和TCP keepalive的区别"></a><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别</a></h2><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-x2F-2协议“多路复用”实现原理"><a href="#HTTP-x2F-2协议“多路复用”实现原理" class="headerlink" title="HTTP&#x2F;2协议“多路复用”实现原理"></a><a href="https://segmentfault.com/a/1190000016975064">HTTP&#x2F;2协议“多路复用”实现原理</a></h2><h2 id="Http发展历程-多路复用"><a href="#Http发展历程-多路复用" class="headerlink" title="Http发展历程-多路复用"></a><a href="https://juejin.cn/post/6844903935648497678">Http发展历程-多路复用</a></h2><h2 id="WebSocket-是什么原理？为什么可以实现持久连接？"><a href="#WebSocket-是什么原理？为什么可以实现持久连接？" class="headerlink" title="WebSocket 是什么原理？为什么可以实现持久连接？"></a><a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理？为什么可以实现持久连接？</a></h2><h2 id="POST-PUT和PATCH的区别"><a href="#POST-PUT和PATCH的区别" class="headerlink" title="POST,PUT和PATCH的区别"></a><a href="https://www.jianshu.com/p/bee85cf4e33a">POST,PUT和PATCH的区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-url</title>
    <link href="/2022/05/07/Redis-url/"/>
    <url>/2022/05/07/Redis-url/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis面试题-笔经面经-牛客网"><a href="#Redis面试题-笔经面经-牛客网" class="headerlink" title="Redis面试题_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/837063?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis面试题_笔经面经_牛客网</a></h2><h2 id="Redis超高频面试题和参考答案汇总！-笔经面经-牛客网"><a href="#Redis超高频面试题和参考答案汇总！-笔经面经-牛客网" class="headerlink" title="Redis超高频面试题和参考答案汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/941154?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1651208767878">Redis超高频面试题和参考答案汇总！_笔经面经_牛客网</a></h2><h2 id="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"><a href="#最全面的Redis缓存雪崩、击穿、穿透问题解决方案" class="headerlink" title="最全面的Redis缓存雪崩、击穿、穿透问题解决方案"></a><a href="https://segmentfault.com/a/1190000039300423">最全面的Redis缓存雪崩、击穿、穿透问题解决方案</a></h2><h2 id="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"><a href="#Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级" class="headerlink" title="Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"></a><a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></h2><h2 id="Redis-主从、哨兵和集群-区别"><a href="#Redis-主从、哨兵和集群-区别" class="headerlink" title="Redis 主从、哨兵和集群 区别"></a><a href="https://blog.csdn.net/u014527619/article/details/88232178">Redis 主从、哨兵和集群 区别</a></h2><h2 id="Memcached与Redis有什么区别"><a href="#Memcached与Redis有什么区别" class="headerlink" title="Memcached与Redis有什么区别"></a><a href="https://segmentfault.com/a/1190000023217491">Memcached与Redis有什么区别</a></h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-url</title>
    <link href="/2022/05/07/Mysql-url/"/>
    <url>/2022/05/07/Mysql-url/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><h2 id="MySQL超高频面试题汇总！-笔经面经-牛客网"><a href="#MySQL超高频面试题汇总！-笔经面经-牛客网" class="headerlink" title="MySQL超高频面试题汇总！_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/922991?type=post&order=jing&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=8EE8A0C4A6BA130B861D79D1B84FBF1F-1650335022589">MySQL超高频面试题汇总！_笔经面经_牛客网</a></h2><h2 id="B-树，B树，聚集索引，非聚集索引"><a href="#B-树，B树，聚集索引，非聚集索引" class="headerlink" title="B+树，B树，聚集索引，非聚集索引"></a><a href="https://blog.csdn.net/weixin_30565199/article/details/95851132">B+树，B树，聚集索引，非聚集索引</a></h2><h2 id="MySQL为什么用B-树存储索引？"><a href="#MySQL为什么用B-树存储索引？" class="headerlink" title="MySQL为什么用B+树存储索引？"></a><a href="https://blog.csdn.net/dl674756321/article/details/102987984">MySQL为什么用B+树存储索引？</a></h2><h2 id="高度为3的B-树能存多少行数据"><a href="#高度为3的B-树能存多少行数据" class="headerlink" title="高度为3的B+树能存多少行数据?"></a><a href="https://www.1024sou.com/article/40.html">高度为3的B+树能存多少行数据?</a></h2><h1 id="模糊查询与联合索引"><a href="#模糊查询与联合索引" class="headerlink" title="模糊查询与联合索引"></a>模糊查询与联合索引</h1><h2 id="LIKE-模糊查询概述"><a href="#LIKE-模糊查询概述" class="headerlink" title="LIKE%模糊查询概述"></a><a href="https://blog.csdn.net/weixin_34081595/article/details/93658047?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">LIKE%模糊查询概述</a></h2><h2 id="LIKE-开头的模糊查询的解决方法"><a href="#LIKE-开头的模糊查询的解决方法" class="headerlink" title="LIKE%开头的模糊查询的解决方法"></a><a href="https://blog.csdn.net/qq_42539533/article/details/93137526?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">LIKE%开头的模糊查询的解决方法</a></h2><h2 id="联合索引在B-树上的存储结构及数据查找方式"><a href="#联合索引在B-树上的存储结构及数据查找方式" class="headerlink" title="联合索引在B+树上的存储结构及数据查找方式"></a><a href="https://www.cnblogs.com/ibigboy/p/12373978.html">联合索引在B+树上的存储结构及数据查找方式</a></h2><h2 id="索引最左前缀匹配原则"><a href="#索引最左前缀匹配原则" class="headerlink" title="索引最左前缀匹配原则"></a><a href="https://blog.csdn.net/yuanchangliang/article/details/107798724">索引最左前缀匹配原则</a></h2><h1 id="事务与MVCC机制"><a href="#事务与MVCC机制" class="headerlink" title="事务与MVCC机制"></a>事务与MVCC机制</h1><h2 id="MySql解决幻读-x2F-不可重复读以及MVCC机制"><a href="#MySql解决幻读-x2F-不可重复读以及MVCC机制" class="headerlink" title="MySql解决幻读&#x2F;不可重复读以及MVCC机制"></a><a href="https://blog.csdn.net/qq_42799615/article/details/110942949">MySql解决幻读&#x2F;不可重复读以及MVCC机制</a></h2><h2 id="MySQL-如何解决幻读（MVCC-原理分析）"><a href="#MySQL-如何解决幻读（MVCC-原理分析）" class="headerlink" title="MySQL 如何解决幻读（MVCC 原理分析）"></a><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析）</a></h2><h2 id="从ReadView深入理解MySql-MVCC原理"><a href="#从ReadView深入理解MySql-MVCC原理" class="headerlink" title="从ReadView深入理解MySql MVCC原理"></a><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></h2><h2 id="MySQL间隙锁、Next-Key-Lock主要知识点"><a href="#MySQL间隙锁、Next-Key-Lock主要知识点" class="headerlink" title="MySQL间隙锁、Next-Key Lock主要知识点"></a><a href="https://www.jianshu.com/p/d5c2613cbb81">MySQL间隙锁、Next-Key Lock主要知识点</a></h2><h1 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h1><h2 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a><a href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别（9个不同点）</a></h2><h2 id="Innodb-Purge简介"><a href="#Innodb-Purge简介" class="headerlink" title="Innodb Purge简介"></a><a href="https://juejin.cn/post/6844903686393561096">Innodb Purge简介</a></h2><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="我终于看懂了HBase"><a href="#我终于看懂了HBase" class="headerlink" title="我终于看懂了HBase"></a><a href="https://zhuanlan.zhihu.com/p/145551967">我终于看懂了HBase</a></h2><h2 id="入门HBase，看这一篇就够了"><a href="#入门HBase，看这一篇就够了" class="headerlink" title="入门HBase，看这一篇就够了"></a><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></h2>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++-url</title>
    <link href="/2022/05/07/C++-url/"/>
    <url>/2022/05/07/C++-url/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="C-多态与虚函数"><a href="#C-多态与虚函数" class="headerlink" title="C++多态与虚函数"></a><a href="http://c.biancheng.net/cplus/polymorphism/">C++多态与虚函数</a></h2><h1 id="C-高级特性"><a href="#C-高级特性" class="headerlink" title="C++高级特性"></a>C++高级特性</h1><h2 id="智能指针详解-博客园"><a href="#智能指针详解-博客园" class="headerlink" title="智能指针详解-博客园"></a><a href="https://www.cnblogs.com/linuxandmcu/p/10409723.html">智能指针详解-博客园</a></h2><h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a><a href="http://c.biancheng.net/view/7829.html">C++11右值引用</a></h2><h2 id="右值引用-amp-转移语义-amp-完美转发"><a href="#右值引用-amp-转移语义-amp-完美转发" class="headerlink" title="右值引用 &amp; 转移语义 &amp; 完美转发"></a><a href="https://www.irimsky.top/archives/296/">右值引用 &amp; 转移语义 &amp; 完美转发</a></h2><h1 id="STL原理"><a href="#STL原理" class="headerlink" title="STL原理"></a>STL原理</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="deque容器底层实现原理（深度剖析）"><a href="#deque容器底层实现原理（深度剖析）" class="headerlink" title="deque容器底层实现原理（深度剖析）"></a><a href="http://c.biancheng.net/view/6908.html">deque容器底层实现原理（深度剖析）</a></h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-url</title>
    <link href="/2022/05/07/Linux-url/"/>
    <url>/2022/05/07/Linux-url/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h1><h2 id="WebServer项目概述-ZWiley的随记"><a href="#WebServer项目概述-ZWiley的随记" class="headerlink" title="WebServer项目概述 - ZWiley的随记"></a><a href="https://zwiley.github.io/mybook/webserver/0%20%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/">WebServer项目概述 - ZWiley的随记</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（一）"><a href="#WebServer服务器项目可能会被问到的问题（一）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（一）"></a><a href="https://www.nowcoder.com/discuss/934904">WebServer服务器项目可能会被问到的问题（一）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题（二）"><a href="#WebServer服务器项目可能会被问到的问题（二）" class="headerlink" title="WebServer服务器项目可能会被问到的问题（二）"></a><a href="https://www.nowcoder.com/discuss/939267?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题（二）</a></h2><h2 id="WebServer服务器项目可能会被问到的问题-三-完结"><a href="#WebServer服务器项目可能会被问到的问题-三-完结" class="headerlink" title="WebServer服务器项目可能会被问到的问题(三)完结"></a><a href="https://www.nowcoder.com/discuss/945403?channel=-1&source_id=profile_follow_post_nctrack">WebServer服务器项目可能会被问到的问题(三)完结</a></h2><h2 id="Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读"><a href="#Linux高性能服务器编程-游双-著-机械工业出版社-豆瓣阅读" class="headerlink" title="Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读"></a><a href="https://read.douban.com/reader/ebook/15233070/?dcs=bookshelf">Linux高性能服务器编程 - 游双 著 机械工业出版社 | 豆瓣阅读</a></h2><h2 id="qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器"><a href="#qinguoyi-x2F-TinyWebServer-Linux下C-轻量级Web服务器" class="headerlink" title="qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器"></a><a href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器</a></h2><h2 id="彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云"><a href="#彻底搞懂Reactor模型和Proactor模型-云-社区-腾讯云" class="headerlink" title="彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云"></a><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云</a></h2><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金"><a href="#虚拟地址空间、用户空间、内核空间、用户态与内核态-掘金" class="headerlink" title="虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金"></a><a href="https://juejin.cn/post/6990237426903957540">虚拟地址空间、用户空间、内核空间、用户态与内核态 - 掘金</a></h2><h2 id="linux下进程和线程状态查看"><a href="#linux下进程和线程状态查看" class="headerlink" title="linux下进程和线程状态查看"></a><a href="https://blog.csdn.net/huangjin0507/article/details/77848386">linux下进程和线程状态查看</a></h2><h2 id="socket阻塞和非阻塞有哪些影响-CSDN"><a href="#socket阻塞和非阻塞有哪些影响-CSDN" class="headerlink" title="socket阻塞和非阻塞有哪些影响-CSDN"></a><a href="https://blog.csdn.net/mayue_web/article/details/82873115">socket阻塞和非阻塞有哪些影响-CSDN</a></h2><h2 id="句柄和文件描述符-简书"><a href="#句柄和文件描述符-简书" class="headerlink" title="句柄和文件描述符-简书"></a><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符-简书</a></h2><h2 id="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"><a href="#Linux文件存储结构，包括目录项、inode、数据块-C语言中文网" class="headerlink" title="Linux文件存储结构，包括目录项、inode、数据块-C语言中文网"></a><a href="http://c.biancheng.net/cpp/html/2780.html">Linux文件存储结构，包括目录项、inode、数据块-C语言中文网</a></h2><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令与shell-菜鸟教程"><a href="#Linux命令与shell-菜鸟教程" class="headerlink" title="Linux命令与shell- 菜鸟教程"></a><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令与shell- 菜鸟教程</a></h2><h2 id="Linux命令大全教程"><a href="#Linux命令大全教程" class="headerlink" title="Linux命令大全教程"></a><a href="https://www.yiibai.com/linux/lsof.html">Linux命令大全教程</a></h2><h2 id="shell脚本指南"><a href="#shell脚本指南" class="headerlink" title="shell脚本指南"></a><a href="http://c.biancheng.net/view/706.html">shell脚本指南</a></h2><h2 id="linux的top命令参数详解-博客园"><a href="#linux的top命令参数详解-博客园" class="headerlink" title="linux的top命令参数详解-博客园"></a><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html">linux的top命令参数详解-博客园</a></h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>校招面经-url</title>
    <link href="/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/"/>
    <url>/2022/05/07/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F-url/</url>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="十道海量数据处理面试题与十个方法大总结"><a href="#十道海量数据处理面试题与十个方法大总结" class="headerlink" title="十道海量数据处理面试题与十个方法大总结"></a><a href="https://blog.csdn.net/v_JULY_v/article/details/6279498?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">十道海量数据处理面试题与十个方法大总结</a></h2><h2 id="面试题：从n个数中找出第K大的数"><a href="#面试题：从n个数中找出第K大的数" class="headerlink" title="面试题：从n个数中找出第K大的数"></a><a href="https://blog.csdn.net/orangefly0214/article/details/86527462">面试题：从n个数中找出第K大的数</a></h2><h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="互联网大厂最爱问的智力题总结（带详细答案）"><a href="#互联网大厂最爱问的智力题总结（带详细答案）" class="headerlink" title="互联网大厂最爱问的智力题总结（带详细答案）"></a><a href="https://www.nowcoder.com/discuss/754712?type=1&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack">互联网大厂最爱问的智力题总结（带详细答案）</a></h2><h1 id="常见排序方法实现"><a href="#常见排序方法实现" class="headerlink" title="常见排序方法实现"></a>常见排序方法实现</h1><h2 id="创建堆，堆排序的详细实现过程，C-完整代码"><a href="#创建堆，堆排序的详细实现过程，C-完整代码" class="headerlink" title="创建堆，堆排序的详细实现过程，C++完整代码"></a><a href="https://blog.csdn.net/ahfytao/article/details/47681221">创建堆，堆排序的详细实现过程，C++完整代码</a></h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bigsai/p/13396391.html">桶排序</a></h2><h1 id="C-面经"><a href="#C-面经" class="headerlink" title="C++面经"></a>C++面经</h1><h2 id="C-x2F-C-技术面试基础知识总结-huihut"><a href="#C-x2F-C-技术面试基础知识总结-huihut" class="headerlink" title="C&#x2F;C++ 技术面试基础知识总结-huihut"></a><a href="https://interview.huihut.com/#/">C&#x2F;C++ 技术面试基础知识总结-huihut</a></h2><h2 id="【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网"><a href="#【C-工程师面试宝典】学习说明-互联网校招面试真题面经汇总-牛客网" class="headerlink" title="【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网"></a><a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网</a></h2><h2 id="牛客网收藏面经"><a href="#牛客网收藏面经" class="headerlink" title="牛客网收藏面经"></a><a href="https://www.nowcoder.com/profile/674401673/following-posts">牛客网收藏面经</a></h2><h2 id="GoGoCoder面经"><a href="#GoGoCoder面经" class="headerlink" title="GoGoCoder面经"></a><a href="https://gogocoder.com/face">GoGoCoder面经</a></h2><h2 id="C-工程师精选面经汇总-校招实习社招-牛客网-牛客网"><a href="#C-工程师精选面经汇总-校招实习社招-牛客网-牛客网" class="headerlink" title="C++工程师精选面经汇总_校招实习社招_牛客网_牛客网"></a><a href="https://www.nowcoder.com/discuss/experience?tagId=640">C++工程师精选面经汇总_校招实习社招_牛客网_牛客网</a></h2><h1 id="Java面经"><a href="#Java面经" class="headerlink" title="Java面经"></a>Java面经</h1><h2 id="Java-全栈知识体系"><a href="#Java-全栈知识体系" class="headerlink" title="Java 全栈知识体系"></a><a href="https://pdai.tech/">Java 全栈知识体系</a></h2>]]></content>
    
    
    <categories>
      
      <category>校招面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大厂笔试参考资料-url</title>
    <link href="/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/"/>
    <url>/2022/05/07/%E5%A4%A7%E5%8E%82%E7%AC%94%E8%AF%95%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-url/</url>
    
    <content type="html"><![CDATA[<h1 id="ACM输入输出"><a href="#ACM输入输出" class="headerlink" title="ACM输入输出"></a>ACM输入输出</h1><h2 id="ACM输入方式-C-代码先锋网"><a href="#ACM输入方式-C-代码先锋网" class="headerlink" title="ACM输入方式-C++ - 代码先锋网"></a><a href="https://www.codeleading.com/article/50865910043/">ACM输入方式-C++ - 代码先锋网</a></h2><h2 id="C-使用stringstream与getline-分割字符串"><a href="#C-使用stringstream与getline-分割字符串" class="headerlink" title="C++使用stringstream与getline()分割字符串"></a><a href="https://blog.csdn.net/qq_36743440/article/details/91999615">C++使用stringstream与getline()分割字符串</a></h2><h2 id="C-中的cin以及stringstream"><a href="#C-中的cin以及stringstream" class="headerlink" title="C++中的cin以及stringstream"></a><a href="https://blog.csdn.net/flow_specter/article/details/116503515">C++中的cin以及stringstream</a></h2><h2 id="ACM模式数组构建二叉树"><a href="#ACM模式数组构建二叉树" class="headerlink" title="ACM模式数组构建二叉树"></a><a href="https://blog.csdn.net/m0_47240785/article/details/123406393">ACM模式数组构建二叉树</a></h2><h2 id="完全二叉树的顺序储存结构（C-完整代码）"><a href="#完全二叉树的顺序储存结构（C-完整代码）" class="headerlink" title="完全二叉树的顺序储存结构（C++完整代码）"></a><a href="https://blog.csdn.net/qq_52284035/article/details/118025460">完全二叉树的顺序储存结构（C++完整代码）</a></h2><h1 id="STL基础及模板"><a href="#STL基础及模板" class="headerlink" title="STL基础及模板"></a>STL基础及模板</h1><h2 id="C-STL标准库基础"><a href="#C-STL标准库基础" class="headerlink" title="C++ STL标准库基础"></a><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></h2><h2 id="C-STL中Map的按Key排序和按Value排序"><a href="#C-STL中Map的按Key排序和按Value排序" class="headerlink" title="C++ STL中Map的按Key排序和按Value排序"></a><a href="https://blog.csdn.net/iicy266/article/details/11906189">C++ STL中Map的按Key排序和按Value排序</a></h2><h2 id="优先队列详解-ACM例题分析"><a href="#优先队列详解-ACM例题分析" class="headerlink" title="优先队列详解+ACM例题分析"></a><a href="https://blog.csdn.net/qq_38492462/article/details/78631091">优先队列详解+ACM例题分析</a></h2><h1 id="大厂笔试题解"><a href="#大厂笔试题解" class="headerlink" title="大厂笔试题解"></a>大厂笔试题解</h1><h2 id="4-6-华为笔试题解-笔经面经-牛客网"><a href="#4-6-华为笔试题解-笔经面经-牛客网" class="headerlink" title="4.6 华为笔试题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/924780">4.6 华为笔试题解_笔经面经_牛客网</a></h2><h2 id="腾讯2022实习生笔试情况与题解-笔经面经-牛客网"><a href="#腾讯2022实习生笔试情况与题解-笔经面经-牛客网" class="headerlink" title="腾讯2022实习生笔试情况与题解_笔经面经_牛客网"></a><a href="https://www.nowcoder.com/discuss/940859">腾讯2022实习生笔试情况与题解_笔经面经_牛客网</a></h2><h2 id="拓扑排序-知乎"><a href="#拓扑排序-知乎" class="headerlink" title="拓扑排序 - 知乎"></a><a href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序 - 知乎</a></h2>]]></content>
    
    
    <categories>
      
      <category>大厂笔试参考资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件描述符及三种拷贝命令</title>
    <link href="/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/06/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-文件描述符概念"><a href="#一-文件描述符概念" class="headerlink" title="一. 文件描述符概念"></a>一. 文件描述符概念</h1><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符</p></blockquote><p><strong>关于文件描述符，Linux内核维护了3个数据结构</strong></p><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137792.png"><br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062137233.gif"></p><ul><li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的</li><li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样(概率很低)</li><li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况</li></ul><hr><h1 id="二-Linux文件和目录"><a href="#二-Linux文件和目录" class="headerlink" title="二. Linux文件和目录"></a>二. Linux文件和目录</h1><p>Linux文件是树形结构，inode是平坦结构，通过inode-&gt;i_mode字段，即S_ISREG、S_ISDIR两个宏判断是哪个类型。</p><ul><li><p>普通文件：<strong>inode</strong>里面存储元数据，inode索引到block，block存储数据</p></li><li><p>目录文件：inode索引到block，block中存储许多dirent目录条目，即名字到inode number的映射表<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138975.webp"></p></li></ul><p>目录文件的block区域如下：<br><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062138621.webp"></p><p>内存的树形结构：</p><ul><li>dentry 绑定到唯一一个 inode 结构体；</li><li>dentry 有父，子，兄弟的索引路径，有这个就足够在内存中构建一个树了，并且事实也确实如此；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>  *<span class="hljs-title">d_parent</span>;</span>   <span class="hljs-comment">/* 父节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span>     <span class="hljs-title">d_name</span>;</span>      <span class="hljs-comment">// 名字</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>   *<span class="hljs-title">d_inode</span>;</span>    <span class="hljs-comment">// inode 结构体</span><br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_child</span>;</span>     <span class="hljs-comment">/* 兄弟节点 */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span>   <span class="hljs-comment">/* 子节点 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="三-ln命令"><a href="#三-ln命令" class="headerlink" title="三. ln命令"></a>三. ln命令</h1><ul><li><p>软链接：软链接文件是一个全新的文件，有独立的 inode，有自己的 block ，内容是一段 path 路径，这个路径直接指向源文件；</p><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139893.webp"></p></li><li><p>硬链接：</p><blockquote><p>硬链接文件其实并没有新建文件（也就是说，没有消耗 inode 和 文件所需的 block 块）；</p><p>硬链接其实是修改了当前目录所在的目录文件，加了一个 dirent 而已，这个 dirent 用一个新的 name 名字指向原来的 inode number；</p><p>由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：<strong>不能跨文件系统。因为，不同文件系统的 inode 管理都是独立的。</strong></p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202205062139421.webp"></p><p>总结：<strong>硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化。新的 name 指向原来的 inode。</strong></p><hr><h1 id="四-mv命令"><a href="#四-mv命令" class="headerlink" title="四. mv命令"></a>四. mv命令</h1><ul><li>源文件和目标文件在同一文件系统下：</li></ul><blockquote><p>mv 命令的核心操作是系统调用 rename ，rename 从内核实现来说只涉及到元数据的操作，只涉及到 dirent 的增删；</p><p><strong>inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。</strong></p></blockquote><br><ul><li>源文件和目标文件不在同一文件系统下：</li></ul><blockquote><p> 系统调用 rename 的时候，如果<strong>源</strong>和<strong>目的</strong>不在同一文件系统时，会报告 EXDEV 的错误码，提示该调用不能跨文件系统。</p></blockquote><p><strong>这个时候操作分成两步走，先 copy ，后 remove：</strong></p><ol><li><p>走不了 rename ，那么就退化成 copy ，也就是真正的拷贝。读取源文件，写入目标位置，生成一个全新的目标文件副本；</p><blockquote><p>这里调用的 copy_reg 的函数封装；</p><p>ln，mv，cp 是在 coreutils 库里的命令，公用函数本身就是可以复用的；</p></blockquote></li><li><p>删除源文件，使用 rm 函数删除；</p></li></ol><hr><h1 id="五-cp命令"><a href="#五-cp命令" class="headerlink" title="五. cp命令"></a>五. cp命令</h1><p><a href="https://juejin.cn/post/6939328247922425869">深度剖析 Linux cp 的秘密-博客</a></p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h1><ol><li>目录文件是一种特殊的文件，可以理解成存储的是 dirent 列表。dirent 只是名字到 inode 的映射，这个是树形结构的基础；</li><li>常说目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；</li><li>ln -s 创建软链接文件，软链接文件是一个独立的新文件，有一个新的 inode ，有新的 dentry，文件类型为 link，文件内容就是<strong>一条指向源的路径</strong>，所以<strong>软链的创建可以无视文件系统，跨越山河；</strong></li><li>ln 默认创建硬连接，硬链接文件只在目录文件里添加了一个新 dirent 项 (新name:原inode)，文件 inode 还是和原文件同一个，<strong>所以硬链接不能跨文件系统（因为不同的文件系统是独立的一套 inode 管理方式，不同的文件系统实例对 inode number 的解释各有不同）；</strong></li><li>ln 命令貌似创建出了新文件，但其实不然，ln 只跟元数据相关，涉及到 dirent  的变动，<strong>不涉及到数据的拷贝</strong>，起不到数据备份的目的；</li><li>mv 其实是调用 rename 调用，<strong>在同一个文件系统中不涉及到数据拷贝，只涉及到元数据变更</strong>（ dirent 的增删 ），所以速度也很快。但如果 mv 的源和目的<strong>在不同的文件系统，那么就会退化成真正的 copy ，会涉及到数据拷贝</strong>，这个时候速度相对慢一些，慢成什么样子？就跟 cp 命令一样；</li><li>cp 命令才是真正的数据拷贝命令，速度可能相对慢一些，但是 cp 命令有 –spare 可以优化拷贝速度，针对空洞和全 0 数据，可以跳过，从而<strong>针对稀疏文件可以节省大量磁盘 IO</strong>；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PersonalSummary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
