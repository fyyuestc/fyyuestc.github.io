

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fyy">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、OS基础1.硬件结构2.操作系统结构2.1用户态和内核态 概念 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同 用户态拥有最低的特权级，内核态拥有较高的特权级 运行在用户态的程序不能直接访问操作系统内核数据结构和程序 操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的 分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性 分开存放，管理上很方">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux面经-个人总结">
<meta property="og:url" content="http://example.com/2022/07/09/Linux%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="UESTC-Fyy">
<meta property="og:description" content="一、OS基础1.硬件结构2.操作系统结构2.1用户态和内核态 概念 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同 用户态拥有最低的特权级，内核态拥有较高的特权级 运行在用户态的程序不能直接访问操作系统内核数据结构和程序 操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的 分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性 分开存放，管理上很方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png">
<meta property="article:published_time" content="2022-07-09T07:15:07.000Z">
<meta property="article:modified_time" content="2022-08-25T08:42:56.766Z">
<meta property="article:author" content="Fyy">
<meta property="article:tag" content="PersonalSummary">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png">
  
  
  <title>Linux面经-个人总结 - UESTC-Fyy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DKnIWAmLCrVnCLIBVwd8hotg-gzGzoHsz","app_key":"9xmUpEdyRJB2o9bIKREcXk3j","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>UESTC-Fyy-Master</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux面经-个人总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-09 15:15" pubdate>
          2022年7月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          248 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux面经-个人总结</h1>
            
            <div class="markdown-body">
              
              <h2 id="一、OS基础"><a href="#一、OS基础" class="headerlink" title="一、OS基础"></a>一、OS基础</h2><h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1.硬件结构"></a>1.硬件结构</h2><h2 id="2-操作系统结构"><a href="#2-操作系统结构" class="headerlink" title="2.操作系统结构"></a>2.<strong>操作系统结构</strong></h2><h3 id="2-1用户态和内核态"><a href="#2-1用户态和内核态" class="headerlink" title="2.1用户态和内核态"></a>2.1用户态和内核态</h3><ul>
<li><strong>概念</strong><ul>
<li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同</li>
<li>用户态拥有最低的特权级，内核态拥有较高的特权级</li>
<li>运行在用户态的程序不能直接访问操作系统内核数据结构和程序</li>
<li>操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的<ul>
<li>分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性</li>
<li>分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统</li>
</ul>
</li>
</ul>
</li>
<li><strong>用户态和内核态可以通过指针传递数据吗？</strong><ul>
<li><strong>用户态不能访问内核态的指针</strong><ul>
<li>为了实现内存的保护，防止越界访问而造成受保护内存的被非法修改，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的</li>
</ul>
</li>
<li><strong>内核态可以访问用户态的指针(有前提)</strong><ul>
<li>必须保证用户态虚拟空间的指针（虚拟空间的地址），已经分配物理地址，否则指针传入内核态中将不会引发缺页异常而报错</li>
</ul>
</li>
<li><strong>内核中访问用户进程的地址的时候用copy_from_user，而不是用memcpy直接拷贝(或者说使用用户态指针)</strong><ul>
<li><strong>copy_from_user主要是这个函数提供了两个功能</strong><ul>
<li>对用户进程传过来的地址范围进行合法性检查</li>
<li>当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行</li>
<li>对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表。这个过程对于用户进程是完全透明的。但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误</li>
</ul>
</li>
<li><strong>直接使用memcpy时为什么没有出现异常</strong><ul>
<li>只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>两种状态转换</strong><ul>
<li><strong>系统调用</strong><ul>
<li>用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作</li>
</ul>
</li>
<li><strong>异常</strong><ul>
<li>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常</li>
</ul>
</li>
<li><strong>外围设备中断</strong><ul>
<li>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序</li>
<li>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2库函数和系统调用的区别"><a href="#2-2库函数和系统调用的区别" class="headerlink" title="2.2库函数和系统调用的区别"></a>2.2库函数和系统调用的区别</h3><ul>
<li><strong>概念</strong><ul>
<li>库函数调用是语言或应用程序的一部分，而系统调用是操作系统的一部分，<strong>跨平台技术的原理就是通过库函数实现的，库函数可以理解为是对系统调用的一层封装，但库函数不是必须包含系统调用</strong></li>
<li>库函数有可能包含有一个系统调用，有可能有好几个系统调用，当然也有可能没有系统调用，比如有些操作不需要涉及内核的功能</li>
</ul>
</li>
<li><strong>区别</strong><ul>
<li>所有 C 函数库是相同的，而各个操作系统的系统调用是不同的</li>
<li>函数库调用是调用函数库中的一个程序，而系统调用是调用系统内核的服务</li>
<li>函数库调用是与用户程序相联系，而系统调用是操作系统的一个进入点</li>
<li>函数库调用是在用户地址空间执行，而系统调用是在内核地址空间执行</li>
<li>函数库调用的运行时间属于「用户」时间，而系统调用的运行时间属于「系统」时间</li>
<li>函数库调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大</li>
<li>在C函数库libc中大约 300 个程序，在 UNIX 中大约有 90 个系统调用</li>
<li>函数库典型的 C 函数：system, fprintf, malloc，而典型的系统调用：chdir, fork, write, brk</li>
</ul>
</li>
<li><strong>为什么不直接用函数调用</strong><ul>
<li>因为读写文件通常是大量的数据（相对于底层驱动的系统调用所实现的数据操作单位），这时，使用库函数可以大大减少系统调用的次数。这是因为<strong>缓冲区技术</strong>，<strong>在用户空间和内核空间对文件操作都使用了缓冲区。当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓存区</strong>。同理，内核缓冲区满或写结束时，才将内核缓冲区内容写到文件对应的硬件媒介</li>
<li><strong>为了保证可移植性，现有跨平台技术就是通过库函数调用实现的</strong>，不使用系统函数调用。Qt各个操作系统都有特定的宏，然后代码里面根据不同的宏调用不同平台的API</li>
</ul>
</li>
<li><strong>库函数的缓冲区</strong><ul>
<li><p>对于库函数，如果标准输出连到终端设备(直接输出到屏幕)，则它是行缓冲的（遇到回车换行符或者是缓冲区满了才输出）；否则（输出到文件）是全缓冲的（缓冲区填满或者是程序运行结束了才输出）</p>
</li>
<li><p>程序运行结束时，会刷新所有的缓冲区<br>由于上面的缓冲机制，也给我们编写程序时带来了一些奇怪的问题。解决办法有如下两种：</p>
</li>
<li><p>任何时候我们都可以使用fflush(stdout)来刷新标准输出缓冲区</p>
</li>
<li><p>使用不带缓冲的系统调用write替代printf输出</p>
</li>
</ul>
</li>
<li><strong>系统调用底层原理</strong><ul>
<li>每个系统调用函数都有一个系统调用号</li>
<li>首先找到系统调用对应的中断号（Linux下是int 0x80），然后在中断向量表中找到对应的中断处理函数，再根据系统调用号，在中断处理函数找到对应系统调用函数进行执行</li>
</ul>
</li>
</ul>
<h3 id="2-3计算密集任务和IO密集任务"><a href="#2-3计算密集任务和IO密集任务" class="headerlink" title="2.3计算密集任务和IO密集任务"></a>2.3计算密集任务和IO密集任务</h3><ul>
<li><strong>计算密集型任务</strong><ul>
<li>特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力</li>
<li>虽然可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数</li>
</ul>
</li>
<li><strong>IO密集型任务</strong><ul>
<li>涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）</li>
<li>对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用</li>
</ul>
</li>
</ul>
<h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h2><h3 id="3-1程序的局部性原理"><a href="#3-1程序的局部性原理" class="headerlink" title="3.1程序的局部性原理"></a>3.1程序的局部性原理</h3><ul>
<li><p><strong>基本概念</strong><br>程序倾向于引用临近于其他最近引用过的数据项的数据项，或最近引用过的数据项本身，这种倾向性被称为局部性原理</p>
<ul>
<li><strong>时间局部性</strong><ul>
<li>良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用</li>
</ul>
</li>
<li><strong>空间局部性</strong><ul>
<li>良好空间局部性的程序中，一个内存位置被引用，程序很可能在不远的将来引用其附近的一个内存位置</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>从硬件和操作系统层面看如何利用局部性</strong></p>
<ul>
<li><strong>硬件层</strong><ul>
<li>局部性原理允许硬件引入高速缓存存储器这种小而快速的存储器来存储最近被引用的指令和数据，从而提高对主存的访问速度</li>
</ul>
</li>
<li><strong>操作系统</strong><ul>
<li>允许系统使用主存作为虚拟地址空间作为最近被引用块的高速缓存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>从存储结构看如何利用局部性</strong><br>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存</p>
<ul>
<li><strong>时间局部性</strong><ul>
<li>同一数据对象可能被多次使用。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中的快很多</li>
</ul>
</li>
<li><strong>空间局部性</strong><ul>
<li>块通常包含多个数据对象。我们会期望后面对该块中其他对象的访问能补偿不命中后复制该块的花费</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2存储器层次结构"><a href="#3-2存储器层次结构" class="headerlink" title="3.2存储器层次结构"></a>3.2存储器层次结构</h3><ul>
<li><p><strong>层次结构</strong><br>本地磁盘 -&gt; 主存(DRAM) -&gt; L3高速缓存(SRAM) -&gt; L2高速缓存(SRAM) -&gt; L1高速缓存(SRAM) -&gt; L0寄存器</p>
</li>
<li><p><strong>缓存思想</strong></p>
<ul>
<li>位于K层的更快更小的存储设备作为位于K+1层更大更慢的存储设备的缓存</li>
<li>K+1层的存储器被划分成连续的数据对象组块，称为块，数据总是以块大小为传送单元在K和K+1层之间来回复制</li>
</ul>
</li>
<li><p><strong>缓存命中</strong></p>
<ul>
<li>当程序需要K+1层的某个数据对象d时，首先在当前存储在K层的块中查找d，若d刚好缓存在k层中，则称为缓存命中</li>
<li>若缓存不命中，则需要将K+1层中包含对象d的块缓存到K层中，若K层中满了，则需要替换现存的一个块</li>
</ul>
</li>
</ul>
<h3 id="3-3虚拟内存页表寻址"><a href="#3-3虚拟内存页表寻址" class="headerlink" title="3.3虚拟内存页表寻址"></a>3.3虚拟内存页表寻址</h3><ul>
<li><strong>什么是虚拟内存</strong><ul>
<li>为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存，防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存</li>
<li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存</strong>，也<strong>不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令</li>
<li>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</li>
</ul>
</li>
<li><strong>虚拟内存的好处</strong><ul>
<li><strong>可以更加高效的使用物理内存</strong><ul>
<li>虚拟地址空间一开始并没有真正的对应物理地址，而是在真正使用的时候才去对应</li>
<li>通过虚拟内存置换算法在访问后边的地址空间的时候就可以将前边当前没有在访问的物理页释放掉，或者交换到硬盘中。这样这个物理页又可以去对应新的虚拟地址。从而使物理内存可以充分的利用</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li>为每个进程提供了一致的地址空间，简化内存管理</li>
</ul>
</li>
<li><strong>内存保护</strong><ul>
<li>在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提高了系统的封装性</li>
<li>保护了每个进程的地址空间不被其他进程破坏</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚拟内存页表寻址</strong><ul>
<li><p><strong>分页</strong><br>虚拟内存分割成虚拟页，物理内存被分割成物理页，用来作为磁盘和主存的传输单元。 虚拟页分为三个不相交的子集</p>
<ul>
<li>未分配的，不占磁盘空间</li>
<li>缓存的，当前已缓存在物理内存中的已分配页，在页表中标志位为1</li>
<li>未缓存的，未缓存在物理内存中的已分配页，在页表中标志位为0</li>
</ul>
</li>
<li><p><strong>页表</strong></p>
<ul>
<li>内存管理单元（MMU，属于硬件）管理着地址空间和物理内存的转换，操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，存储着程序地址空间到物理内存空间的映射表</li>
<li>页表存放在物理内存中，物理页存放在物理内存中，虚拟页存放在磁盘上</li>
</ul>
</li>
<li><p><strong>页表寻址</strong></p>
<ul>
<li>一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量</li>
<li>页表分为序号、页基地址、标志位</li>
<li>访问虚拟地址，先通过页表查询页面号，查看标志位确认虚拟地址是否在物理内存中有缓存，然后由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移虚拟地址中的偏移量就得到最后的物理地址</li>
<li>一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间</li>
</ul>
</li>
</ul>
</li>
<li><strong>缺页中断</strong><ul>
<li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存</li>
<li><strong>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</strong><ul>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ul>
</li>
<li><strong>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</strong><ul>
<li>在指令执行期间产生和处理缺页中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
<li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-进程与线程"><a href="#4-进程与线程" class="headerlink" title="4.进程与线程"></a>4.进程与线程</h2><h3 id="4-1单核CPU-x2F-多核CPU-x2F-多CPU"><a href="#4-1单核CPU-x2F-多核CPU-x2F-多CPU" class="headerlink" title="4.1单核CPU&#x2F;多核CPU&#x2F;多CPU"></a>4.1单核CPU&#x2F;多核CPU&#x2F;多CPU</h3><ul>
<li><p><strong>概述</strong></p>
<ul>
<li>单核CPU<ul>
<li><p>一个CPU中只有一个核心处理器</p>
</li>
<li><p>多核CPU</p>
<ul>
<li>一个CPU有多个核心处理器，处理器之间通过<strong>CPU内部总线</strong>进行通讯</li>
</ul>
</li>
</ul>
</li>
<li>多CPU<ul>
<li>简单的多个CPU工作在同一个系统上，多个CPU之间通过<strong>主板上的总线</strong>进行通讯</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>深入理解进程和线程</strong></p>
<ul>
<li>进程的调度和资源分配是操作系统负责</li>
<li>线程的调度和资源分配是CPU负责</li>
<li>进程是操作系统资源分配(包括cpu、内存、磁盘IO等)的基本单位，一个CPU同时刻只能执行一个进程<ul>
<li><strong>单核CPU实现多进程，并发：</strong>通过操作系统的进程调度算法，单核CPU进行进程调度的时候，需要读取上下文+执行程序+保存上下文，即进程切换</li>
<li><strong>多CPU实现多进程，并行：</strong>不同的进程运行在不同的CPU上</li>
</ul>
</li>
<li>线程是CPU调度和资源分配的基本单位，一个CPU核心同时刻只能执行一个线程<ul>
<li><strong>单核CPU实现多线程，并发：</strong>不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，这个线程切换比进程切换开销少很多</li>
<li><strong>多核CPU实现多线程，并行：</strong>CPU可以将不同线程分配到不同的CPU核心处理器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>单CPU中进程只能是并发，多CPU计算机中进程可以并行</li>
<li>单CPU单核中线程只能并发，单CPU多核中线程可以并行</li>
<li>并行有上限，进程与CPU个数，线程与CPU核心个数有关，并不是所有线程和所有进程都能同时运行</li>
</ul>
<h3 id="4-2进程与PCB"><a href="#4-2进程与PCB" class="headerlink" title="4.2进程与PCB"></a>4.2进程与PCB</h3><ul>
<li><strong>进程</strong><ul>
<li>进程是操作系统的资源分配单位，实现操作系统的并发，对于一个进程，它在被执行前其实是一个可执行程序。这个程序是被放在磁盘上的，当它要被执行的时候，它先被加载到内存当中，然后再放入到寄存器中，最后再让cpu执行该程序，这个时候一个静态的程序就变成了进程</li>
<li>进程创建时会分配4G的内存，其中0-3G是用户空间，3-4G是内核空间，PCB存在于内核空间</li>
<li>进程的用户空间是不同的，内核空间也是不同的。比如每个进程的不同系统调用，是陷入自己独立的内核空间里面，所以每个进程内核的堆栈肯定是不一样的</li>
</ul>
</li>
<li><strong>PCB</strong><ul>
<li>每个进程的PCB都是存在所有进程共享的内核空间中，操作系统管理进程，也就是在内核空间中管理的，在内核空间中通过链表管理所有进程的PCB，如果有一个进程要被创建，实际上多分配了这么一个4G的虚拟内存，并在共享的内核空间中的双向链表中加入了自己的PCB</li>
<li>PCB(Process Control Block)进程控制块，描述进程的基本信息和运行状态，<strong>进程的创建和销毁都是对PCB进行操作</strong>，PCB的具体内容如下：<ul>
<li><strong>标识相关：</strong>pid，ppid等等</li>
<li><strong>文件相关：</strong>进程需要记录打开的文件信息，于是需要文件描述符表</li>
<li><strong>内存相关：</strong>内存指针，指向进程的虚拟地址空间（用户空间）信息</li>
<li><strong>优先级相关：</strong>进程相对于其他进程的调度优先级</li>
<li><strong>上下文信息相关：</strong>CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行</li>
<li><strong>状态相关：</strong>进程当前的状态，说明该进程处于什么状态</li>
<li><strong>信号相关：</strong>进程的信号处理函数，以及记录当前进程是否还有待处理的信号</li>
<li><strong>I&#x2F;O相关：</strong>记录进程与各种I&#x2F;O设备之间的交互</li>
</ul>
</li>
<li>每个进程的内核空间中都有PCB，但真正的PCB是存储在物理内存上的，当进程创建和销毁时，会由操作系统操作PCB，每个进程只是虚拟地址空间，并不会存储实际数据，数据存储在物理内存中，只有一份</li>
</ul>
</li>
</ul>
<h3 id="4-3进程间通信"><a href="#4-3进程间通信" class="headerlink" title="4.3进程间通信"></a>4.3进程间通信</h3><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号、共享内存等）、本地套接字socket</p>
<ul>
<li><strong>管道(缓冲区有限)</strong><ul>
<li><strong>无名管道PIPE</strong><ul>
<li>一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程或兄弟进程）</li>
</ul>
</li>
<li><strong>有名管道FIFO</strong><ul>
<li>一种半双工的通信方式，可以在非亲缘关系的进程间使用</li>
</ul>
</li>
</ul>
</li>
<li><strong>消息队列</strong><ul>
<li>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识</li>
<li>消息队列克服了信号传递信息少，管道缓冲区大小受限的缺点</li>
<li>一个消息队列由一个标识符（即队列ID）来标记</li>
</ul>
</li>
<li><strong>信号</strong><ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。多个进程可以同时操作，所以需要进行同步 ，一般与信号量配合使用</li>
<li><strong>不同进程访问共享内存</strong><ul>
<li>shm<ul>
<li>不同进程通过shmget-&gt;shmat函数，将共享内存连接到自己的虚拟内存地址</li>
</ul>
</li>
<li>mmap<ul>
<li>不同进程通过mmap函数创建映射区，将自己的内存虚拟地址映射到磁盘的文件上</li>
</ul>
</li>
</ul>
</li>
<li><strong>shm</strong><ul>
<li><strong>原理</strong></li>
<li>多个进程的地址空间映射到同一个物理内存，不同进程可以将同一段共享的内存连接到自己的地址空间中，从而所有进程都可以访问共享内存中的地址</li>
<li><strong>API</strong><ul>
<li><code>int shmget(key_t key, size_t size, int shmflg);</code><ul>
<li>在物理内存创建一个共享内存，返回共享内存的编号</li>
<li>key是一个非0整数，命名共享内存段，运行成功返回一个与key相关的共享内存标识符</li>
<li>size表示以字节为单位指定需要的共享内存的容量</li>
<li>shmflag是权限标志位，与open的mode参数一致，若key标识的共享内存不存在，通过0666|IPC_CREAT来创建，并设置权限</li>
</ul>
</li>
<li><code>void *shmat(int shmid, const void shmaddr,int shmflg);</code><ul>
<li>连接成功后把共享内存区对象映射到调用进程的地址空间，函数返回各个进程挂接的虚拟的地址空间</li>
<li>shmid是挂接的进程号，</li>
<li>shmaddr置为NULL，让系统选择一个合适的地址空间进行挂接</li>
<li>shmflg表示什么方式进行挂接，一般都是取0</li>
</ul>
</li>
<li><code>void *shmdt(const void* shmaddr);</code><ul>
<li>将共享内存从当前进程中分离，断开用户级页表到共享内存的那根箭头</li>
</ul>
</li>
<li><code>int shmctl(int shmid, int cmd, struct shmid_ds* buf);</code><ul>
<li>释放物理内存中的那块共享内存</li>
<li>cmd取IPC_RMID表示删除这块共享内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>mmap</strong><ul>
<li><strong>原理</strong><ul>
<li>mmap是映射磁盘上的一个文件，每个进程在自己的逻辑地址空间中开辟一块空间对磁盘上的文件进行映射</li>
<li>内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存</li>
<li>mmap返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，建立内存映射并没有实际拷贝数据，这时，将产生一个缺页中断，会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中</li>
</ul>
</li>
<li><strong>效率</strong><ul>
<li>read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了两次数据拷贝</li>
<li>mmap()也是系统调用，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝</li>
</ul>
</li>
<li><strong>映射文件</strong><ul>
<li>普通文件<ul>
<li>open系统调用打开一个文件，然后进行mmap操作，得到共享内存，这种方式适用于任何进程之间</li>
</ul>
</li>
<li>匿名映射<ul>
<li>调用 mmap 时，在参数 flags 中指定 MAP_ANONYMOUS 标志位，并且将参数 fd 指定为 -1 ,用于父子进程之间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>程序异常退出，共享内存会释放么？</strong><ul>
<li>不会<ul>
<li>Linux中通过API函数shmget创建的共享内存一般都是在程序中使用shmctl来释放的，但是有时为了调试程序，开发人员可能通过Ctrl + C等方式发送中断信号来结束程序，此时程序申请的共享内存就不能得到释放，当然如果程序没有改动的话，重新运行程序时仍然会使用上次申请的共享内存，但是如果我们修改了程序，由于共享内存的大小不一致等原因会导致程序申请共享内存错误</li>
</ul>
</li>
<li>如何释放<ul>
<li>如果总是通过Crtl+C来结束的话，可以做一个信号处理器，当接收到这个信号的时候，先释放共享内存，然后退出程序</li>
<li>不管你以什么方式结束程序，如果共享内存还是得不到释放，那么可以通过linux命令ipcrm shm shmid来释放，在使用该命令之前可以通过ipcs -m命令来查看共享内存</li>
</ul>
</li>
</ul>
</li>
<li><strong>两者的区别</strong><ul>
<li><strong>作用</strong><ul>
<li>mmap系统调用并不完全是为了共享内存来设计的，它本身提供了不同于一般对普通文件的访问的方式，进程可以像读写内存一样对普通文件进行操作</li>
<li>IPC的共享内存shm是纯粹为了共享</li>
</ul>
</li>
<li><strong>映射位置</strong><ul>
<li>mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间对磁盘上的文件进行映射</li>
<li>shm每个进程映射到同一块物理内存，shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大</li>
</ul>
</li>
<li><strong>内容丢失</strong><ul>
<li>进程挂了重启不丢失内容，二者都可以做到</li>
<li>机器挂了重启，mmap把文件存在磁盘上，可以不丢失内容（文件内保存了OS同步过的映像），而 shmget 会丢失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>套接字</strong><ul>
<li>本地套接字用于本机不同进程间通信，另外普通套接字可以用于不同主机间的进程间通信</li>
</ul>
</li>
</ul>
<h3 id="4-4fork、vfork、clone"><a href="#4-4fork、vfork、clone" class="headerlink" title="4.4fork、vfork、clone"></a>4.4fork、vfork、clone</h3><p><strong>fork、v_fork、clone底层都是do_fork，追踪发现底层使用的是sys_clone</strong></p>
<ul>
<li><strong>fork</strong><ul>
<li>父进程fork之后创建子进程，子进程复制父进程的所有资源，子进程的代码段、数据段、堆栈都是指向父进程的物理空间，但此时仅仅是子进程的虚拟地址空间和父进程指向的物理地址空间建立了映射关系，并没有真正复制</li>
<li>由于fork()后会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，处于效率考虑，linux中引入了“写时复制技术-Copy-On-Write”</li>
<li>若两个进程一直只是读数据，则子进程一直不会复制，直到任一进程进行写操作</li>
<li>父进程和子进程执行顺序没有规定，可以乱序执行</li>
<li>读时共享，写时复制</li>
</ul>
</li>
<li><strong>vfork</strong><ul>
<li>vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。</li>
<li>规定必须子进程先执行</li>
<li>严格意义上讲，vfork产生的不叫进程，因为他没有独立的地址空间，和父进程共享同一个</li>
</ul>
</li>
</ul>
<h3 id="4-5僵尸进程和孤儿进程"><a href="#4-5僵尸进程和孤儿进程" class="headerlink" title="4.5僵尸进程和孤儿进程"></a>4.5僵尸进程和孤儿进程</h3><ul>
<li>当父进程先结束，子进程此时就会变成孤儿进程，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素</li>
<li>如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，回收进程资源，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程<ul>
<li><strong>僵尸进程是每个子进程退出时必然经历的过程</strong></li>
<li><strong>僵尸进程的危害</strong><ul>
<li>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait &#x2F; waitpid来取时才释放</li>
<li>如果进程不调用wait &#x2F; waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</li>
</ul>
</li>
<li><strong>如何消除僵尸进程</strong><ul>
<li>kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管</li>
<li>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-6进程退出方式及区别"><a href="#4-6进程退出方式及区别" class="headerlink" title="4.6进程退出方式及区别"></a>4.6进程退出方式及区别</h3><p>不管哪种退出方式，系统最终都会执行内核的同一代码，这段代码用来关闭进程打开的文件描述符，释放它占用的内存和其他资源</p>
<ul>
<li><strong>退出</strong><ul>
<li><strong>正常退出</strong><ul>
<li>main函数调用return</li>
<li>调用exit()函数</li>
<li>调用_exit()函数</li>
</ul>
</li>
<li>**异常退出 **<ul>
<li>调用abort函数</li>
<li>进程收到某个信号，该信号使程序终止</li>
</ul>
</li>
</ul>
</li>
<li><strong>已结束进程的状态</strong><ul>
<li>shell执行 echo $?，保存最近一次运行的进程的返回值<ul>
<li>程序中main函数运行结束，保存main函数的返回值</li>
<li>程序调用exit函数结束运行，保存exit函数的参数</li>
<li>程序异常退出，保存异常出错的错误号</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别</strong><ul>
<li><strong>exit和return的区别</strong><ul>
<li>exit是函数，有参数，exit执行完会把控制权交给系统，exit(0)表示正常终止，其他值表示有错误发生</li>
<li>return是函数执行完后的返回，return执行完后把控制权交给调用函数</li>
</ul>
</li>
<li><strong>exit和abort的区别</strong><ul>
<li>exit是正常终止进程</li>
<li>abort是异常终止进程</li>
</ul>
</li>
<li><strong>exit和_exit函数的区别</strong><ul>
<li>exit在头文件stdlib.h中声明，_exit是在头文件unistd.h中声明</li>
<li>exit是_exit之上的一个封装，exit先刷新流数据，再调用_exit函数<ul>
<li>_exit会关闭进程打开的文件描述符，清理内存，不会刷新流数据</li>
<li>linux的库函数，有一种“缓冲IO”的操作，对应每一个打开的文件，在内存中有一片缓冲区，每次读文件，会连续读出若干条记录，下次再读文件的时候，直接从内存的缓冲区中读；同样写文件也是先写入缓冲区，满足一定条件才将缓冲区的内容一次性写入文件。具体可以看printf和write的区别，及行缓冲和全缓冲</li>
<li>exit先刷新流数据，将文件缓冲区的内容写回文件，可以保证数据的完整性，_exit会将数据直接丢失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-7回收进程资源的方式和区别"><a href="#4-7回收进程资源的方式和区别" class="headerlink" title="4.7回收进程资源的方式和区别"></a>4.7回收进程资源的方式和区别</h3><ul>
<li><strong>init进程（进程号为1）会周期性的调用wait系统调用来清除各个僵尸进程</strong></li>
<li><strong>wait</strong><ul>
<li><code>pid_t wait (int *status)</code> status表示子进程的退出状态，成功返回值为子进程进程号，失败为-1</li>
<li>进程一旦调用wait函数，立即阻塞自己， 判断当前进程的某个子进程是否变成僵尸进程<ul>
<li>若存在则收集子进程的信息，将它彻底销毁然后返回</li>
<li>若没有，则会一直阻塞，直到出现一个</li>
</ul>
</li>
</ul>
</li>
<li><strong>waitpid</strong><ul>
<li>waitpid相当于wait函数的封装，多了两个由用户控制的参数pid和options，可以自定义回收的子进程进程号，并设置是否阻塞</li>
<li><code>pid_t waitpid(pid_t pid, int * status, int options)</code></li>
<li>pid<ul>
<li>pid &lt; -1，等待进程组ID为pid绝对值的任何子进程</li>
<li>pid &#x3D; -1，等待任何子进程，相当于wait</li>
<li>pid &#x3D; 0，等待进程组ID与目前进程相同的任何子进程</li>
<li>pid &gt; 0，等待子进程ID为pid的进程</li>
</ul>
</li>
<li>options<ul>
<li>0，与wait相同，也会阻塞</li>
<li>WNOHANG，不会阻塞，如果当前没有可回收的子进程，立即返回0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-8线程间同步及系统调用"><a href="#4-8线程间同步及系统调用" class="headerlink" title="4.8线程间同步及系统调用"></a>4.8线程间同步及系统调用</h3><ul>
<li><p><strong>信号量</strong><br>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<ul>
<li>P(SV)：如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程</li>
<li>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1</li>
<li><strong>系统调用</strong>：<ul>
<li>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值</li>
<li>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>互斥量</strong><br>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区 时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程</p>
<ul>
<li><strong>系统调用：</strong><ul>
<li>pthread_mutex_init:初始化互斥锁</li>
<li>pthread_mutex_destroy：销毁互斥锁</li>
<li>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁</li>
<li>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>条件变量</strong><br>条件变量，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个&#x2F;多个线程。即，当某个共享变量等于某个值时，调用 signal&#x2F;broadcast。此时操作共享变量时需要加锁</p>
<ul>
<li><strong>系统调用：</strong><ul>
<li>pthread_cond_init:初始化条件变量</li>
<li>pthread_cond_destroy：销毁条件变量</li>
<li>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级</li>
<li>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-9线程退出方式与线程回收"><a href="#4-9线程退出方式与线程回收" class="headerlink" title="4.9线程退出方式与线程回收"></a>4.9线程退出方式与线程回收</h3><ul>
<li><p>线程退出方式</p>
<p>注意：不能使用exit，exit表示退出整个进程</p>
<ul>
<li><p>pthread_exit</p>
<ul>
<li><p><code>int pthread_exit(void *retval);</code></p>
</li>
<li><p>在任何线程中使用，使该线程直接退出</p>
</li>
<li><p>主线程退出而不影响其他线程，只能使用这种方式</p>
</li>
</ul>
</li>
<li><p>return</p>
<ul>
<li>子线程中可以使用，主线程不能使用，主线程代表退出整个进程</li>
</ul>
</li>
</ul>
</li>
<li><p>线程回收</p>
<ul>
<li>pthread_join<ul>
<li><code>int pthread_join(pthread_t thread, void **retval)</code></li>
<li>用来等待一个线程的结束，并回收该线程的资源</li>
<li>一般是主线程调用，用来等待子线程退出，是阻塞的</li>
</ul>
</li>
</ul>
</li>
<li><p>线程分离</p>
<ul>
<li>pthread_detach<ul>
<li><code>int pthread_detach(pthread_t thread)</code></li>
<li>分离已经创建的线程，将主线程与子线程分离，子线程结束后，资源自动回收。</li>
<li>状态分离后，该线程的结束状态不能被该进程中的其他线程得到，因此pthread_join不能调用，否则会出错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-10说一下LINUX系统中的锁"><a href="#4-10说一下LINUX系统中的锁" class="headerlink" title="4.10说一下LINUX系统中的锁"></a>4.10说一下LINUX系统中的锁</h3><ul>
<li><strong>互斥锁：</strong>mutex，用于保证在任何时刻，都只能有一个线程访问该对象。<strong>当获取锁操作失败时，线程会进入睡眠</strong>，等待锁释放时被唤醒</li>
<li><strong>读写锁：rwlock，分为读锁和写锁</strong>。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它<strong>获取写锁失败的线程都会进入睡眠状态</strong>，直到写锁释放时被唤醒。 <ul>
<li><strong>注意：</strong>写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合</li>
</ul>
</li>
<li><strong>自旋锁：</strong>spinlock，在任何时刻同样只能有一个线程访问对象。但是<strong>当获取锁操作失败时，不会进入睡眠，而是会在原地自旋</strong>，循环检测锁的保持者是否释放，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源</li>
</ul>
<h3 id="4-11线程间共享和私有资源"><a href="#4-11线程间共享和私有资源" class="headerlink" title="4.11线程间共享和私有资源"></a>4.11线程间共享和私有资源</h3><ul>
<li><strong>私有：线程栈，寄存器，程序寄存器</strong>，线程ID，错误返回码，信号屏蔽字，调度优先级</li>
<li><strong>共享：</strong>文件描述符表，堆，地址空间，全局变量，静态变量，进程代码段，进程的当前目录和进程用户ID与进程组ID</li>
</ul>
<h3 id="4-12进程与线程的区别"><a href="#4-12进程与线程的区别" class="headerlink" title="4.12进程与线程的区别"></a>4.12进程与线程的区别</h3><ul>
<li><p><strong>概述</strong></p>
<ul>
<li>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位</li>
<li>进程有独立的系统资源或地址空间，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如线程Id,栈、寄存器、程序计数器PC(或者说IP)</li>
<li>一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也宕掉</li>
<li>进程在创建、销毁时开销比较大，而线程比较小。进程创建的时候需要分配虚拟地址空间等系统资源，而销毁的的时候需要释放系统资源；线程只需要创建栈，栈指针，程序计数器，通用目的寄存器和条件码等，不需要创建独立的虚拟地址空间</li>
<li>进程切换开销比较打，线程比较小。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB</li>
<li>进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>TLB</strong><br>TLB( Translation Look- aside buffer)专门用于缓存内存中的页表项,一般在MMU单元内部，页表一般存储在屋里内存中。当处理器要访问一个虚拟地址时,首先会在TLB中查询。如果TLB表项中没有相应的表项,称为TLB Miss,那么就需要访问页表来计算出相应的物理地址。如果TLB表项中有相应的表项,那么直接从TLB表项中获取物理地址,称为TLB命中</p>
</li>
<li><p><strong>程序计数器PC和指令指针寄存器IP</strong></p>
<ul>
<li><strong>程序计数器PC</strong><ul>
<li>用指令事先编好的程序连续存放在内存程序区中，靠地址+1的方法连续取指执行”。在八位机8080CPU中是采用先取指后执行的串行操作的原理，而其中执行地址+1指令寻址的部件就是程序计数器PC。那么在程序的执行过程中，PC始终是指向下一条要执行的指令</li>
<li><strong>结论：</strong>PC中的地址就是需要转移、循环、调用子程序和中断子程序等操作时的断点</li>
</ul>
</li>
<li><strong>指令指针寄存器IP</strong><ul>
<li>在向上兼容的十六位机8086CPU中首先分为两个功能部件，即总线接口部件BIU和执行部件EU，BIU负责取指令，EU负责译码执行。并且当BIU执行指令排队栈中的六个字节装满后，（8088CPU是4个字节），EU开始从指令排队栈的出栈口，取指令进行译码执行，同时BIU并行操作向入栈口补充一条取指令命令</li>
<li>指令指针IP则是指向下个条要取指的指令，而不是EU要执行的指令。而断点则应该是要执行的指令内存地址，而不是IP内的下一条要取指的指令地址</li>
</ul>
</li>
<li><strong>PC是模型机中的概念，IP是实际使用的，调试时我们发现，IP实现的就是PC的功能</strong></li>
</ul>
</li>
<li><p><strong>为什么有了进程还需要线程？</strong></p>
<ul>
<li><strong>优点</strong><ul>
<li>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>进程在同一时间只能干一件事</li>
<li>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行</li>
</ul>
</li>
<li><strong>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性</strong></li>
</ul>
</li>
</ul>
<h3 id="4-13Posix信号量与System-V信号量的区别"><a href="#4-13Posix信号量与System-V信号量的区别" class="headerlink" title="4.13Posix信号量与System V信号量的区别"></a>4.13Posix信号量与System V信号量的区别</h3><ul>
<li><p>POSIX信号量常用于线程；system v信号量常用于进程的同步</p>
</li>
<li><p>从使用的角度，System V 信号量的使用比较复杂，而 POSIX 信号量使用起来相对简单</p>
</li>
<li><p>对 POSIX 来说，信号量是个非负整数。而 System V 信号量则是一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为 System V IPC 服务的，信号量只不过是它的一部分</p>
</li>
<li><p>Posix信号量是基于内存的，即信号量值是放在共享内存中的，它是由可能与文件系统中的路径名对应的名字来标识的。而System v信号量则是基于内核的，它放在内核里面</p>
</li>
<li><p>POSIX 信号量的头文件是 &lt;semaphore.h&gt;，而 System V 信号量的头文件是 &lt;sys&#x2F;sem.h&gt;</p>
</li>
<li><p>Posix还有有名信号量，一般用于进程同步, 有名信号量是内核持续的</p>
</li>
</ul>
<h2 id="5-调度算法"><a href="#5-调度算法" class="headerlink" title="5.调度算法"></a>5.调度算法</h2><h3 id="5-1进程调度算法"><a href="#5-1进程调度算法" class="headerlink" title="5.1进程调度算法"></a>5.1进程调度算法</h3><ul>
<li><p><strong>批处理系统</strong><br>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p>
<ul>
<li><strong>先来先服务 first-come first-serverd（FCFS）</strong><ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
</li>
<li><strong>短作业优先 shortest job first（SJF）</strong><ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
</li>
<li><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><ul>
<li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度</li>
<li>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应</p>
<ul>
<li><strong>时间片轮转</strong><ul>
<li>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片</li>
<li>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</li>
</ul>
</li>
<li><strong>优先级调度</strong><ul>
<li>为每个进程分配一个优先级，按优先级进行调度</li>
<li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</li>
</ul>
</li>
<li><strong>多级反馈队列</strong><ul>
<li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次</li>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次</li>
<li>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程</li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实时系统</strong></p>
<ul>
<li>实时系统要求一个请求在一个确定时间内得到响应</li>
<li>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时</li>
</ul>
</li>
<li><p><strong>进程调度时机</strong></p>
<ul>
<li>进程状态转换的时刻：进程终止、进程睡眠</li>
<li>当前进程的时间片用完时（current-&gt;counter&#x3D;0）</li>
<li>设备驱动程序</li>
<li>进程从中断、异常及系统调用返回到用户态时</li>
</ul>
</li>
</ul>
<h3 id="5-2虚拟内存置换算法"><a href="#5-2虚拟内存置换算法" class="headerlink" title="5.2虚拟内存置换算法"></a>5.2虚拟内存置换算法</h3><ul>
<li>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换</li>
<li>当前操作系统最常采用的缺页置换算法如下：<ul>
<li><strong>先进先出(FIFO)算法：</strong>置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除</li>
<li><strong>最近最少使用（LRU）算法：</strong>置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问</li>
<li>当前最常采用的就是LRU算法</li>
</ul>
</li>
</ul>
<h2 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6.文件系统"></a>6.文件系统</h2><h2 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7.设备管理"></a>7.设备管理</h2><h2 id="8-网络系统"><a href="#8-网络系统" class="headerlink" title="8.网络系统"></a>8.网络系统</h2><h1 id="二、Linux网络编程"><a href="#二、Linux网络编程" class="headerlink" title="二、Linux网络编程"></a>二、Linux网络编程</h1><h2 id="1-网络编程步骤"><a href="#1-网络编程步骤" class="headerlink" title="1.网络编程步骤"></a>1.网络编程步骤</h2><ul>
<li><strong>TCP</strong><ul>
<li><strong>服务端：</strong>socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv&#x2F;send-&gt;close<ul>
<li>创建一个socket，用函数socket()，设置SOCK_STREAM</li>
<li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构</li>
<li>bind()函数绑定服务器IP地址、端口等信息到socket上</li>
<li>listen()函数设置允许的最大连接数</li>
<li>accept()函数接收客户端上来的连接</li>
<li>send()&#x2F;recv()或read()&#x2F;write()函数收发数据</li>
<li>close()关闭网络连接，需要关闭服务器sock和accpet产生的客户端sock描述符</li>
</ul>
</li>
<li><strong>客户端：socket-&gt;connect-&gt;send&#x2F;recv-&gt;close</strong><ul>
<li>创建一个socket，用函数socket()</li>
<li>设置要连接的对方的IP地址和端口等属性</li>
<li>连接服务器，用函数connect()</li>
<li>收发数据，用函数send()和recv()，或read()和write()</li>
<li>关闭网络连接close()</li>
</ul>
</li>
<li><strong>注意：</strong><ul>
<li>INADDR_ANY表示本机任意地址，一般服务器端都可以这样写</li>
<li>accept中接收的是客户端的地址，返回对应当前客户端的一个clisock文件描述符，表示当前客户端的tcp连接</li>
<li>send和recv中接收的是新建立的客户端的sock地址</li>
</ul>
</li>
</ul>
</li>
<li><strong>UDP</strong><ul>
<li><strong>服务端：</strong>socket -&gt; bind -&gt; recvfrom&#x2F;sendto -&gt; close<ul>
<li>建立套接字文件描述符，使用函数socket()，设置SOCK_DGRAM</li>
<li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构</li>
<li>绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定</li>
<li>接收客户端的数据，使用recvfrom()函数接收客户端的网络数据</li>
<li>向客户端发送数据，使用sendto()函数向服务器主机发送数据</li>
<li>关闭套接字，使用close()函数释放资源</li>
</ul>
</li>
<li><strong>客户端：</strong>socket -&gt; sendto&#x2F;recvfrom -&gt; close<ul>
<li>建立套接字文件描述符，socket()</li>
<li>设置服务器地址和端口，struct sockaddr</li>
<li>向服务器发送数据，sendto()</li>
<li>接收服务器的数据，recvfrom()</li>
<li>关闭套接字，close()</li>
</ul>
</li>
<li><strong>注意：</strong><ul>
<li>sendto和recvfrom的第56个参数是sock地址<ul>
<li>服务器端的recvfrom和sendto都是cli地址</li>
<li>客户端sendto是服务器端的地址，最后一个参数是指针，recvfrom是新建的from地址，最后一个参数是整型</li>
</ul>
</li>
<li>UDP不用listen，accept，因为UDP无连接</li>
<li>UDP通过sendto函数完成套接字的地址分配工作<ul>
<li>第一阶段：向UDP套接字注册IP和端口号</li>
<li>第二阶段：传输数据</li>
<li>第三阶段：删除UDP套接字中注册的目标地址信息</li>
</ul>
</li>
<li>每次调用sendto函数都重复上述过程，每次都变更地址，因此可以重复利用同一UDP套接字向不同的目标传输数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-TCP中的accept和connect和listen的关系"><a href="#2-TCP中的accept和connect和listen的关系" class="headerlink" title="2.TCP中的accept和connect和listen的关系"></a>2.TCP中的accept和connect和listen的关系</h2><ul>
<li><strong>listen</strong><ul>
<li><strong>listen功能</strong><ul>
<li>listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求</li>
<li>参数 backlog 的作用是设置内核中连接队列的长度</li>
<li>根据TCP状态转换图，调用listen导致套接字从CLOSED状态转换成LISTEN状态</li>
</ul>
</li>
<li><strong>是否阻塞</strong><ul>
<li>listen()函数不会阻塞，它将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束</li>
</ul>
</li>
<li><strong>backlog的作用</strong><ul>
<li>backlog是队列的长度，内核为任何一个给定的监听套接口维护两个队列：<ul>
<li>未完成连接队列（incomplete connection queue），每个这样的 SYN 分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些套接口处于 SYN_RCVD 状态</li>
<li>已完成连接队列（completed connection queue），每个已完成 TCP 三次握手过程的客户对应其中一项。这些套接口处于 ESTABLISHED 状态</li>
</ul>
</li>
<li>当有一个客户端主动连接（connect()），Linux 内核就自动完成TCP 三次握手，该项就从未完成连接队列移到已完成连接队列的队尾，将建立好的链接自动存储到队列中，如此重复</li>
<li>backlog 参数历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5</li>
</ul>
</li>
</ul>
</li>
<li><strong>connect</strong><ul>
<li><strong>connect功能</strong><ul>
<li>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。</li>
<li>connect之后是三次握手</li>
</ul>
</li>
<li><strong>是否阻塞</strong><ul>
<li>通常的情况，客户端的connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）</li>
</ul>
</li>
</ul>
</li>
<li><strong>accept</strong><ul>
<li><strong>accept功能</strong><ul>
<li>accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接(<strong>三次握手之后</strong>)</li>
</ul>
</li>
<li><strong>是否阻塞</strong><ul>
<li>如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止</li>
<li>如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-UDP中的connect"><a href="#3-UDP中的connect" class="headerlink" title="3.UDP中的connect"></a>3.UDP中的connect</h2><p><strong>UDP的connect和TCP的connect完全不同，UDP不会引起三次握手</strong></p>
<ul>
<li><strong>未连接的UDP传输数据</strong><ul>
<li>第一阶段：向UDP套接字注册IP和端口号</li>
<li>第二阶段：传输数据</li>
<li>第三阶段：删除UDP套接字中注册的目标地址信息</li>
</ul>
</li>
<li><strong>已连接的UDP传输数据</strong><ul>
<li>第一阶段：向UDP套接字注册IP和端口号</li>
<li>第二阶段：传输数据</li>
<li>第三阶段：传输数据</li>
</ul>
</li>
<li>可以提高传输效率</li>
<li>采用connect的UDP发送接受报文可以调用send,write和recv,read操作，也可以调用sendto,recvfrom，此时需要将第五和第六个参数置为NULL或0</li>
<li>由已连接的UDP套接口引发的异步错误，返回给他们所在的进程。相反我们说过，未连接UDP套接口不接收任何异步错误给一个UDP套接口，connect后的udp套接口write可以检测发送数据成功与否，直接sendto无法检测</li>
<li>多次调用connect拥有一个已连接UDP套接口的进程的作用<ul>
<li>指定新的IP地址和端口号</li>
<li>断开套接口</li>
</ul>
</li>
</ul>
<h2 id="4-服务端大量TIMEWAIT或CLOSEWAIT状态"><a href="#4-服务端大量TIMEWAIT或CLOSEWAIT状态" class="headerlink" title="4.服务端大量TIMEWAIT或CLOSEWAIT状态"></a>4.服务端大量TIMEWAIT或CLOSEWAIT状态</h2><p>首先通过TCP的四次挥手过程分析确定两个状态的出现背景。TIMEWAIT是大量tcp短连接导致的，确保对方收到最后发出的ACK，一般为2MSL；CLOSEWAIT是tcp连接不关闭导致的，出现在close()函数之前</p>
<ul>
<li><strong>TIMEWAIT</strong><ul>
<li>可以通过设置SOCKET选项SO_REUSEADDR来重用处于TIMEWAIT的sock地址，对应于内核中的tcp_tw_reuse，这个参数不是“消除” TIME_WAIT的，而是说当资源不够时，可以重用TIME_WAIT的连接</li>
<li>修改ipv4.ip_local_port_range，增大可用端口范围，来承受更多TIME</li>
<li>设置SOCK选项SO_LINGER选项，这样会直接消除TIMEWAIT</li>
</ul>
</li>
<li><strong>CLOSEWAIT</strong><ul>
<li>客户端主动关闭，而服务端没有close关闭连接，则服务端产生大量CLOSEWAIT，一般都是业务代码有问题</li>
</ul>
</li>
</ul>
<h2 id="5-优雅关闭和半关闭"><a href="#5-优雅关闭和半关闭" class="headerlink" title="5.优雅关闭和半关闭"></a>5.优雅关闭和半关闭</h2><ul>
<li><strong>概念</strong><ul>
<li>一个文件描述符关联一个文件，这里是网络套接字</li>
<li>close会关闭用户应用程序中的socket句柄，释放相关资源，从而触发关闭TCP连接</li>
<li>关闭TCP连接，是关闭网络套接字，断开连接</li>
<li>close只是减少引用计数，只有当引用计数为0的时候，才发送fin，真正关闭连接</li>
<li>shutdown不同，只要以SHUT_WR&#x2F;SHUT_RDWR方式调用即发送FIN包</li>
<li>shutdown后要调用close</li>
<li>保持连接的某一端想关闭连接了，<strong>但它需要确保要发送的数据全部发送完毕以后才断开连接</strong>，此种情况下需要使用优雅关闭，一种是shutdown，一种是设置SO_LINGER的close</li>
<li>半关闭，是关闭写端，但可以读对方的数据，这种只能通过shutdown实现</li>
</ul>
</li>
<li><strong>close函数会关闭文件描述符，不会立马关闭网络套接字，除非引用计数为0，则会触发调用关闭TCP连接</strong><ul>
<li>检查接收缓冲区是否有数据未读(不包括FIN包)，如果有数据未读，协议栈会发送RST包，而不是FIN包。如果套接字设置了SO_LINGER选项，并且lingertime设置为0，这种情况下也会发送RST包来终止连接。其他情况下，会检查套接字的状态，只有在套接字的状态是TCP_ESTABLISHED、TCP_SYN_RECV和TCP_CLOSE_WAIT的状态下，才会发送FIN包</li>
<li>若有多个进程调用同一个网络套接字，会将网络套接字的文件描述符+1，close调用只是将当前套接字的文件描述符-1，只会对当前的进程有效，只会关闭当前进程的文件描述符，其他进程同样可以访问该套接字</li>
<li>close函数的默认行为是，关闭一个socket，close将立即返回，TCP模块尝试把该socket对应的TCP缓冲区中的残留数据发送给对方，并不保证能到达对方</li>
<li>close行为可以通过SO_LINGER修改</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">struct linger&#123;<br>    int l_onoff;    //开启或关闭该选项<br>    int l_linger;   //滞留时间<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">* l_onoff为0，该选项不起作用，采用默认close行为 
* l_onoff不为0，l_linger为0，close立即返回，TCP模块丢弃被关闭的socket对应的TCP缓冲区中的数据，给对方发送RST复位信号，这样可以异常终止连接，且完全消除了TIME_WAIT状态 
* l_linger不为0，阻塞socket，被关闭的socket对应TCP缓冲区，若还有数据，close会阻塞，进程睡眠，直到收到对方的确认或等待l_linger时间，若超时仍未收到确认，则close返回-1设置errno为EWOULDBLOCK
* l_linger不为0，非阻塞socket，close立即返回，需要根据返回值和errno判断残留数据是够发送完毕
</code></pre>
<ul>
<li><strong>shutdown没有采用引用计数的机制，会影响所有进程的网络套接字，可以只关闭套接字的读端或写端，也可全部关闭，用于实现半关闭，会直接发送FIN包</strong><ul>
<li>SHUT_RD，关闭sockfd上的读端，不能再对sockfd文件描述符进行读操作，且接收缓冲区中的所有数据都会丢弃</li>
<li>SHUT_WR，关闭写端，确保发送缓冲区中的数据会在真正关闭连接之前会发送出去，不能对其进行写操作，连接处于半关闭状态</li>
<li>SHUT_RDWR，同时关闭sockfd的读写</li>
</ul>
</li>
</ul>
<h2 id="6-send和recv的阻塞和非阻塞情况"><a href="#6-send和recv的阻塞和非阻塞情况" class="headerlink" title="6.send和recv的阻塞和非阻塞情况"></a>6.send和recv的阻塞和非阻塞情况</h2><ul>
<li><p><strong>send</strong><br>send函数返回100，并不是将100个字节的数据发送到网络上或对端，而是发送到了协议栈的写缓冲区，至于什么时候发送，由协议栈决定</p>
<ul>
<li><strong>阻塞</strong><ul>
<li>一直等待，直到写缓冲区有空闲<ul>
<li>成功写返回发送数据长度</li>
<li>失败返回-1</li>
</ul>
</li>
</ul>
</li>
<li><strong>非阻塞</strong><ul>
<li>不等待，立即返回，成功返回数据长度</li>
<li>返回-1，判断错误码<ul>
<li>若错误码为EAGAIN或EWOULDBLOCK则表示写缓冲区不空闲</li>
<li>若错误码为ERROR，则表示失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>recv</strong></p>
<ul>
<li><strong>阻塞</strong><ul>
<li>一直等待，直到读缓冲区有数据<ul>
<li>成功写返回数据长度</li>
<li>失败返回-1</li>
</ul>
</li>
</ul>
</li>
<li><strong>非阻塞</strong><ul>
<li>不等待，立即返回，成功返回数据长度</li>
<li>返回-1，判断错误码<ul>
<li>若错误码为EAGAIN或EWOULDBLOCK则表示读缓冲区没数据</li>
<li>若错误码为ERROR，则表示失败</li>
</ul>
</li>
<li>返回0<ul>
<li>对端关闭连接</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-网络字节序和主机序"><a href="#7-网络字节序和主机序" class="headerlink" title="7.网络字节序和主机序"></a>7.网络字节序和主机序</h2><p>字节序分为大端字节序和小端字节序，大端字节序也称网络字节序，小端字节序也称为主机字节序</p>
<ul>
<li><strong>大端字节序</strong><ul>
<li>一个整数的高位字节存储在低位地址，低位字节存储在高位地址</li>
</ul>
</li>
<li><strong>小端字节序</strong><ul>
<li>高位字节存储在高位地址，低位字节存储在低位地址</li>
</ul>
</li>
<li><strong>转换API</strong><ul>
<li>htonl 主机序转网络序，长整型，用于转换IP地址</li>
<li>htons 主机序转网络序，短整型，用于转换端口号</li>
<li>ntohl 网络序转主机序</li>
<li>ntohs 网络序转主机序</li>
</ul>
</li>
</ul>
<h2 id="8-为什么忽略SIGPIPE信号"><a href="#8-为什么忽略SIGPIPE信号" class="headerlink" title="8.为什么忽略SIGPIPE信号"></a>8.为什么忽略SIGPIPE信号</h2><ul>
<li>假设server和client 已经建立了连接，server调用了close, 发送FIN 段给client（其实不一定会发送FIN段，后面再说），此时server不能再通过socket发送和接收数据，此时client调用read，如果接收到FIN 段会返回0</li>
<li>但client此时还是可以write 给server的，write调用只负责把数据交给TCP发送缓冲区就可以成功返回了，所以不会出错，而server收到数据后应答一个RST段，表示服务器已经不能接收数据，连接重置，client收到RST段后无法立刻通知应用层，只把这个状态保存在TCP协议层</li>
<li>如果client再次调用write发数据给server，由于TCP协议层已经处于RST状态了，因此不会将数据发出，而是发一个SIGPIPE信号给应用层，SIGPIPE信号的缺省处理动作是终止程序</li>
<li>有时候代码中需要连续多次调用write，可能还来不及调用read得知对方已关闭了连接就被SIGPIPE信号终止掉了，这就需要在初始化时调用sigaction处理SIGPIPE信号，对于这个信号的处理我们通常忽略即可</li>
<li>往一个读端关闭的管道或者读端关闭的socket连接中写入数据，会引发SIGPIPE信号。当系统受到该信号会结束进程是，但我们不希望因为错误的写操作导致程序退出</li>
<li>通过sigaction函数设置信号，将handler设置为SIG_IGN将其忽略</li>
<li>通过send函数的MSG_NOSIGNAL来禁止写操作触发SIGPIPE信号</li>
</ul>
<h1 id="三、Linux工具与命令"><a href="#三、Linux工具与命令" class="headerlink" title="三、Linux工具与命令"></a>三、Linux工具与命令</h1><h2 id="1-Linux基本目录结构"><a href="#1-Linux基本目录结构" class="headerlink" title="1.Linux基本目录结构"></a>1.Linux基本目录结构</h2><ul>
<li>&#x2F;bin，binaries存放二进制可执行文件</li>
<li>&#x2F;usr，unix shared resources用于存放共享的系统资源</li>
<li>&#x2F;sbin，super user binaries存放二进制可执行文件，只有root才能访问</li>
<li>&#x2F;etc，etcetera存放系统的配置文件</li>
<li>&#x2F;boot，存放启动linux和引导文件的目录</li>
<li>&#x2F;lib，存放着系统最基本的动态连接共享库</li>
<li>&#x2F;dev，存放linux的设备文件，比如显示器，键盘等</li>
<li>&#x2F;mnt，用户可以在这个目录下挂在其他临时文件系统</li>
<li>&#x2F;media，linux系统会自动识别一些设备，例如U盘、光驱等等，linux会把识别的设备挂载到这个目录下</li>
<li>&#x2F;opt，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</li>
<li><strong>&#x2F;proc，proc被称为虚拟文件系统，它是一个控制中心，可以通过更改其中某些文件改变内核运行状态，它也是内核提空给我们的查询中心，用户可以通过它查看系统硬件及当前运行的进程信息</strong><ul>
<li>&#x2F;proc&#x2F;loadavg，前三列分别保存最近1分钟，5分钟，及15分钟的平均负载</li>
<li>&#x2F;proc&#x2F;meminfo，当前内存使用信息</li>
<li>&#x2F;proc&#x2F;cpuinfo ， CPU的详细信息</li>
<li>&#x2F;proc&#x2F;diskstats， 磁盘I&#x2F;O统计信息列表</li>
<li>&#x2F;proc&#x2F;net&#x2F;dev ， 网络流入流出统计信息</li>
<li>&#x2F;proc&#x2F;filesystems， 支持的文件系统</li>
<li>&#x2F;proc&#x2F;cmdline ， 启动时传递至内核的启动参数，通常由grub进行传递</li>
<li>&#x2F;proc&#x2F;mounts ， 系统当前挂在的文件系统</li>
<li>&#x2F;proc&#x2F;uptime ， 系统运行时间</li>
<li>&#x2F;poc&#x2F;version ， 当前运行的内核版本号等信息</li>
</ul>
</li>
</ul>
<h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h2><ul>
<li><p><strong>文件查找：find</strong></p>
<ul>
<li><p>按名查找： </p>
<ul>
<li>查找具体文件（一般方式）</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">find</span> . -name <span class="hljs-regexp">*.cpp</span><br></code></pre></td></tr></table></figure>

<ul>
<li>查找具体文件（正则方式）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># -regex为正则查找，-iregex为忽略大小写的正则查找 </span><br>find <span class="hljs-operator">-regex</span> <span class="hljs-string">&quot;.*.cpp<span class="hljs-variable">$</span>&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>定制查找：</p>
<ul>
<li>按类型查找</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">f</span>(file)为文件，<span class="hljs-built_in">d</span>(dictionary)为目录，<span class="hljs-built_in">l</span>(link)为链接<br>find . -type f<br></code></pre></td></tr></table></figure>

<ul>
<li>按时间查找</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta"># atime为访问时间，x天内加参数<span class="hljs-string">&quot;-atime -x&quot;</span>，超过x天加<span class="hljs-string">&quot;-atime -x&quot;</span></span><br><span class="hljs-meta"># mtime为修改时间</span><br><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">type</span> f -atime -<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<ul>
<li>按大小查找</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"># -size后接文件大小，单位可以为<span class="hljs-built_in">k</span>(kb)，<span class="hljs-built_in">m</span>(MB)，<span class="hljs-built_in">g</span>(GB)<br>find . -type f -size -<span class="hljs-number">1</span>k<br></code></pre></td></tr></table></figure>

<ul>
<li>按权限查询</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># -perm后接权限</span><br><span class="hljs-title">find</span> . -<span class="hljs-class"><span class="hljs-keyword">type</span> -perm 644</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>文本搜索：grep</strong></p>
<ul>
<li><p>模式匹配</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 匹配<span class="hljs-keyword">test</span>.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>串的内容<br>grep <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure>
</li>
<li><p>多个模式匹配</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 匹配<span class="hljs-keyword">test</span>.cpp文件中含有<span class="hljs-string">&quot;iostream&quot;</span>和<span class="hljs-string">&quot;using&quot;</span>串的内容<br>grep -<span class="hljs-keyword">e</span> <span class="hljs-string">&quot;using&quot;</span> -<span class="hljs-keyword">e</span> <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure>
</li>
<li><p>输出信息</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br>grep -n <span class="hljs-string">&quot;iostream&quot;</span> <span class="hljs-keyword">test</span>.cpp  <br></code></pre></td></tr></table></figure>
</li>
<li><p>统计文件中某个单词出现的次数</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># -o选项会把每个匹配到的关键字都单独显示在一行中进行输出</span><br>grep -o word filename <span class="hljs-string">| wc -l</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>对日志文件的IP出现的次数进行统计 并显示次数最多的前六名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -i -o -E <span class="hljs-string">&quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot;</span> test1.txt | <span class="hljs-built_in">sort</span> -n | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -n -r | <span class="hljs-built_in">head</span> -6<br></code></pre></td></tr></table></figure>

<p><strong>grep命令 用于文本搜索：</strong></p>
<ul>
<li><p>-E：用于使用正则匹配</p>
</li>
<li><p>-o：只显示匹配的部分</p>
</li>
<li><p>-i：忽略大小写</p>
</li>
</ul>
<p><strong>sort命令用于排序：</strong></p>
<ul>
<li><p>-n：数值排序</p>
</li>
<li><p>-r：倒序排序</p>
</li>
</ul>
<p><strong>uniq命令用于去重：</strong></p>
<ul>
<li>-c：显示重复次数</li>
</ul>
<p><strong>head -6命令显示前6行</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39646725/article/details/116579913">详解</a></p>
</li>
</ul>
</li>
<li><p><strong>排序：sort</strong></p>
<ul>
<li>文件内容行排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 排序在内存进行，不改变文件</span><br><span class="hljs-comment"># -n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="hljs-comment"># -k N表示按各行第N列进行排序</span><br><span class="hljs-comment"># -r(reverse)为逆序排序</span><br><br><span class="hljs-built_in">sort</span> -n -k 1 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>转换：tr</strong></p>
<ul>
<li><p>字符替换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># 将打开文件中所有目标字符替换</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># -d删除(delete)</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换在内存进行，不改变文件</span><br><span class="hljs-comment"># -s位于后部</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27; &#x27;</span> -s<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>按列切分文本：cut</strong></p>
<ul>
<li><p>截取特定列</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 截取的内存进行，不改变文件</span><br><span class="hljs-comment"># -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="hljs-comment"># 数字为具体列范围</span><br><span class="hljs-attribute">cut</span> -f <span class="hljs-number">1</span>,<span class="hljs-number">2</span> test<br></code></pre></td></tr></table></figure>
</li>
<li><p>指定界定符</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 截取的内存进行，不改变文件</span><br><span class="hljs-meta"># -d后接界定符</span><br>cut -f <span class="hljs-number">2</span> -d <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>按列拼接文本：paste</strong></p>
<ul>
<li><p>按列拼接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内存中拼接，不改变文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将两个文件按对应列拼接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加上-d <span class="hljs-string">&quot;x&quot;</span>会将x作为指定分隔符（<span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span>）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两文件列数可以不同</span> <br>paste test1 test2<br></code></pre></td></tr></table></figure>
</li>
<li><p>指定界定符拼接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在内存中拼接，不改变文件</span><br><span class="hljs-comment"># 按照-d之后给出的界定符拼接</span><br><span class="hljs-built_in">paste</span> test1 test2 -d <span class="hljs-string">&quot;,&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><strong>统计行和字符：wc</strong><ul>
<li><p>基本统计 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><span class="hljs-built_in">wc</span> -l <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>ls</strong></p>
<ul>
<li><code>ls -lrt</code> 递归显示文件的详细信息并按照时间排序</li>
</ul>
</li>
<li><p><strong>tail</strong></p>
<ul>
<li><p><code>tail -n 100</code> 显示文件尾，指定显示行数，默认10行</p>
</li>
<li><p>查看文件尾部</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="hljs-comment"># 查看日志时常用</span><br><span class="hljs-built_in">tail</span> -f <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>chmod</strong></p>
<ul>
<li><p><code>chmod 777 filename</code> 修改文件的权限为用户，用户组，其他人有所有权限</p>
</li>
<li><p>更改文件权限</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="hljs-comment"># 文件可以有三种权限，r(read)，w(write)，x(execute)</span><br><span class="hljs-comment"># 这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="hljs-comment"># 这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br>chmod u+r <span class="hljs-built_in">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>rm</strong></p>
<ul>
<li><code>rm -r</code> 递归删除子目录</li>
<li><code>rm -f</code> 强制删除</li>
</ul>
</li>
<li><p><strong>vim的三种模式</strong></p>
<ul>
<li>命令模式(一般模式，通过yy进行赋值)</li>
<li>编辑模式，通过i或者a</li>
<li>末行模式，冒号</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/5426.html">详见</a></p>
</li>
<li><p><strong>创建链接：ln</strong></p>
<ul>
<li><p>创建硬链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><span class="hljs-built_in">ln</span> file1 file2<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建软（符号链接）链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -s(symbol)为符号链接，仅仅是引用路径</span><br><span class="hljs-comment"># 相比于硬链接最大特点是可以跨文件系统</span><br><span class="hljs-comment"># 类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><span class="hljs-built_in">ln</span> -s file1 file2<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-磁盘及内存命令"><a href="#3-磁盘及内存命令" class="headerlink" title="3.磁盘及内存命令"></a>3.磁盘及内存命令</h2><ul>
<li>文件大小和占用空间大小是不一样的，因为要对齐</li>
<li>显示每个文件和目录的磁盘使用空间<ul>
<li><strong>(disk used) du -h</strong></li>
</ul>
</li>
<li>显示磁盘分区上可以使用的磁盘空间<ul>
<li><strong>(disk free) df -h</strong></li>
</ul>
</li>
<li><strong>显示内存使用情况：free</strong><ul>
<li>可获得内存及交换区的总量，已使用量，空闲量等信息</li>
<li>Mem是物理内存的使用情况</li>
<li>Swap是交换空间的使用情况</li>
<li>total是物理内存和交换空间的总大小</li>
<li>used是物理内存和交换空间已经被使用的大小</li>
<li>free是物理内存和交换空间可用空间（从内核和系统的角度看，真正尚未被使用的物理内存数量）</li>
<li>shared 列显示被共享使用的物理内存大小</li>
<li>buff&#x2F;cache 列显示被 buffer 和 cache 使用的物理内存大小（其实是内存为缓存磁盘数据设置的缓冲区）</li>
<li>available 列显示还可以被应用程序使用的物理内存大小，当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求，理想来说available &#x3D; free + buffer + cache</li>
</ul>
</li>
</ul>
<h2 id="4-监控性能指标：sar"><a href="#4-监控性能指标：sar" class="headerlink" title="4.监控性能指标：sar"></a>4.监控性能指标：sar</h2><p>监控CPU </p>
<ul>
<li>监控CPU负载</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="hljs-comment"># 这里&quot;1&quot;表示采样时间间隔是1秒，这里&quot;2&quot;表示采样次数为2</span><br><span class="hljs-attribute">sar</span> -q <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>监控CPU使用率</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 可以显示CPU使用情况</span><br><span class="hljs-comment"># 参数意义同上</span><br><span class="hljs-attribute">sar</span> -u <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>监控内存</p>
<ul>
<li>查询内存</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 可以显示内存使用情况</span><br><span class="hljs-comment"># 参数意义同上 </span><br><span class="hljs-attribute">sar</span> -r <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>页面交换查询</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-comment"># 可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br> <span class="hljs-comment"># 参数意义同上</span><br><span class="hljs-attribute">sar</span> -W <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="5-进程命令"><a href="#5-进程命令" class="headerlink" title="5.进程命令"></a>5.进程命令</h2><ul>
<li><p><strong>ps</strong></p>
<ul>
<li>当前运行的进程的快照，指定ps命令的那个时刻的那些进程</li>
<li><code>ps -aux</code> 查看所有的在内存中的进程信息</li>
<li><code>ps -ajx</code> 查看进程组相关信息，可以追踪进程之间的血缘关系</li>
<li><code>ps -ef</code> 线城市所有进程信息，并显示程序间的关系</li>
<li><code>ps -u username</code> 显示指定用户username信息</li>
</ul>
</li>
<li><p><strong>top</strong></p>
<ul>
<li>实时显示系统中各个进程的资源占用情况，按”q”退出top命令</li>
<li><code>top -H -p pid</code>显示对应pid的所有线程资源使用情况</li>
<li><code>load average</code> 表示系统最近1min,5min,15min的平均负载，越大表示负载越来越小</li>
<li>%MEM物理内存占用比</li>
<li>Cpu(s)和%CPU<ul>
<li>Cpu(s)表示的是所有用户进程占用整个cpu的平均值</li>
<li>%CPU显示的是进程占用一个核的百分比，而不是整个cpu（8核）的百分比，有时候可能大于100，那是因为该进程启用了多线程占用了多个核心，所以有时候我们看该值得时候会超过100%，但不会超过总核数*100</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>kill</strong></p>
<ul>
<li><p>杀掉进程</p>
</li>
<li><p><code>kill -9 pid</code>杀掉指定进程</p>
</li>
<li><p>杀死具体进程</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加具体进程PID</span><br><span class="hljs-attribute">kill</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>杀死某进程相关进程</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 加上&quot;-9&quot;杀死某进程相关进程</span><br><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>lsof</strong></p>
<ul>
<li>列出当前系统打开文件的工具</li>
<li><code>lsof -i :8600</code> 查看8600端口的运行情况</li>
<li><code>lsof -u username</code> 查看username打开的文件</li>
<li><code>lsof -c string</code> 查看包含指定字符的进程所打开的文件</li>
</ul>
<ul>
<li><p>查看某用户打开的文件 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># -u(user)为用户，后接用户名</span><br><span class="hljs-attribute">lsof</span> -u inx<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看指定进程打开的文件 </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># -p(process)为进程，后接进程PID</span><br><span class="hljs-attribute">lsof</span> -p <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>查看指定目录下被进程打开的文件 </p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 这里是<span class="hljs-string">&quot;+d&quot;</span>，需要注意，使用<span class="hljs-string">&quot;+D&quot;</span>递归目录</span><br>lsof +d /test<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="6-网络命令"><a href="#6-网络命令" class="headerlink" title="6.网络命令"></a>6.网络命令</h2><ul>
<li><p><strong>netstat</strong></p>
<ul>
<li><p>用于显示与IP、TCP、UDP、和ICMP协议相关的统计数据，用于检验本机各端口的网络连接情况</p>
</li>
<li><p><code>-a</code> 列出所有端口</p>
</li>
<li><p><code>-p</code> 显示出进程和PID</p>
</li>
<li><p><code>-n</code> 将主机、端口和用户名用数字代替</p>
</li>
<li><p><code>netstat -apn | grep port</code> 显示指定端口的状态信息和进程信息</p>
</li>
<li><p>网络接口信息</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 显示网卡信息，可结合ifconfig学习</span><br><span class="hljs-attribute">netstat</span> -i<br></code></pre></td></tr></table></figure>
</li>
<li><p>列出端口</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">-a</span>(all)表示所有端口，<span class="hljs-built_in">-t</span>(tcp)表示所有使用中的TCP端口<br># <span class="hljs-built_in">-l</span>(listening)表示正在监听的端口<br>netstat -at<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示端口统计信息</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"># <span class="hljs-built_in">-s</span>(status)显示各协议信息<br># -加上<span class="hljs-built_in">-t</span>(tcp)显示tcp协议信息，加上<span class="hljs-built_in">-u</span>(udp)显示udp协议信息<br>netstat -s<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示使用某协议的应用名</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><span class="hljs-attribute">netstat</span> -pt<br></code></pre></td></tr></table></figure>
</li>
<li><p>查找指定进程、端口</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="hljs-comment"># 第二个操作可以用lsof替代</span><br>netstat -ap | <span class="hljs-keyword">grep</span> ssh<br>netstat -an | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;:80&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>tcpdump</strong></p>
<ul>
<li><code>tcpdump host ip</code> 截获主机发出和收到的数据包</li>
<li><code>tcpdump port 6666</code> 截获端口上通过的包</li>
<li><code>tcpdump -i eth0</code> 截获某网卡上的包</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">详见</a></p>
</li>
<li><p><strong>ping</strong></p>
<ul>
<li><code>ping ip</code> 用于测试另一台主机是否可达，测试网络是否连通以及时延</li>
<li>windows下ping是32比特，默认发送4次数据包结束</li>
<li>linux下ping是64比特，默认不停发送数据包，直到手动停止</li>
</ul>
</li>
<li><p><strong>host</strong></p>
<ul>
<li><code>host 域名</code> 返回域名的IP地址</li>
<li>用来查询DNS记录</li>
</ul>
</li>
<li><p><strong>ifconfig</strong></p>
<ul>
<li><p>输出当前系统中所有处于活动状态的网络接口</p>
</li>
<li><p><code>ifconfig eth0 ip/24</code> 手工指定网卡的IP地址和广播地址，其中广播地址可以根据掩码计算出来</p>
</li>
<li><p><code>ifconfig eth0 up</code> 启动网卡eht0</p>
</li>
<li><p><code>ifconfig eth0 down</code> 关闭网卡eht0</p>
</li>
<li><p>显示设备信息</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 可以显示已激活的网络设备信息</span><br>ifconfig<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动关闭指定网卡</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 前一个参数为具体网卡，后一个为开关信息</span><br><span class="hljs-comment"># up为打开，down为关闭</span><br><span class="hljs-attribute">ifconfig</span> eth0 up<br></code></pre></td></tr></table></figure>
</li>
<li><p>配置IP地址</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 前一个参数为具体网卡，后一个为配置的IP地址</span><br><span class="hljs-attribute">ifconfig</span> eth0 <span class="hljs-number">192.168.1.1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>设置最大传输单元</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">前一个参数为具体网卡，后面为MTU的大小</span><br><span class="hljs-comment"># 设置链路层MTU值，通常为1500</span><br><span class="hljs-string">ifconfig</span> <span class="hljs-string">eth0</span> <span class="hljs-string">mtu</span> <span class="hljs-number">1500</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>启用和关闭ARP协议</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启arp如下，若关闭则-arp</span><br><span class="hljs-attribute">ifconfig</span> eth0 arp<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>traceroute</strong></p>
<ul>
<li><p>文件包途径的IP</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 可以打印从沿途经过的路由器IP地址</span><br><span class="hljs-attribute">traceroute</span> baidu.com<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>网络Debug分析（网络层&#x2F;传输层）：nc</strong></p>
<ul>
<li><p>端口扫描</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 黑客很喜欢</span><br><span class="hljs-comment"># 扫描某服务器端口使用情况</span><br><span class="hljs-comment"># -v(view)显示指令执行过程，-w(wait)设置超时时长</span><br><span class="hljs-comment"># -z使用输入输出模式（只在端口扫描时使用）</span><br><span class="hljs-comment"># 数字为扫描的端口范围 </span><br><span class="hljs-attribute">nc</span> -v -w <span class="hljs-number">1</span> baidu.com  -z <span class="hljs-number">75</span>-<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.oschina.net/translate/linux-netcat-command">其他详见</a></p>
</li>
<li><p><strong>域名解析工具（应用层DNS协议）：dig</strong></p>
<ul>
<li><pre><code class="hljs"># 应用层，DNS
# 打印域名解析结果
# 打印域名解析过程中涉及的各级DNS服务器地址
dig baidu.com
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**网络请求（应用层）：curl**</span><br><br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://www.cnblogs.com/gbyukg/p/3326825.html</span>)<br><br><span class="hljs-section">## 7.调试命令</span><br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**调试工具：gdb**</span><br>  <br><span class="hljs-bullet">  *</span> <span class="hljs-code">`l`</span> 列出函数代码及行数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`b 16`</span> 在16行设置断点<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`b func`</span> 在函数func设置断点<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`r`</span> 运行程序<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`n`</span> 单条执行程序<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`p i`</span> 打印i变量的值<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`bt`</span> 查看函数堆栈<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`finish`</span> 退出函数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`q`</span> 结束调试<br>  <br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</span>)<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**编译器：gcc/g++**</span><br><br><span class="hljs-bullet">  *</span> \- C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程<br><br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html</span>)<br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**跟踪进程中系统调用：strace**</span><br>  <br><span class="hljs-bullet">  *</span> 监控用户空间进程和内核的交互，跟踪系统调用和信号传递<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`strace -c ./test`</span> 统计./test使用的系统调用<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`strace -p pid`</span> 跟踪现有进程<br>  <br>  [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html</span>)<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**跟踪进程栈：pstack**</span><br><br><span class="hljs-bullet">  *</span> [<span class="hljs-string">详见</span>](<span class="hljs-link">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#</span>)<br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**ipcs**</span><br>  <br><span class="hljs-bullet">  *</span> 用于报告系统的消息队列，信号量和共享内存等使用情况<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -a`</span>用于列出本用户所有相关的ipcs参数<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -q`</span>用于列出进程中的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -s`</span>用于列出所有的信号量<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -m`</span>用于列出所有的共享内存信息<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -l`</span>用于列出系统限额，比如共享内存最大限制<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcs -u`</span>用于列出当前的使用情况<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**进程内存映射：pmap**</span><br><br><span class="hljs-bullet">  *</span> 显示进程内存映射<br><br></code></pre></td></tr></table></figure>
# -x显示扩展信息，后接进程pid
# Address: 内存开始地址
# 显示信息：
    Kbytes: 占用内存的字节数
    RSS: 保留内存的字节数
    Dirty: 脏页的字节数（包括共享和私有的）
    Mode: 内存的权限：read、write、execute、shared、private
    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）
    Device: 设备名 (major:minor)

pmap -x 12345
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**ipcrm**</span><br>  <br><span class="hljs-bullet">  *</span> 用于移除一个消息队列，或者共享内存段，或者一个信号集，同时会将与ipc对象相关联的数据也一起移除，只有超级管理员，或者ipc对象的创建者才能这样做<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -M shmkey`</span> 移除用shmkey创建的共享内存段<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -m shmid`</span> 移除用shmid标识的共享内存段<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -Q msgkey`</span> 移除用msqkey创建的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -q msqid`</span> 移除用msqid标识的消息队列<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -S semkey`</span> 移除用semkey创建的信号<br><span class="hljs-bullet">  *</span> <span class="hljs-code">`ipcrm -s semid`</span> 移除用semid标识的信号<br>  <br><span class="hljs-bullet">*</span> <span class="hljs-strong">**查看依赖库：ldd**</span><br><br><span class="hljs-bullet">  *</span> 程序依赖库查询<br><br></code></pre></td></tr></table></figure>
# ldd后接可执行文件
# 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址
# 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置

ldd a.out
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">## 8.文本处理工具</span><br><br><span class="hljs-bullet">*</span> <span class="hljs-strong">**sed**</span><br><br><span class="hljs-bullet">  -</span> 统计该文件中每一个单词出现的次数，并按照出现频率从大到小排序<br><br></code></pre></td></tr></table></figure>
sed &#39;s/ /\n/g&#39; &quot;a.txt&quot; | sort | uniq -c | sort -nr
</code></pre>
<p><strong>sed替换：</strong></p>
<ul>
<li><p>sed ‘s&#x2F;被替换的字符串&#x2F;新字符串&#x2F;[替换选项]’ filename</p>
</li>
<li><p>替换选项g表示替换文本中所有出现被替换字符串之处</p>
</li>
</ul>
<p><strong>uniq统计次数：</strong></p>
<ul>
<li>uniq -c表示打印每行在文本中重复出现的次数</li>
</ul>
<p><strong>sort排序：</strong></p>
<ul>
<li><p>-n根据数字大小进行排序</p>
</li>
<li><p>-r将排序结果逆向显示</p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/9104.html">详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-sed.html">Linux教程</a></p>
</li>
</ul>
<ul>
<li><p><strong>awk</strong></p>
<p><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/9070.html">详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-awk.html">Linux教程</a></p>
</li>
</ul>
<h1 id="四、Docker"><a href="#四、Docker" class="headerlink" title="四、Docker"></a>四、Docker</h1><h2 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1.Docker概述"></a>1.Docker概述</h2><h3 id="1-1解决的问题"><a href="#1-1解决的问题" class="headerlink" title="1.1解决的问题"></a>1.1解决的问题</h3><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png" srcset="/img/loading.gif" lazyload width="400px"/> </div><br>

<h3 id="1-2与虚拟机的比较"><a href="#1-2与虚拟机的比较" class="headerlink" title="1.2与虚拟机的比较"></a>1.2与虚拟机的比较</h3><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png" srcset="/img/loading.gif" lazyload width="500"/> </div><br>

<ul>
<li><p><strong>启动速度</strong></p>
<ul>
<li>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢</li>
<li>而启动 Docker 相当于启动宿主操作系统上的一个进程</li>
</ul>
</li>
<li><p><strong>占用资源</strong></p>
<ul>
<li>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机</li>
<li>而Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker</li>
</ul>
</li>
</ul>
<h3 id="1-3优势"><a href="#1-3优势" class="headerlink" title="1.3优势"></a>1.3优势</h3><p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<ul>
<li><p><strong>更容易迁移</strong></p>
<ul>
<li>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行</li>
</ul>
</li>
<li><p><strong>更容易维护</strong></p>
<ul>
<li>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易</li>
</ul>
</li>
<li><p><strong>更容易扩展</strong></p>
<ul>
<li>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像</li>
</ul>
</li>
</ul>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h2><ul>
<li><p><strong>持续集成</strong></p>
<ul>
<li>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误</li>
<li>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响</li>
</ul>
</li>
<li><p><strong>提供可伸缩的云服务</strong></p>
<ul>
<li>根据应用的负载情况，可以很容易地增加或者减少 Docker</li>
</ul>
</li>
<li><p><strong>搭建微服务架构</strong></p>
<ul>
<li>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务</li>
</ul>
</li>
</ul>
<h2 id="3-镜像与容器"><a href="#3-镜像与容器" class="headerlink" title="3.镜像与容器"></a>3.镜像与容器</h2><ul>
<li><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例</p>
</li>
<li><p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制</p>
</li>
<li><p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png" srcset="/img/loading.gif" lazyload/> </div><br>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li>
<li><a target="_blank" rel="noopener" href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php">Docker container vs Virtual machine</a></li>
<li><a target="_blank" rel="noopener" href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/">How to Create Docker Container using Dockerfile</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sammyliu/p/5877964.html">理解 Docker（2）：Docker 镜像</a></li>
<li><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html">为什么要使用 Docker？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docker.com/what-docker">What is Docker</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-00-overview.html">Java全栈知识体系</a></li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PersonalSummary/">#PersonalSummary</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux面经-个人总结</div>
      <div>http://example.com/2022/07/09/Linux面经-个人总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fyy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="计算机网络面经-个人总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络面经-个人总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/09/Linux-C-%E5%85%A8%E5%A5%97%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F-%E5%8F%82%E8%80%83/" title="Linux C++全套牛客面经-参考">
                        <span class="hidden-mobile">Linux C++全套牛客面经-参考</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
