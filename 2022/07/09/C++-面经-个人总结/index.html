

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fyy">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、C++基础1.数组和指针的区别 概念不同  指针相当于一个变量，它存放的是数据在内存中的地址 数组是用于储存多个相同类型数据的集合   赋值不同  同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝   访问数据不同  指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容 数组是直接访问   sizeof意义不同  数组所占存储空间的内存：sizeof（数组名）">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面经-个人总结">
<meta property="og:url" content="http://example.com/2022/07/09/C++-%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="UESTC-Fyy">
<meta property="og:description" content="一、C++基础1.数组和指针的区别 概念不同  指针相当于一个变量，它存放的是数据在内存中的地址 数组是用于储存多个相同类型数据的集合   赋值不同  同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝   访问数据不同  指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容 数组是直接访问   sizeof意义不同  数组所占存储空间的内存：sizeof（数组名）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251433025.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251433244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251546070.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208202051612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208202052325.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208291549311.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204011124009.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339227.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356676.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356849.png">
<meta property="article:published_time" content="2022-07-09T07:15:45.000Z">
<meta property="article:modified_time" content="2022-09-11T14:40:12.936Z">
<meta property="article:author" content="Fyy">
<meta property="article:tag" content="PersonalSummary">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png">
  
  
  <title>C++面经-个人总结 - UESTC-Fyy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DKnIWAmLCrVnCLIBVwd8hotg-gzGzoHsz","app_key":"9xmUpEdyRJB2o9bIKREcXk3j","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>UESTC-Fyy-Master</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++面经-个人总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-09 15:15" pubdate>
          2022年7月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          442 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++面经-个人总结</h1>
            
            <div class="markdown-body">
              
              <h1 id="一、C-基础"><a href="#一、C-基础" class="headerlink" title="一、C++基础"></a>一、C++基础</h1><h2 id="1-数组和指针的区别"><a href="#1-数组和指针的区别" class="headerlink" title="1.数组和指针的区别"></a>1.数组和指针的区别</h2><ul>
<li><strong>概念不同</strong> <ul>
<li>指针相当于一个变量，它存放的是数据在内存中的地址</li>
<li>数组是用于储存多个相同类型数据的集合</li>
</ul>
</li>
<li><strong>赋值不同</strong> <ul>
<li>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li>
</ul>
</li>
<li><strong>访问数据不同</strong> <ul>
<li>指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容</li>
<li>数组是直接访问</li>
</ul>
</li>
<li><strong>sizeof意义不同</strong> <ul>
<li>数组所占存储空间的内存：sizeof（数组名） ,数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） </li>
<li>在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li>
</ul>
</li>
<li><strong>指针和数组名异同</strong> <ul>
<li>指针和数组名都可以表示地址，但指针是变量，可以修改</li>
<li>数组名是常量，不可修改赋值</li>
</ul>
</li>
<li><strong>传参：</strong> 数组传参时会退化成指针 <ul>
<li>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。 </li>
<li>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</li>
</ul>
</li>
</ul>
<h2 id="2-指针数组和数组指针"><a href="#2-指针数组和数组指针" class="headerlink" title="2.指针数组和数组指针"></a>2.指针数组和数组指针</h2><ul>
<li><strong>指针数组：</strong>它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8]<ul>
<li><ol>
<li>优先级问题：[]的优先级比高 </li>
<li>说明arr是一个数组，而int*是数组里面的内容 </li>
<li>这句话的意思就是：arr是一个含有8和int*的数组</li>
</ol>
</li>
</ul>
</li>
<li><strong>数组指针：</strong>它实际上是一个指针，该指针指向一个数组。 int (*arr)[8]<ul>
<li><ol>
<li>由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来 </li>
<li>arr先和*结合，说明p是一个指针变量 </li>
<li>这句话的意思就是：指针arr指向一个大小为8个整型的数组</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="3-字符数组和字符串常量"><a href="#3-字符数组和字符串常量" class="headerlink" title="3.字符数组和字符串常量"></a>3.字符数组和字符串常量</h2><ul>
<li><strong>字符数组：</strong>char arr[] &#x3D; “hello”;<ul>
<li>此处的赋值是将常量区的字符串”hello”拷贝到了堆栈区的数arr的空间了</li>
<li>数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值</li>
<li>另外此时的数组名arr是堆栈区中的”hello”的首地址</li>
</ul>
</li>
<li><strong>字符串常量：</strong>char *arr2 &#x3D; “hello”;<ul>
<li>指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值</li>
</ul>
</li>
</ul>
<h2 id="4-引用和指针的区别"><a href="#4-引用和指针的区别" class="headerlink" title="4.引用和指针的区别"></a>4.引用和指针的区别</h2><ul>
<li><strong>指针有内存分配，而引用只是一个别名</strong> <ul>
<li>引用声明时必须初始化，从而指向一个已经存在的对象</li>
</ul>
</li>
<li><strong>引用可以看做常量指针，指针是一个存储地址的变量</strong> <ul>
<li>指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变</li>
<li>这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变</li>
</ul>
</li>
<li><strong>引用创建时必须初始化，且不为空，指针创建时可以为空</strong> <ul>
<li>不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高</li>
<li>因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空</li>
</ul>
</li>
<li><strong>指针和引用的自增运算符意义不同</strong> <ul>
<li>指针是对内存地址的自增，引用是对值的自增</li>
</ul>
</li>
<li><strong>sizeof的意义不同</strong> <ul>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小</li>
</ul>
</li>
<li><strong>没有引用常量，有指针常量</strong> <ul>
<li>没有int&amp; const p，但有int* const p</li>
<li>常量指针和常量引用是存在的，const int *p和cosnt int &amp;p，都表示指向的对象为常量常量引用形参的好处：<ul>
<li>（1）使用引用作为形参，不会产生新的变量，减少形参和实参传递的开销</li>
<li>（2）使用引用可能会导致实参随着形参的改变而改变。声明为const之后就会消除这种副作用</li>
</ul>
</li>
</ul>
</li>
<li><strong>参数传递</strong> <ul>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象</li>
</ul>
</li>
<li><strong>多级指针，一级引用</strong> <ul>
<li>指针可以有多级指针（**p），而引用只有一级</li>
</ul>
</li>
</ul>
<h2 id="5-函数指针与指针函数"><a href="#5-函数指针与指针函数" class="headerlink" title="5.函数指针与指针函数"></a>5.函数指针与指针函数</h2><ul>
<li>指针函数<code>int* f(int x, int y)</code>本质是函数，返回值为指针，函数指针<code>int (*f)(int x)</code>本质是指针，指向函数的指针</li>
<li>通常我们可以将指针指向某类型的变量，称为类型指针（如，整型指针）。若将一个指针指向函数，则称为函数指针</li>
<li>函数名代表函数的入口地址，同样的，我们可以通过根据该地址进行函数调用，而非直接调用函数名</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test001</span>()</span>&#123;<br>    printf(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br>    <span class="hljs-keyword">void</span>(*myfunc)() = test001;<span class="hljs-comment">//将函数写成函数指针</span><br>    myfunc(); <span class="hljs-comment">//调用函数指针 hello world</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>test001的函数名与myfunc函数指针都是一样的，即都是函数指针。test001函数名是一个函数指针常量，而myfunc是一个函数指针变量，这是它们的关系</p>
<ul>
<li>函数指针多用于回调函数，回调函数最大的优势在于灵活操作，可以实现用户定制的函数，降低耦合性，实现多样性，如STL中</li>
</ul>
<h2 id="6-C-中class和struct的区别"><a href="#6-C-中class和struct的区别" class="headerlink" title="6.C++中class和struct的区别"></a>6.C++中class和struct的区别</h2><ul>
<li>在C语言中，struct 只能包含成员变量，不能包含成员函数，但C++中可以</li>
<li>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它能包含<strong>成员函数，能继承与实现多态</strong></li>
<li><strong>class 中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的</strong></li>
<li><strong>默认的继承访问权限</strong> <ul>
<li>struct是public的，class是private的 </li>
<li>class B : public A就是为了指明是public继承，而不是用默认的private继承，若class B : A则是private继承</li>
</ul>
</li>
<li><strong>定义模板参数</strong> <ul>
<li>class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数</li>
</ul>
</li>
</ul>
<h2 id="7-结构体和联合体的区别"><a href="#7-结构体和联合体的区别" class="headerlink" title="7.结构体和联合体的区别"></a>7.结构体和联合体的区别</h2><ul>
<li>struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和</li>
<li>在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度</li>
<li>对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的</li>
</ul>
<h2 id="8-new-x2F-delete和malloc-x2F-free的区别"><a href="#8-new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="8.new&#x2F;delete和malloc&#x2F;free的区别"></a>8.new&#x2F;delete和malloc&#x2F;free的区别</h2><ul>
<li><p><strong>主要区别</strong></p>
<ul>
<li>calloc在返回指向内存的指针之前把它初始化为0，calloc的参数包括所需的元素的数量和每个元素的字节数</li>
</ul>
</li>
<li><p><strong>属性不同</strong> </p>
<ul>
<li>new&#x2F;delete是C++关键字，需要编译器支持。malloc&#x2F;free是库函数，需要头文件支持C</li>
</ul>
</li>
<li><p><strong>申请的内存所在位置</strong> </p>
<ul>
<li><strong>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存</strong></li>
<li>自由存储区是C++的抽象概念，堆是操作系统中的术语，自由存储区可以是堆，也可以是静态存储区，取决于operator new的实现细节</li>
<li>基本上所有的C++编译器默认用堆来实现自由存储区，即new运算符会按照malloc的方式来实现</li>
</ul>
</li>
<li><p><strong>返回类型安全性</strong> </p>
<ul>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</li>
<li>malloc内存分配成功则是返回void*类型，需要通过强制类型转换将空类型指针转换成我们需要的类型</li>
</ul>
</li>
<li><p><strong>内存分配失败时的返回值</strong></p>
<ul>
<li>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL</li>
</ul>
</li>
<li><p><strong>是否需要指定内存大小</strong> </p>
<ul>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算<ul>
<li>int *pi&#x3D;new int;	&#x2F;&#x2F;在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi</li>
<li>int *pi&#x3D;new int();	&#x2F;&#x2F;对指针pi指向的地址的值进行了初始化为0 </li>
<li>int *pi&#x3D;new int(1024);	&#x2F;&#x2F;初始化为1024</li>
</ul>
</li>
<li>malloc则需要显式地指出所需内存的大小<ul>
<li>int *p&#x3D;(int *)malloc(100);	&#x2F;&#x2F;指向整型的指针p指向一个大小为100字节的内存的地址 </li>
<li>int *p&#x3D;(int *)malloc(25 * sizeof(int));	&#x2F;&#x2F;指向整型的指针p指向一个25个int整型空间的地址</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数组分配内存（与前一个特点类似）</strong></p>
<ul>
<li>new中分配内存对于变量和数组不同，malloc分配内存则相同 </li>
<li>int *pi&#x3D;new int[];	&#x2F;&#x2F;指针pi所指向的数组未初始化 </li>
<li>int *pi&#x3D;new int[n];	&#x2F;&#x2F;指针pi指向长度为n的数组，未初始化 </li>
<li>int *pi&#x3D;new int;	&#x2F;&#x2F;指针pi所指向的地址初始化为0</li>
</ul>
</li>
<li><p><strong>是否调用构造函数&#x2F;析构函数</strong> </p>
<ul>
<li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</li>
<li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作</li>
</ul>
</li>
<li><p><strong>能否重载</strong> </p>
<ul>
<li>opeartor new&#x2F;operator delete允许重载,malloc&#x2F;free不允许重载</li>
</ul>
</li>
<li><p><strong>已分配内存的扩充</strong> </p>
<ul>
<li>malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</li>
</ul>
</li>
<li><p><strong>能否相互调用</strong></p>
<ul>
<li>operator new &#x2F;operator  delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new</li>
</ul>
</li>
</ul>
<h2 id="9-new运算符的原理"><a href="#9-new运算符的原理" class="headerlink" title="9.new运算符的原理"></a>9.new运算符的原理</h2><ul>
<li><p><strong>基本过程</strong></p>
<ul>
<li><p>new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间</p>
</li>
<li><p>编译器运行相应的构造函数以构造这些对象，并为其传入初始值</p>
</li>
<li><p>对象被分配了空间并构造完成，返回一个指向该对象的指针</p>
</li>
</ul>
</li>
<li><p><strong>内存分配</strong></p>
<ul>
<li><p>new简单类型直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数</p>
</li>
<li><p>对于简单类型，new[]计算好大小后调用operator new；对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小</p>
</li>
<li><p>如果 operator new(size_t) 不能成功获得内存，则调用 new_handler()函数用于处理new失败问题</p>
</li>
<li><p>如果没有设置 new_handler() 函数或者 new_handler() 未能分配足够内存，则抛出 std::bad_alloc 异常</p>
</li>
</ul>
</li>
<li><p><strong>构造函数</strong></p>
<ul>
<li>在分配到的动态内存块上 初始化相应类型的对象（构造函数）并返回其首地址</li>
<li>如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void *) 函数释放已经分配到的内存</li>
</ul>
</li>
</ul>
<h2 id="10-delete、delete、allocator都有什么作用"><a href="#10-delete、delete、allocator都有什么作用" class="headerlink" title="10.delete、delete、allocator都有什么作用"></a>10.delete、delete、allocator都有什么作用</h2><ul>
<li>需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了</li>
<li>delete简单数据类型默认只是调用free函数；复杂数据类型则先调用析构函数再调用operator delete<ul>
<li>针对简单类型，delete和delete[]等同。如果指针p指向new[]分配的内存，因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存，而delete会直接释放p指向的内存，但这个内存根本没有被系统记录，所以会崩溃</li>
<li>delete[]时，数组中的元素按逆序的顺序进行销毁</li>
<li>delete ptr代表用来释放内存，且只用来释放ptr指向的内存。delete[] rg用来释放rg指向的内存，还逐一调用数组中每个对象的destructor</li>
<li>对于像int&#x2F;char&#x2F;long&#x2F;int*&#x2F;struct等等简单数据类型，由于对象没有destructor ，所以用 delete 和 delete []是一样的！但是如果是 C++ 对象数组就不同</li>
</ul>
</li>
<li>new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作</li>
</ul>
<h2 id="11-malloc-x2F-free的实现原理"><a href="#11-malloc-x2F-free的实现原理" class="headerlink" title="11.malloc&#x2F;free的实现原理"></a>11.malloc&#x2F;free的实现原理</h2><ol>
<li><p>在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk、mmap、munmap这些系统调用实现的</p>
</li>
<li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</p>
</li>
<li><p>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p>
</li>
<li><p>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序</p>
</li>
</ol>
<ul>
<li><p><strong>malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存？</strong></p>
<ul>
<li>首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存</li>
<li>如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中</li>
</ul>
</li>
<li><p><strong>被free回收的内存不是立即返还给操作系统</strong></p>
<ul>
<li>被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片</li>
</ul>
</li>
</ul>
<h2 id="12-堆和栈的区别"><a href="#12-堆和栈的区别" class="headerlink" title="12.堆和栈的区别"></a>12.堆和栈的区别</h2><ul>
<li>管理方式不同<ul>
<li>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak</li>
</ul>
</li>
<li>空间大小不同<ul>
<li>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M</li>
</ul>
</li>
<li>能否产生碎片不同<ul>
<li>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</li>
<li>对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</li>
</ul>
</li>
<li>生长方向不同<ul>
<li>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长</li>
</ul>
</li>
</ul>
<h2 id="13-const关键字"><a href="#13-const关键字" class="headerlink" title="13.const关键字"></a>13.const关键字</h2><ul>
<li><strong>修饰变量：</strong>说明该变量不可以被改变</li>
<li><strong>修饰指针：</strong>分为指向常量的指针和指针常量；int *const p和const int *p</li>
<li><strong>常量引用：</strong>经常用于形参类型，即避免了拷贝，又避免了函数对值的修改</li>
<li><strong>修饰成员函数：</strong>说明该成员函数内不能修改成员变量，本质是const this指针</li>
</ul>
<h2 id="14-static关键字"><a href="#14-static关键字" class="headerlink" title="14.static关键字"></a>14.static关键字</h2><ul>
<li><strong>修饰普通变量：</strong> 修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0<ul>
<li><strong>全局变量作用域：</strong>全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾</li>
<li><strong>局部变量作用域：</strong>仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变</li>
</ul>
</li>
<li><strong>修饰普通函数：</strong>其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li><strong>修饰类成员变量和成员函数：</strong> 它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li>
</ul>
<h2 id="15-extern关键字"><a href="#15-extern关键字" class="headerlink" title="15.extern关键字"></a>15.extern关键字</h2><p>extern关键字主要修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用</p>
<ul>
<li><strong>修饰变量或函数</strong><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
</ul>
</li>
<li><strong>extern “C”</strong><ul>
<li>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题<ul>
<li><ol>
<li>在c头文件中通过#ifdef __cplusplus extern “C” { #endif来定义</li>
<li>在对应的c文件中实现 </li>
<li>在cpp文件中通过“extern “C” 函数名”调用，或者包含c头文件 </li>
<li><strong>注意：</strong> extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间，但若需要调用的函数太多，还是直接包含头文件吧</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="16-volatile关键字"><a href="#16-volatile关键字" class="headerlink" title="16.volatile关键字"></a>16.volatile关键字</h2><ul>
<li><strong>不可优化性：</strong> volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化</li>
<li><strong>易变性：</strong> volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
</ul>
<h2 id="17-explicit关键字"><a href="#17-explicit关键字" class="headerlink" title="17.explicit关键字"></a>17.explicit关键字</h2><p>explicit关键字的作用就是<strong>防止对象间实现&#x3D;赋值</strong>，<strong>防止类构造函数的隐式自动转换</strong>，类构造函数默认情况下即声明为implicit(隐式)，另外<strong>explicit只用于单参数的构造函数</strong>，或者除了第一个参数以外的其他参数都有默认值</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换</li>
</ul>
<h2 id="18-final和override关键字"><a href="#18-final和override关键字" class="headerlink" title="18.final和override关键字"></a>18.final和override关键字</h2><p><strong>override</strong></p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// OK</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//OK</span><br>&#125;  <br></code></pre></td></tr></table></figure>

<p>如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f00</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK，这个函数是B新增的，不是继承的</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0o</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>final</strong></p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">final</span> : A <span class="hljs-comment">// 指明B是不可以被继承的</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// Error: 在A中已经被final了</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : B <span class="hljs-comment">// Error: B is final</span><br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="19-C-从代码到可执行"><a href="#19-C-从代码到可执行" class="headerlink" title="19.C++从代码到可执行"></a>19.C++从代码到可执行</h2><p><strong>一、预编译</strong></p>
<p>主要处理源代码文件中的以“#”开头的预编译指令，处理规则见下：</p>
<ol>
<li>删除所有的#define，展开所有的宏定义</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件</li>
<li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号</li>
</ol>
<p><strong>二、编译</strong></p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件</p>
<ol>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义</li>
<li>优化：源代码级别的一个优化过程</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等</li>
</ol>
<p><strong>三、汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)</p>
<p><strong>四、链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ul>
<li><p><strong>静态链接</strong></p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件</p>
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本</li>
<li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序</li>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快</li>
</ul>
</li>
<li><p><strong>动态链接</strong></p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件</p>
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标</li>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</li>
</ul>
</li>
</ul>
<h2 id="20-hello-c程序的编译过程"><a href="#20-hello-c程序的编译过程" class="headerlink" title="20.hello.c程序的编译过程"></a>20.hello.c程序的编译过程</h2><p>以下是一个 hello.c 程序：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;

int main()
&#123;
    printf(&quot;hello, world\n&quot;);
    return 0;
&#125;
</code></pre>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<pre><code class="hljs">    gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：</p>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<p><strong>静态链接</strong><br>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>目标文件</strong></p>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<p><strong>动态链接</strong><br>静态库有以下两个问题：</p>
<ul>
<li><p>当静态库更新时那么整个程序都要重新进行链接；</p>
</li>
<li><p>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</p>
</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</p>
<ol>
<li><p>预处理<br>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。</p>
</li>
<li><p>编译阶段<br>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p>
</li>
<li><p>汇编过程<br>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p>
</li>
<li><p>链接阶段<br>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p>
</li>
</ol>
<h2 id="21-宏定义和typedef、函数的区别"><a href="#21-宏定义和typedef、函数的区别" class="headerlink" title="21.宏定义和typedef、函数的区别"></a>21.宏定义和typedef、函数的区别</h2><p><strong>宏定义与typedef：</strong></p>
<ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分</li>
<li>宏不检查类型；typedef会检查数据类型</li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束</li>
<li>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大</li>
</ul>
<p><strong>宏定义与函数：</strong></p>
<ul>
<li>宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数</li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值</li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型</li>
</ul>
<h2 id="22-C-异常处理（try-catch-throw）"><a href="#22-C-异常处理（try-catch-throw）" class="headerlink" title="22.C++异常处理（try catch throw）"></a>22.C++异常处理（try catch throw）</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/422.html">详解</a></p>
<h2 id="23-如何用代码判断大小端存储？"><a href="#23-如何用代码判断大小端存储？" class="headerlink" title="23.如何用代码判断大小端存储？"></a>23.如何用代码判断大小端存储？</h2><ul>
<li><p>大端存储：字数据的高字节存储在低地址中</p>
</li>
<li><p>小端存储：字数据的低字节存储在低地址中</p>
</li>
</ul>
<p>例如：32bit的数字0x12345678</p>
<p><strong>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p>
<ul>
<li>小端模式中的存储方式为：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251433025.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>大端模式中的存储方式为：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251433244.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>方式一：使用强制类型转换</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;
    else if(c == 0x34)
        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>方式二：巧用union联合体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">endian</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> ch;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    endian value;<br>    value.a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//a和ch共用4字节的内存空间</span><br>    <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;big endian&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;little endian&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="24-快速判断一个数是否是2的幂次方"><a href="#24-快速判断一个数是否是2的幂次方" class="headerlink" title="24.快速判断一个数是否是2的幂次方"></a>24.快速判断一个数是否是2的幂次方</h2><ul>
<li><p>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了 </p>
</li>
<li><p>如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零</p>
</li>
<li><p><strong>最快速的方法： (number &amp; number - 1) &#x3D;&#x3D; 0</strong></p>
</li>
<li><p>原因：因为2的N次方换算是二进制为10……0这样的形式(0除外)。与上自己-1的位数，这们得到结果为0。例如。8的二进制为1000；8-1&#x3D;7，7的二进制为111。两者相与的结果为0。计算如下：<br> 1000<br> &amp; 0111</p>
</li>
</ul>
<p>​            0000</p>
<pre><code class="hljs">使用递归来实现的代码如下：
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;

int log2(int value)   //递归判断一个数是2的多少次方
&#123;
    if (value == 1)
        return 0;
    else
        return 1+log2(value&gt;&gt;1);
&#125;

int main(void)
&#123;
    int num;
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;,&amp;num);
    if(num&amp;(num-1))  //使用与运算判断一个数是否是2的幂次方
        printf(&quot;%d不是2的幂次方！\n&quot;,num);
    else
        printf(&quot;%d是2的%d次方！\n&quot;,num,log2(num));
    system(&quot;pause&quot;);
    return 0;
&#125;

使用非递归来实现的代码如下：
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;

int log2(int value)   //非递归判断一个数是2的多少次方
&#123;
    int x=0;
    while(value&gt;1)
    &#123;
        value&gt;&gt;=1;
        x++;
    &#125;
    return x;
&#125;

int main(void)
&#123;
    int num;
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;,&amp;num);
    if(num&amp;(num-1))     //使用与运算判断一个数是否是2的幂次方
        printf(&quot;%d不是2的幂次方！\n&quot;,num);
    else
        printf(&quot;%d是2的%d次方！\n&quot;,num,log2(num));
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<ul>
<li><strong>扩展一：求一个数n的二进制中1的个数</strong><br>非常巧妙地利用了一个性质，n&#x3D;n&amp;(n-1) 能移除掉n的二进制中最右边的1的性质，循环移除，直到将1全部移除，这种方法将问题的复杂度降低到只和1的个数有关系。代码如下：</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> Func3(<span class="hljs-built_in">int</span> <span class="hljs-keyword">data</span>)<br>&#123;   //利用了<span class="hljs-keyword">data</span>&amp;(<span class="hljs-keyword">data</span>-<span class="hljs-number">1</span>)每次都能移除最右边的<span class="hljs-number">1</span>，移除了多少个<span class="hljs-number">1</span>，就是包含了几个<span class="hljs-number">1</span><br>	<span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (<span class="hljs-keyword">data</span>)<br>	&#123;<br>		<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span> &amp; (<span class="hljs-keyword">data</span>-<span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">count</span>++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>扩展问题二：A和B的二进制中有多少位不相同</strong> <ul>
<li>(1)将A和B异或得到C，即C&#x3D;A^B</li>
<li>(2)计算C的二进制中有多少个1</li>
</ul>
</li>
</ul>
<h1 id="二、C-面向对象"><a href="#二、C-面向对象" class="headerlink" title="二、C++面向对象"></a>二、C++面向对象</h1><h2 id="1-内存字节对齐"><a href="#1-内存字节对齐" class="headerlink" title="1.内存字节对齐"></a>1.内存字节对齐</h2><ul>
<li><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing">struct A&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">short</span> c;<br>&#125;;<br>- <span class="hljs-type">char</span>占一个字节，起始偏移为零<br>- <span class="hljs-type">int</span>占四个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以应该偏移量为<span class="hljs-number">4</span>，所以应该在<span class="hljs-type">char</span>后面加上三个字节，不存放任何东西<br>- <span class="hljs-type">short</span>占两个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>)=<span class="hljs-number">2</span>;所以偏移量是<span class="hljs-number">2</span>的倍数，而<span class="hljs-type">short</span>偏移量是<span class="hljs-number">8</span>，是<span class="hljs-number">2</span>的倍数，所以无需添加任何字节<br>- 所以第一个规则对齐之后内存状态为<span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span><br>- 此时一共占了<span class="hljs-number">10</span>个字节，但是还有结构体本身的对齐，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以总体应该是<span class="hljs-number">4</span>的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 <span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span>xx，一共占据了<span class="hljs-number">12</span>个字节<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>内存对齐规则</strong><ul>
<li>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数</li>
<li>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)</li>
</ul>
</li>
<li><strong>需要对齐的原因</strong><ul>
<li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li>
<li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li>
</ul>
</li>
</ul>
<h2 id="2-双冒号、using和namespace"><a href="#2-双冒号、using和namespace" class="headerlink" title="2.双冒号、using和namespace"></a>2.双冒号、using和namespace</h2><ul>
<li><strong>namespace主要用来解决命名冲突的问题</strong><ul>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放函数，变量、结构体和类</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li>
</ul>
</li>
<li><strong>双冒号::作用域运算符</strong><ul>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ul>
</li>
<li><strong>using分为using声明和using编译指令</strong><ul>
<li><code>using std::cout; //声明</code></li>
<li><code>using namespace std; //编译指令</code></li>
<li>尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</li>
</ul>
</li>
</ul>
<h2 id="3-内联函数、函数重载、宏定义的区别"><a href="#3-内联函数、函数重载、宏定义的区别" class="headerlink" title="3.内联函数、函数重载、宏定义的区别"></a>3.内联函数、函数重载、宏定义的区别</h2><ul>
<li><strong>内联函数</strong><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性</li>
<li>不能包含循环、递归、switch 等复杂操作</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数</li>
</ul>
</li>
<li><strong>内联函数适用场景：</strong><ul>
<li>使用宏定义的地方都可以使用 inline 函数</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li>
</ul>
</li>
<li><strong>C++的函数名称可以重复，称为函数重载</strong><ul>
<li>其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中</li>
<li>可以根据函数参数的个数、类型（const也可以作为重载条件）、顺序不同进行函数重载，但<strong>不能用函数返回值进行重载</strong></li>
<li>当函数重载遇到函数默认参数时，要注意二义性</li>
</ul>
</li>
<li><strong>内联函数与宏定义的区别</strong><ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数有类型检测、语法判断等功能，而宏没有</li>
</ul>
</li>
</ul>
<h2 id="4-虚函数可以是内联函数吗"><a href="#4-虚函数可以是内联函数吗" class="headerlink" title="4.虚函数可以是内联函数吗"></a>4.虚函数可以是内联函数吗</h2><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li>
<li>内联是在编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联</li>
<li><strong>inline virtual 唯一可以内联的时候是</strong>：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</li>
</ul>
<h2 id="5-构造函数和析构函数"><a href="#5-构造函数和析构函数" class="headerlink" title="5.构造函数和析构函数"></a>5.构造函数和析构函数</h2><ul>
<li>构造函数和析构函数，分别对应变量的初始化和清理，变量没有初始化，使用后果未知；没有清理，则会内存管理出现安全问题。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数</li>
</ul>
<blockquote>
<ul>
<li>构造函数：与类名相同，没有返回值，不写void，<strong>可以发生重载</strong>，可以有参数，编译器自动调用，只调用一次。</li>
<li>析构函数：~类名，没有返回值，不写void，<strong>不可以发生重载</strong>，不可以有参数，编译器自动调用，只调用一次。</li>
</ul>
</blockquote>
<ul>
<li>构造函数<ul>
<li>系统会默认给一个类提供三个函数：默认构造函数（无参，函数体为空）、默认拷贝构造和析构函数（无参，函数体为空），其中默认拷贝构造可以实现简单的值拷贝</li>
<li>提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数；若自己定义了有参构造，还想要无参构造函数，就必须再自定义无参构造函数</li>
</ul>
</li>
<li>析构函数<ul>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="6-拷贝初始化和直接初始化"><a href="#6-拷贝初始化和直接初始化" class="headerlink" title="6.拷贝初始化和直接初始化"></a>6.拷贝初始化和直接初始化</h2><ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;I am a string&quot;</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数   </span><br></code></pre></td></tr></table></figure>

<ul>
<li>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了（语句1和语句3等价），但是需要辨别两种情况。<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<h2 id="7-初始化和赋值的区别"><a href="#7-初始化和赋值的区别" class="headerlink" title="7.初始化和赋值的区别"></a>7.初始化和赋值的区别</h2><ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b)&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;;<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>拷贝构造函数、构造函数与赋值操作符的区别</strong></p>
<ul>
<li><strong>构造函数：对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</strong></li>
<li><strong>拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作</strong></li>
<li><strong>实现不一样</strong><ul>
<li><strong>拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象</strong></li>
<li><strong>赋值操作符则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回</strong></li>
</ul>
</li>
<li><strong>一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</strong></li>
<li><strong>如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码</strong></li>
</ul>
<h2 id="8-拷贝构造函数与深浅拷贝"><a href="#8-拷贝构造函数与深浅拷贝" class="headerlink" title="8.拷贝构造函数与深浅拷贝"></a>8.拷贝构造函数与深浅拷贝</h2><p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象</p>
<ul>
<li><strong>拷贝构造函数的使用时机</strong><ul>
<li>使用已经创建好的对象初始化新对象 <code>A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符</code></li>
<li>以值传递的方式来给函数参数传值</li>
<li>以值方式返回局部对象（不常用，一般不返回局部对象）</li>
</ul>
</li>
<li><strong>深拷贝和浅拷贝</strong>只有当对象的成员属性在堆区开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求<ul>
<li><strong>浅拷贝</strong>：使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉</li>
<li><strong>浅拷贝的问题</strong>：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。<strong>当数据成员中没有指针时，浅拷贝是可行的</strong>。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了所以，这时，必须采用深拷贝</li>
<li><strong>深拷贝</strong>：自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。<strong>需要注意自定义析构函数中应该释放掉申请的内存</strong></li>
</ul>
</li>
</ul>
<p>我们在定义类或者结构体，这些结构的时候，<strong>最后都重写拷贝函数，避免浅拷贝</strong>这类不易发现但后果严重的错误产生</p>
<h2 id="9-拷贝构造函数和移动构造函数的区别"><a href="#9-拷贝构造函数和移动构造函数的区别" class="headerlink" title="9.拷贝构造函数和移动构造函数的区别"></a>9.拷贝构造函数和移动构造函数的区别</h2><ul>
<li><strong>移动构造函数设计初衷</strong><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本</li>
</ul>
</li>
<li><strong>两者区别</strong><ul>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制</li>
<li>拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间</li>
<li>移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配额外的内存空间</li>
<li>典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象</li>
</ul>
</li>
</ul>
<h2 id="10-什么情况下会调用拷贝构造函数"><a href="#10-什么情况下会调用拷贝构造函数" class="headerlink" title="10.什么情况下会调用拷贝构造函数"></a>10.什么情况下会调用拷贝构造函数</h2><ul>
<li>用类的一个实例化对象去初始化另一个对象的时候</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li>
</ul>
<p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p>
<p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p>
<p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p>
<h2 id="11-只在堆上-x2F-栈上创建对象"><a href="#11-只在堆上-x2F-栈上创建对象" class="headerlink" title="11.只在堆上&#x2F;栈上创建对象"></a>11.只在堆上&#x2F;栈上创建对象</h2><ul>
<li><p><strong>只能在堆上生成对象：将析构函数设置为私有</strong> </p>
<ul>
<li><strong>原因：</strong>C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象</li>
</ul>
</li>
<li><p><strong>只能在栈上生成对象：将new 和 delete 重载为私有</strong></p>
<ul>
<li><strong>原因：</strong>在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象</li>
</ul>
</li>
</ul>
<h2 id="12-this指针"><a href="#12-this指针" class="headerlink" title="12.this指针"></a>12.this指针</h2><ul>
<li><p><strong>为什么会有this指针</strong>：</p>
<ul>
<li>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针</li>
</ul>
</li>
<li><p><strong>this指针的作用：</strong></p>
<ul>
<li>this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。this指针指向被调用的成员函数所属的对象（谁调用成员函数，this指向谁），this表示对象本身，<strong>非静态成员函数中才有this，静态成员函数内部没有</strong></li>
</ul>
</li>
<li><p>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）</p>
<ul>
<li>对非静态成员函数默认添加了this指针，类型为classname *const this</li>
<li><strong>this指针只能在成员函数中使用，在全局函数、静态成员函数中不能使用this指针。因此，获得一个对象后，不能通过对象使用this指针，但在成员函数中，可以知道this指针位置，也可以直接使用它</strong></li>
</ul>
</li>
<li><p><strong>this指针使用：</strong></p>
<ul>
<li>当形参与成员变量名相同时，用this指针来区分</li>
<li>为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，&#x2F;*this表示对象本身</li>
</ul>
</li>
<li><p><strong>this指针在成员函数的开始执行前构造，在成员函数的执行结束后清除</strong></p>
</li>
<li><p><strong>this指针会因编译器不同而有不同的放置位置，可能是栈，也可能是寄存器，甚至全局变量</strong></p>
</li>
</ul>
<h2 id="13-delete-this合法吗？"><a href="#13-delete-this合法吗？" class="headerlink" title="13.delete this合法吗？"></a>13.delete this合法吗？</h2><p><strong>合法，但有前提：</strong></p>
<blockquote>
<p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p>
</blockquote>
<ul>
<li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ul>
<p><strong>在类的析构函数中调用delete this会发生什么？</strong></p>
<ul>
<li>会导致堆栈溢出</li>
<li>原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</li>
</ul>
<p><strong>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</strong></p>
<ul>
<li>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中</li>
<li>在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它</li>
<li>当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</li>
</ul>
<h2 id="14-静态成员变量和静态成员函数"><a href="#14-静态成员变量和静态成员函数" class="headerlink" title="14.静态成员变量和静态成员函数"></a>14.静态成员变量和静态成员函数</h2><p>若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。<strong>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区</strong></p>
<ul>
<li><strong>静态成员变量</strong><ul>
<li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）</li>
<li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限</li>
<li>非静态成员类外不能初始化</li>
<li>静态成员数据是共享的</li>
</ul>
</li>
<li><strong>静态成员函数</strong><ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量</li>
<li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针</li>
</ul>
</li>
</ul>
<h2 id="15-静态成员与普通成员的区别"><a href="#15-静态成员与普通成员的区别" class="headerlink" title="15.静态成员与普通成员的区别"></a>15.静态成员与普通成员的区别</h2><ol>
<li><p>生命周期</p>
<ul>
<li>静态成员变量从类被加载开始到类被卸载，一直存在</li>
<li>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束</li>
</ul>
</li>
<li><p>共享方式</p>
<ul>
<li>静态成员变量是全类共享；普通成员变量是每个对象单独享用的</li>
</ul>
</li>
<li><p>定义位置</p>
<ul>
<li>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区</li>
</ul>
</li>
<li><p>初始化位置</p>
<ul>
<li>普通成员变量在类中初始化；静态成员变量在类外初始化</li>
</ul>
</li>
<li><p>默认实参</p>
<ul>
<li>可以使用静态成员变量作为默认实参</li>
</ul>
</li>
</ol>
<h2 id="15-初始化列表的好处和使用条件"><a href="#15-初始化列表的好处和使用条件" class="headerlink" title="15.初始化列表的好处和使用条件"></a>15.初始化列表的好处和使用条件</h2><ul>
<li><p><strong>初始化列表的使用条件</strong></p>
<ul>
<li>const类型的数据</li>
<li>引用类型的数据</li>
</ul>
</li>
<li><p><strong>好处</strong></p>
<ul>
<li>初始化是直接初始化成员</li>
<li>赋值是初始化再赋值</li>
</ul>
</li>
<li><p><strong>不能通过初始化列表初始化静态成员变量</strong>，静态成员变量最好类内声明，类外初始化.静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用域相同的情况下会导致重名的问题</p>
</li>
</ul>
<h2 id="16-运算符重载及-重载实现"><a href="#16-运算符重载及-重载实现" class="headerlink" title="16.运算符重载及++重载实现"></a>16.运算符重载及++重载实现</h2><ul>
<li><p><strong>运算符重载基本属性</strong></p>
<ul>
<li><p>运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型</p>
</li>
<li><p>运算符重载的实质是函数重载，可以重载为普通成员函数，也可以重载为成员函数</p>
</li>
<li><p><strong>运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址</strong></p>
</li>
</ul>
</li>
<li><p><strong>运算符重载总结</strong></p>
<ul>
<li><p>重载运算符()，[] ，-&gt;， &#x3D;的时候，运算符重载函数必须声明为类的成员函数</p>
</li>
<li><p>重载运算符&lt;&lt;，&gt;&gt;的时候，运算符只能通过全局函数配合友元函数进行重载</p>
</li>
<li><p>不要重载&amp;&amp;和||运算符，因为无法实现短路原则</p>
</li>
</ul>
</li>
<li><p><strong>i++和++i实现</strong></p>
<p>C++内置类型的后置++返回的是变量的拷贝，也就是不可修改的值；前置++返回的是变量的引用，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//++i</span><br><span class="hljs-type">int</span>&amp;  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    *<span class="hljs-keyword">this</span> +=<span class="hljs-number">1</span>；<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>；<br>&#125;<br><br><span class="hljs-comment">//i++，注意后置++有占位参数以区分跟前置++不同</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>    <span class="hljs-type">int</span> oldValue = *<span class="hljs-keyword">this</span>；<br>    ++（*<span class="hljs-keyword">this</span>）；<br>    <span class="hljs-keyword">return</span> oldValue；<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-继承方式、对象模型、同名处理"><a href="#17-继承方式、对象模型、同名处理" class="headerlink" title="17.继承方式、对象模型、同名处理"></a>17.继承方式、对象模型、同名处理</h2><p><strong>继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法</strong></p>
<ul>
<li><p><strong>继承方式</strong></p>
<ul>
<li><p>公有继承：保持父类中的访问属性</p>
</li>
<li><p>私有继承：将父类中的所有访问属性改为private</p>
</li>
<li><p>保护继承：除父类中的私有属性，其他改为保护属性</p>
</li>
</ul>
</li>
<li><p><strong>继承的对象模型</strong></p>
<ul>
<li><p>子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出</p>
</li>
<li><p>子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反</p>
<ul>
<li>由于继承中父类和子类的构造、析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造</li>
</ul>
</li>
<li><p>子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数</p>
</li>
</ul>
</li>
<li><p><strong>继承中的同名处理</strong></p>
<ul>
<li><p>父类和子类<strong>成员属性</strong>同名，用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域</p>
</li>
<li><p>父类和子类<strong>成员函数</strong>同名，子类函数不会覆盖父类的成员，只是隐藏起来，用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域</p>
</li>
<li><p>若子类中没有与父类同名的成员函数，子类声明对象后，可以直接调用父类成员函数</p>
</li>
</ul>
</li>
</ul>
<h2 id="18-多继承、菱形继承、虚继承"><a href="#18-多继承、菱形继承、虚继承" class="headerlink" title="18.多继承、菱形继承、虚继承"></a>18.多继承、菱形继承、虚继承</h2><ul>
<li><strong>多继承</strong></li>
</ul>
<blockquote>
<p>多继承会产生二义性的问题。如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类</p>
</blockquote>
<ul>
<li><strong>菱形继承</strong></li>
</ul>
<blockquote>
<p>两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼</p>
</blockquote>
<ul>
<li><p><strong>菱形继承会产生问题</strong></p>
<ul>
<li><p><strong>浪费空间：</strong>羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可</p>
</li>
<li><p><strong>二义性：</strong>从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题</p>
</li>
<li><p>羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过carmel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致</p>
</li>
</ul>
</li>
<li><p><strong>解决菱形继承的问题</strong></p>
<p><strong>使用虚继承</strong>，在<strong>继承方式前加virtual</strong>，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age</span><br>&#125;<br>- 此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据<br>- Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）<br>- Sheep的虚指针指向下面Sheep的虚基类表<span class="hljs-symbol">vbtale@</span>Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为<span class="hljs-number">20</span>，即Sheep的虚指针地址偏移<span class="hljs-number">20</span>指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素<br>- Son中包含了两个指针和四个<span class="hljs-built_in">int</span>类型，所以大小为<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>虚继承概述</strong><ul>
<li><p>一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类</p>
</li>
<li><p><strong>每个虚继承的子类（虚基类本身没有）都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），虚基类指针属于对象，虚基类表属于类</strong></p>
</li>
<li><p>当虚继承的子类被当做父类继承时，虚基类指针也会被继承</p>
</li>
<li><p>虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址(虚基类指针)之间的偏移量,以此来访问虚基类数据</p>
</li>
<li><p>虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间</p>
</li>
<li><p>虚基类表本质是一个<strong>整型数组</strong></p>
</li>
<li><p><strong>虚函数属于对象，不属于类，而静态函数属于类</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,</span><br>&#125;<br>- 注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表<br></code></pre></td></tr></table></figure>

<h2 id="19-重载、覆盖、重写的区别"><a href="#19-重载、覆盖、重写的区别" class="headerlink" title="19.重载、覆盖、重写的区别"></a>19.重载、覆盖、重写的区别</h2><ul>
<li><strong>重载(overload)：</strong>是不同函数间的水平关系，函数名相同，参数列表不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载只是在同一个类的内部存在，但是不能靠返回类型来判断</li>
<li><strong>覆盖(override)：</strong>也叫重写，子类重新定义父类中有相同名称和参数的虚函数。两者的函数特征相同<ul>
<li>被重写的函数不能是static的。必须是virtual的</li>
<li>重写函数必须有相同的参数个数，参数类型和返回值类型</li>
<li>重写函数的访问权限可以不同。尽管virtual是private的，子类中重写改写为public,protected也是可以的</li>
</ul>
</li>
<li><strong>隐藏：</strong>子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) <ul>
<li>如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域</li>
</ul>
</li>
</ul>
<h2 id="20-C-将派生类赋值给基类（向上转型）"><a href="#20-C-将派生类赋值给基类（向上转型）" class="headerlink" title="20.C++将派生类赋值给基类（向上转型）"></a>20.C++将派生类赋值给基类（向上转型）</h2><ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2284.html">详解</a></li>
</ul>
<h2 id="21-多态实现的基础"><a href="#21-多态实现的基础" class="headerlink" title="21.多态实现的基础"></a>21.多态实现的基础</h2><ul>
<li><strong>继承</strong></li>
<li><strong>虚函数覆盖</strong></li>
<li><strong>父类指针或引用指向子类对象访问虚函数</strong></li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Animal&#123;<br>public:<br>    virtual  void speak()&#123; <span class="hljs-regexp">//</span>在父类中声明虚函数，可以实现多态，动态联编<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">0</span>;<br>&#125;;<br><br>class Sheep :public Animal&#123;<br>public:<br>    void speak()&#123; <span class="hljs-regexp">//</span>发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sheep speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">1</span>;<br>&#125;;<br><br>void doSpeak(Animal &amp;animal)&#123;<br>    animal.speak();<br>&#125;<br><br>void test01()&#123;<br>    <span class="hljs-regexp">//</span>传入子类对象调用子类成员函数<br>    Sheep sheep;<br>    doSpeak(sheep); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接调用子类成员函数<br>    sheep.speak();  <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象通过作用域调用父类成员函数<br>    sheep.Animal::speak();  <span class="hljs-regexp">//</span>animal speak;<br><br>    <span class="hljs-regexp">//</span>基类成员不能转换为子类成员，即不能向下转换<br>    <span class="hljs-regexp">//</span>Animal *animal0 = new Animal();<br>    <span class="hljs-regexp">//</span>Sheep * sheep0 = animal0;<br>    <span class="hljs-regexp">//</span>sheep0-&gt;speak();<br><br>    <span class="hljs-regexp">//</span>同样不能向下转换<br>    <span class="hljs-regexp">//</span>Animal animal0;<br>    <span class="hljs-regexp">//</span>Sheep sheep0 = animal0;<br><br>    <span class="hljs-regexp">//</span>父类指针指向子类对象<br>    Sheep *sheep1 = new Sheep();<br>    Animal *animal1 = sheep1;<br>    animal1-&gt;speak(); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>父类引用指向子类对象<br>    Sheep sheep2;<br>    Animal &amp;animal2 = sheep2;<br>    animal2.speak();    <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则<br>    Sheep sheep0;<br>    Animal animal0 = sheep0;<br>    animal0.speak();    <span class="hljs-regexp">//</span>animal speak;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>静态多态（运算符重载、函数重载）</strong></li>
<li><strong>动态多态（继承、虚函数）</strong></li>
</ul>
<blockquote>
<p>两者主要的区别：函数地址是早绑定（静态联编）还是晚绑定（动态联编）。即，在编译阶段确定好地址还是在运行时才确定地址</p>
</blockquote>
<h2 id="22-虚函数指针和虚函数表"><a href="#22-虚函数指针和虚函数表" class="headerlink" title="22.虚函数指针和虚函数表"></a>22.虚函数指针和虚函数表</h2><ul>
<li><strong>实现多态的流程：虚函数指针-&gt;虚函数表-&gt;函数指针-&gt;入口地址，虚函数表（vftable）属于类，或者说这个类的所有对象共享一个虚函数表；而虚函数指针（vfptr）属于单个对象</strong><ul>
<li>前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，然后对虚函数重写</li>
<li>虚函数重写（覆盖）的实质就是重写父类虚函数表中的父类虚函数地址</li>
<li><strong>虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序</strong></li>
</ul>
</li>
<li>在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表</li>
<li><strong>编译器根本不会去区别，传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数</strong><ul>
<li>如果是虚函数，就根据不同对象的vptr指针找属于自己的函数：父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数</li>
<li>即：vptr-&gt;虚函数表-&gt;函数的入口地址，从而实现了迟绑定（在运行的时候，才会去判断）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208251546070.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="23-构造函数能否实现多态-x2F-虚函数指针什么时候初始化"><a href="#23-构造函数能否实现多态-x2F-虚函数指针什么时候初始化" class="headerlink" title="23.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化"></a>23.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化</h2><p><strong>两个问题本质是一样的，构造函数不能实现多态</strong></p>
<ul>
<li>对象在创建时，由编译器对VPTR指针进行初始化，只有当对象的构造完全结束后VPTR的指向才最终确定</li>
<li>子类中虚函数指针的初始化过程 当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时Vptr又被赋值指向子类的虚函数表</li>
<li><strong>构造函数不能是虚函数，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针</strong></li>
</ul>
<p><strong>虚函数表创建时机</strong></p>
<ul>
<li>虚函数表创建时机是在编译期间，编译期间编译器就为每个类确定好了对应的虚函数表里的内容</li>
<li>所以在程序运行时，编译器会把虚函数表的首地址赋值给虚函数表指针，所以，这个虚函数表指针就有值了</li>
</ul>
<h2 id="24-基类的虚函数表存放在内存的什么区"><a href="#24-基类的虚函数表存放在内存的什么区" class="headerlink" title="24.基类的虚函数表存放在内存的什么区"></a>24.基类的虚函数表存放在内存的什么区</h2><p><strong>虚函数表的特征：</strong></p>
<ul>
<li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li>
<li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li>
<li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li>
</ul>
<p><strong>根据以上特征，虚函数表类似于类中静态成员变量，静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</strong></p>
<ul>
<li><p>虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别</p>
</li>
<li><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面</p>
</li>
<li><p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区</p>
</li>
<li><p><strong>C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区</strong></p>
</li>
</ul>
<h2 id="25-抽象类和纯虚函数"><a href="#25-抽象类和纯虚函数" class="headerlink" title="25.抽象类和纯虚函数"></a>25.抽象类和纯虚函数</h2><p>在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求</p>
<ul>
<li><strong>纯虚函数的语法格式：<code>virtual 返回值类型 函数名 () = 0;</code>只需要将函数体完全替换为 &#x3D;0即可，纯虚函数必须在子类中进行实现，在子类外实现是无效的</strong></li>
<li>注意<ul>
<li>如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象</li>
<li><strong>如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象，但纯虚析构函数例外，因为子类不会继承父类的析构函数</strong></li>
<li><strong>由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址</strong></li>
</ul>
</li>
</ul>
<h2 id="26-虚析构和纯虚析构"><a href="#26-虚析构和纯虚析构" class="headerlink" title="26.虚析构和纯虚析构"></a>26.虚析构和纯虚析构</h2><ul>
<li><p><strong>内存泄漏：当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</strong></p>
<ul>
<li>仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数-&gt;子类构造函数-&gt;子类析构函数-&gt;父类析构函数</li>
<li>当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，如果父类的析构函数不被声明为虚函数，则编译器实施的是静态绑定。销毁的调用流程为：父类构造函数-&gt;子类构造函数-&gt;父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题</li>
</ul>
</li>
<li><p><strong>内存泄漏的解决方法</strong></p>
<ul>
<li><strong>将父类中的析构函数设置为虚函数，设置后会先调用子类析构函数，再调用父类析构函数</strong></li>
</ul>
</li>
<li><p><strong>纯虚析构</strong></p>
<ul>
<li>纯虚析构需要类内声明，类外实现</li>
<li>纯虚析构也是虚函数，该类也为抽象类</li>
<li><strong>子类不会继承父类的析构函数，当父类纯虚析构没有实现时，子类不是抽象类，可以创建创建对象</strong></li>
<li><strong>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</strong></li>
<li><strong>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数</strong></li>
</ul>
</li>
<li><p><strong>C++默认的析构函数不是虚函数：因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存</strong></p>
</li>
</ul>
<h2 id="27-哪些函数不能是虚函数"><a href="#27-哪些函数不能是虚函数" class="headerlink" title="27.哪些函数不能是虚函数"></a>27.哪些函数不能是虚函数</h2><ol>
<li>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化</li>
<li>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数</li>
<li>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义<ul>
<li>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的</li>
<li>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针</li>
<li>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr</li>
<li>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</li>
</ul>
</li>
<li>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法</li>
<li>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数</li>
</ol>
<h2 id="28-类模版和函数模版"><a href="#28-类模版和函数模版" class="headerlink" title="28.类模版和函数模版"></a>28.类模版和函数模版</h2><p><strong>通过template或template实现，主要用于数据的类型参数化，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的</strong></p>
<ul>
<li><p>类模板和函数模板定义</p>
<ul>
<li><p>template声明下面是函数定义，则为函数模板，否则为类模板</p>
</li>
<li><p>注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板(类模板同理)</p>
</li>
</ul>
</li>
<li><p>类模板与函数模板的区别</p>
<ul>
<li>类模板不支持自动类型推导</li>
<li>数据类型可以有默认参数</li>
</ul>
</li>
</ul>
<h1 id="三、C-高级特性"><a href="#三、C-高级特性" class="headerlink" title="三、C++高级特性"></a>三、C++高级特性</h1><h2 id="1-什么是内存池，如何实现？"><a href="#1-什么是内存池，如何实现？" class="headerlink" title="1.什么是内存池，如何实现？"></a>1.什么是内存池，如何实现？</h2><p><strong>内存池（Memory Pool） 是一种内存分配方式</strong></p>
<ul>
<li>通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用</li>
<li>当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升</li>
</ul>
<p><strong>内存池实现机制：allocate 包装 malloc，deallocate包装free</strong></p>
<ul>
<li><p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小</p>
<ol>
<li><p>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20* 32byte）</p>
</li>
<li><p>客户端之后有有内存需求，想申请（20* 64bytes）的空间，这时内存池只有（20* 32bytes），就先将（10* 64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也</p>
</li>
<li><p>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请</p>
</li>
<li><p>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</p>
</li>
</ol>
</li>
<li><p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了</p>
</li>
<li><p>内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
</li>
</ul>
<h2 id="2-构造函数可以抛出异常吗，有什么问题？"><a href="#2-构造函数可以抛出异常吗，有什么问题？" class="headerlink" title="2.构造函数可以抛出异常吗，有什么问题？"></a>2.构造函数可以抛出异常吗，有什么问题？</h2><p><strong>构造函数中应该避免抛出异常</strong></p>
<ul>
<li><p>构造函数中抛出异常后，对象的析构函数将不会被执行</p>
</li>
<li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露</p>
</li>
<li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构</p>
</li>
</ul>
<h2 id="3-初始化列表的异常怎么捕获？"><a href="#3-初始化列表的异常怎么捕获？" class="headerlink" title="3.初始化列表的异常怎么捕获？"></a>3.初始化列表的异常怎么捕获？</h2><ul>
<li>初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题</li>
<li>函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常</li>
</ul>
<h2 id="4-析构函数可以抛出异常吗，有什么问题？"><a href="#4-析构函数可以抛出异常吗，有什么问题？" class="headerlink" title="4.析构函数可以抛出异常吗，有什么问题？"></a>4.析构函数可以抛出异常吗，有什么问题？</h2><p><strong>析构函数不应该抛出异常</strong></p>
<ul>
<li><p><strong>其他正常，仅析构函数异常</strong>。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题</p>
</li>
<li><p><strong>其他异常，且析构函数异常</strong>。 通常异常发生时，c++的机制会调用已经构造好的对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题</p>
</li>
</ul>
<h2 id="5-析构函数如何处理异常"><a href="#5-析构函数如何处理异常" class="headerlink" title="5.析构函数如何处理异常"></a>5.析构函数如何处理异常</h2><ul>
<li>若析构函数抛出异常，调用std::abort()来终止程序</li>
<li>在析构函数中catch捕获异常并作处理，吞下异常</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中</li>
</ul>
<h2 id="6-CPP11新特性"><a href="#6-CPP11新特性" class="headerlink" title="6.CPP11新特性"></a>6.CPP11新特性</h2><ul>
<li><strong>nullptr常量</strong><ul>
<li>C++中NULL仅仅是define NULL 0 的一个宏定义，因此，有时候会产生歧义<ul>
<li>比如f（char*）和f（int），参数传NULL的话到底该调用哪个？</li>
<li>事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题</li>
</ul>
</li>
<li>nullptr是一个空指针，可以被转换成其他任意指针的类型</li>
</ul>
</li>
<li><strong>auto类型指示符</strong><ul>
<li>让编译器替我们去分析表达式所属的类型，直接推导</li>
<li>尤其是STL中map的迭代器这种很长的类型，适合用auto</li>
</ul>
</li>
<li><strong>decltype类型指示符</strong><ul>
<li>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关</li>
<li><code>delctype (f()) sum = x;</code> 并不实际调用函数f()，只是使用f()的返回值当做sum的类型</li>
<li><code>delctype (i) sum = x;</code>和<code>delctype ((i)) sum = x;</code> 其中i为int类型，前面的为int类型，后面的为int&amp;引用</li>
</ul>
</li>
<li><strong>范围for语句</strong><ul>
<li>多与auto配合使用</li>
</ul>
</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">string <span class="hljs-built_in">str</span>(&quot;somthing&quot;);<br><span class="hljs-built_in">for</span>(auto i:str) <span class="hljs-comment">//对于str中的每个字符，i类型为char</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">for</span>(auto &amp;i:str) <span class="hljs-comment">//对于若要改变每个字符的值，需要加引用</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>定义双层vector</strong><ul>
<li><code>vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0))</code> 创建m行n列的二维数组，全部初始化为0</li>
</ul>
</li>
<li><strong>lambda表达式</strong><ul>
<li>用于实现匿名函数，匿名函数只有函数体，没有函数名</li>
</ul>
</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">[capture list] (params list) <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">exception</span><span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//1</span><br>[capture list] (params list) <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//省略mutable，表示const不可修改</span><br>[capture list] (params list) &#123;<span class="hljs-keyword">function</span> body&#125;;       <span class="hljs-comment">//省略返回类型，按照函数体返回值决定返回类型</span><br>[capture list] &#123;<span class="hljs-keyword">function</span> body&#125;;     <span class="hljs-comment">//省略参数列表，无参函数</span><br>参数capture list：捕获外部变量列表 <br>params list：形参列表 <br><span class="hljs-keyword">mutable</span>指示符：用来说用是否可以修改捕获的变量 <br><span class="hljs-keyword">exception</span>：异常设定 <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>：返回类型 <br><span class="hljs-keyword">function</span> body：函数体			<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//示例</span><br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">(vec.begin()</span></span>, vec<span class="hljs-selector-class">.end</span>(), <span class="hljs-selector-attr">[]</span>(int <span class="hljs-selector-tag">a</span>, int b)-&gt;bool&#123;return <span class="hljs-selector-tag">a</span> &lt; b&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>智能指针</strong><ul>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>unique_ptr</li>
</ul>
</li>
<li><strong>右值引用</strong><ul>
<li>左值引用，必须引用左值 <code>int a = 0; int &amp;b = a</code></li>
<li>右值引用可以引用结果 <code>int &amp;&amp; i = 0</code></li>
</ul>
</li>
</ul>
<h2 id="7-auto、decltype的用法"><a href="#7-auto、decltype的用法" class="headerlink" title="7.auto、decltype的用法"></a>7.auto、decltype的用法</h2><p><strong>1）auto</strong></p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p>
<p>举个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//普通；类型</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">auto</span> c = a + b;<span class="hljs-comment">// c为int型</span><br><br><span class="hljs-comment">//const类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">auto</span> j = i; <span class="hljs-comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="hljs-built_in">auto</span> k = &amp;i; <span class="hljs-comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">auto</span> l = i; <span class="hljs-comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><br><span class="hljs-comment">//引用和指针类型</span><br><span class="hljs-built_in">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span>&amp; y = x;<br><span class="hljs-built_in">auto</span> z = y; <span class="hljs-comment">//z是int型不是int&amp; 型</span><br><span class="hljs-built_in">auto</span>&amp; p1 = y; <span class="hljs-comment">//p1是int&amp;型</span><br><span class="hljs-built_in">auto</span> p2 = &amp;x; <span class="hljs-comment">//p2是指针类型int*</span><br></code></pre></td></tr></table></figure>

<p>2）decltype</p>
<p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">int <span class="hljs-keyword">func</span>() &#123;return <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-regexp">//</span>普通类型<br>decltype(<span class="hljs-keyword">func</span>()) sum = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> sum的类型是函数<span class="hljs-keyword">func</span>()的返回值的类型int, 但是这时不会实际调用函数<span class="hljs-keyword">func</span>()<br>int a = <span class="hljs-number">0</span>;<br>decltype(a) b = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span> a的类型是int, 所以b的类型也是int<br><br><span class="hljs-regexp">//</span>不论是顶层const还是底层const, decltype都会保留   <br>const int c = <span class="hljs-number">3</span>;<br>decltype(c) d = c; <span class="hljs-regexp">//</span> d的类型和c是一样的, 都是顶层const<br>int e = <span class="hljs-number">4</span>;<br>const int* f = &amp;e; <span class="hljs-regexp">//</span> f是底层const<br>decltype(f) g = f; <span class="hljs-regexp">//</span> g也是底层const<br><br><span class="hljs-regexp">//</span>引用与指针类型<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 如果表达式是引用类型, 那么decltype的类型也是引用<br>const int i = <span class="hljs-number">3</span>, &amp;j = i;<br>decltype(j) k = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> k的类型是 const int&amp;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:<br>int i = <span class="hljs-number">3</span>, &amp;r = i;<br>decltype(r + <span class="hljs-number">0</span>) t = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> 此时是int类型<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>. 对指针的解引用操作返回的是引用类型<br>int i = <span class="hljs-number">3</span>, j = <span class="hljs-number">6</span>, *p = &amp;i;<br>decltype(*p) c = j; <span class="hljs-regexp">//</span> c是int&amp;类型, c和j绑定在一起<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了<br>int i = <span class="hljs-number">3</span>;<br>decltype((i)) j = i; <span class="hljs-regexp">//</span> 此时j的类型是int&amp;类型, j和i绑定在了一起<br></code></pre></td></tr></table></figure>

<h2 id="8-C-中NULL和nullptr的区别"><a href="#8-C-中NULL和nullptr的区别" class="headerlink" title="8.C++中NULL和nullptr的区别"></a>8.C++中NULL和nullptr的区别</h2><ul>
<li>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void)0，而在C++语言中，NULL则被定义为整数0</li>
<li>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误</li>
</ul>
<h2 id="9-智能指针"><a href="#9-智能指针" class="headerlink" title="9.智能指针"></a>9.智能指针</h2><ul>
<li><p><strong>原始指针在引入了异常机制后容易发生内存泄漏、二次释放等问题</strong></p>
</li>
<li><p>C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针</p>
</li>
<li><p><strong>shared_ptr共享的智能指针</strong></p>
<ul>
<li><p><strong>share_ptr的初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br><span class="hljs-comment">// make_shared里面调用了new操作符分配内存</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;	<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>拷贝和赋值：</strong>拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</p>
</li>
<li><p><strong>shared_ptr常用操作</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">make_shared&lt;T&gt;(args) <span class="hljs-comment">// 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</span><br>shared_ptr&lt;T&gt; <span class="hljs-selector-tag">p</span>(q) <span class="hljs-comment">// p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*</span><br><span class="hljs-selector-tag">p</span> = <span class="hljs-selector-tag">q</span> <span class="hljs-comment">// p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.unique</span>() <span class="hljs-comment">// 若p.use_count()为1，返回true；否则返回false</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.use_count</span>() <span class="hljs-comment">// 返回与p共享对象的智能指针数量；可能很慢，主要用于调试</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>shared_ptr的其他方法</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span> () //若<span class="hljs-selector-tag">p</span>是唯一指向其对象的shared_ptr，reset会释放此对象。<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>) //若传递了可选的参数内置指针<span class="hljs-selector-tag">q</span>，会令<span class="hljs-selector-tag">P</span>指向<span class="hljs-selector-tag">q</span>，否则会将<span class="hljs-selector-tag">P</span>置为空。<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>, d) //若还传递了参数d,将会调用d而不是delete 来释放<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>shared_ptr相互引用产生的问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;  <span class="hljs-comment">// Parent类的前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Parent&gt; father;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello Parent&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Child&gt; son;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Parent&gt; <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;  <span class="hljs-comment">// 1  资源A</span><br>    <span class="hljs-function">std::shared_ptr&lt;Child&gt; <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;  <span class="hljs-comment">// 2   资源B</span><br>    parent-&gt;son = child;     <span class="hljs-comment">// 3   child.use_count() == 2 and parent.use_count() == 1 </span><br>    child-&gt;father = parent;  <span class="hljs-comment">// 4   child.use_count() == 2 and parent.use_count() == 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">hello Parent</span><br><span class="hljs-comment">hello child</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>分析：</p>
<ul>
<li>用了shared_ptr管理资源，没有调用 Parent 和 Child 的析构函数，表示资源最后还是没有释放！内存泄漏还是发生了</li>
<li>这种情况就是个死循环，如果资源A的引用计数想变成0，则必须资源B先析构掉（从而析构掉内部管理资源A的共享智能指针），资源B的引用计数想变为0，又得依赖资源A的析构，这样就陷入了一个死循环</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li>将std::shared_ptr<Parent> father改为std::weak_ptr<Parent> father</li>
<li>将std::shared_ptr<Child> son改为std::weak_ptr<Child> son</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>weak_ptr弱引用的智能指针</strong></p>
<ul>
<li><p><strong><code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏</strong></p>
</li>
<li><p>要想解决上面循环引用的问题，只能引入新的智能指针<code>std::weak_ptr</code>。<code>std::weak_ptr</code>有什么特点呢？与<code>std::shared_ptr</code>最大的差别是在初始化的时候，不会引起智能指针计数增加</p>
<ul>
<li><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作，可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加</li>
<li>同样，在<code>weak_ptr</code>析构时也不会导致引用计数的减少，它只是一个静静地观察者。<code>weak_ptr</code>没有重载<code>operator*</code>和<code>-&gt;</code>，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因</li>
<li>如要操作资源，则必须使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象，从而操作资源</li>
</ul>
</li>
<li><p>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// wp弱共享p; p的引用计数未改变</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>weak_ptr常用操作</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">weak_ptr&lt;T&gt; w;	<span class="hljs-regexp">//</span> 空weak_ptr可以指向类型为T的对象<br>weak_ptr&lt;T&gt; w(shared_ptr p);	<span class="hljs-regexp">//</span> 与p指向相同对象的weak_ptr, T必须能转换为sp指向的类型<br>w = p;	<span class="hljs-regexp">//</span> p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象<br>w.reset();	<span class="hljs-regexp">//</span> weak_ptr置为空<br>w.use_count();	<span class="hljs-regexp">//</span> 与w共享对象的shared_ptr的计数<br>w.expired();	<span class="hljs-regexp">//</span> w.use_count()为<span class="hljs-number">0</span>则返回true，否则返回false<br>w.lock();	<span class="hljs-regexp">//</span> w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>unique_ptr的基本使用</strong></p>
<ul>
<li><p><code>unique_ptr</code>相对于其他两个智能指针更加简单，它和<code>shared_ptr</code>使用差不多，但是功能更为单一，它是一个独占型的智能指针，不允许其他的智能指针共享其内部的指针，更像原生的指针（但更为安全，能够自己释放内存）。<strong>unique_ptr禁止复制语义，拷贝构造函数和复制运算符operator&#x3D; 均被标记为 &#x3D;delete，不允许赋值和拷贝操作，只能够移动</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">0</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1; <span class="hljs-comment">// 错误，不能复制</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// 可以移动</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>性能与安全的权衡</strong></p>
<ul>
<li><code>shared_ptr</code>的大小是原始指针的两倍，因为它的内部有一个原始指针指向资源，同时有个指针指向引用计数</li>
<li>引用计数的内存必须动态分配。虽然一点可以使用<code>make_shared()</code>来避免，但也存在一些情况下不能够使用<code>make_shared()</code></li>
<li>增加和减小引用计数必须是原子操作，因为可能会有读写操作在不同的线程中同时发生。比如在一个线程里有一个指向一块资源的<code>shared_ptr</code>可能调用了析构（因此所指向的资源的引用计数减一），同时，在另一线程里，指向相同对象的一个<code>shared_ptr</code>可能执行了拷贝操作（因此，引用计数加一）。原子操作一般会比非原子操作慢。但是为了线程安全，又不得不这么做，这就给单线程使用环境带来了不必要的困扰</li>
</ul>
</li>
</ul>
<h2 id="10-野指针"><a href="#10-野指针" class="headerlink" title="10.野指针"></a>10.野指针</h2><p><strong>野指针指向一个已删除的对象或 申请访问受限内存区域的指针</strong></p>
<p><strong>产生原因：</strong></p>
<ul>
<li>指针变量未初始化</li>
<li>指针释放未置空</li>
<li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</li>
</ul>
<h2 id="11-强制转换"><a href="#11-强制转换" class="headerlink" title="11.强制转换"></a>11.强制转换</h2><p><strong>C++中强制转换为static_cast, dynamic_cast,const_cast, reinterpret_cast</strong></p>
<ul>
<li><strong>static_cast</strong><ul>
<li>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li>
<li>static_cast &lt; type-id &gt; (expression)</li>
<li>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
</li>
</ul>
</li>
<li><strong>dynamic_cast</strong><ul>
<li>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li>
<li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</li>
<li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</li>
<li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</li>
</ul>
</li>
<li><strong>const_cast</strong><ul>
<li>用于删除 const、volatile特性</li>
<li>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
</li>
</ul>
</li>
<li><strong>reinterpret_cast</strong><ul>
<li>reinterpret_cast<type-id> (expression)</li>
<li>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</li>
<li>几乎什么都可以转,不能丢掉 const、volatile特性</li>
</ul>
</li>
</ul>
<h2 id="12-RTTI"><a href="#12-RTTI" class="headerlink" title="12.RTTI"></a>12.RTTI</h2><p><strong>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid</strong></p>
<ul>
<li><p>dynamic_cast 动态类型转换</p>
</li>
<li><p>typeid typeid 运算符允许在运行时确定对象的类型，获取对象的实际类型</p>
</li>
</ul>
<h2 id="13-RAII"><a href="#13-RAII" class="headerlink" title="13.RAII"></a>13.RAII</h2><p><strong>什么是单例</strong></p>
<ul>
<li><p>单例 Singleton 是设计模式的一种，其特点是只提供<strong>唯一</strong>一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例<br>具体运用场景如：</p>
<ol>
<li><p>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动</p>
</li>
<li><p>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取</p>
</li>
</ol>
</li>
</ul>
<p><strong>C++单例的实现</strong></p>
<ul>
<li>全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）</li>
<li>线程安全</li>
<li>禁止赋值和拷贝</li>
<li>用户通过接口获取实例：使用 static 类成员函数</li>
</ul>
<p><strong>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”</strong></p>
<ul>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理</li>
</ul>
<p><strong>RAII的应用场景</strong></p>
<ul>
<li><p>单例模式：实现线程池、数据库连接池</p>
</li>
<li><p>智能指针（懒汉式单例）：不用通过手动 delete来释放内存</p>
</li>
<li><p>互斥锁（懒汉式单例）：在构造函数中锁住了引用传入的mutex (resource acquisition is initialisation)，并且在析构函数中释放锁</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunchaothu/p/10389842.html">详解</a></p>
</li>
</ul>
<h2 id="14-右值引用"><a href="#14-右值引用" class="headerlink" title="14.右值引用"></a>14.右值引用</h2><ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>左值：存储在内存中，有明确存储地址(可寻址)的数据</li>
<li>右值：可以提供数据值的数据(不一定可以寻址，如寄存器中的数据)</li>
</ul>
</li>
<li><p><strong>判断某个表达式是左值还是右值</strong></p>
<ul>
<li>可位于&#x3D;左侧的表达式就是左值；反之，只能位于&#x3D;右侧的表达式就是右值</li>
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值</li>
</ul>
</li>
<li><p><strong>右值引用：</strong></p>
<ul>
<li><strong>右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</strong></li>
<li>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>&amp; b = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//左值引用</span><br><span class="hljs-built_in">int</span>&amp; e = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，左值引用不能使用右值初始化</span><br><span class="hljs-built_in">int</span>&amp;&amp; d = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//错误，右值引用不能使用左值初始化 </span><br><span class="hljs-built_in">int</span>&amp;&amp; a = <span class="hljs-number">10</span>; <span class="hljs-comment">//右值引用</span><br><span class="hljs-built_in">int</span>&amp;&amp; c = <span class="hljs-built_in">num</span> + <span class="hljs-number">40</span>; <span class="hljs-comment">//右值引用</span><br>a = <span class="hljs-number">100</span>; <span class="hljs-comment">//右值引用可以对右值进行修改</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>右值引用的特点</strong></p>
<ul>
<li>通过右值引用的声明，右值的生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值变量将会一直存活下去</li>
</ul>
</li>
<li><p><strong>移动语义</strong></p>
<ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>即从右值中直接拿数据过来初始化或修改左值，而不需要重新构造一个临时左值后再析构右值，减少了两个对象交互时不必要的拷贝构造</li>
<li>move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去</li>
</ul>
</li>
<li><p><strong>可解决的问题：</strong></p>
<ul>
<li>用右值参数</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//在实现转移语义之前</span><br><span class="hljs-comment">//const &amp;的形参接收了右值参数，但是调用了额外的拷贝构造函数，生成了一个临时变量，销毁临时变量还调用了一次析构函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//在实现转移语义之后</span><br><span class="hljs-comment">//会调用1次移动构造函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br>MyString(MsString &amp;&amp; <span class="hljs-built_in">str</span>)&#123;<br>	<span class="hljs-variable">_len</span> = <span class="hljs-built_in">str</span>.len;<br>	<span class="hljs-variable">_data</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span>;	<span class="hljs-comment">//从右值中获取数据</span><br>	<span class="hljs-built_in">str</span>.len = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> = NULL;	<span class="hljs-comment">//销毁右值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对象存入容器<ul>
<li>void push_back(const T&amp; value)</li>
<li>void push_back(T &amp;&amp; value)</li>
<li>使用push_back()需要调用拷贝构造函数和移动构造函数</li>
<li>而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造函数和移动构造函数，效率更高</li>
</ul>
</li>
<li>vector增长扩容<ul>
<li>移动语义之前是复制并删除，之后只需要移动即可</li>
<li>vector添加元素在空间不够的时候需要重新分配，此时对于原来已有的元素会调用对象类的move constructor，而如果对象类没有定义移动构造，则会使用copy constructor</li>
<li>所以给类添加移动构造函数可以在很多时候提高效率，因为没有它只能用拷贝构造来替代，而编译器又不会自动合成一个</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::move函数</strong></p>
<ul>
<li><p>将左值转变为右值</p>
</li>
<li><p>只有右值引用的类型在后面加上&amp;&amp;仍然是右值引用</p>
</li>
<li><p>其余的在后面加&amp;或者&amp;&amp;都是左值引用</p>
</li>
<li><p>应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化</p>
</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">string</span> s(<span class="hljs-string">&quot;hello&quot;</span>);<br>std::move(s) =&gt; std::move(<span class="hljs-keyword">string</span>&amp; &amp;&amp;) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp;)<br>此时：T的类型为<span class="hljs-keyword">string</span>&amp;<br>	remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例化如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp; t) <span class="hljs-comment">//t为左值，移动后不能在使用t</span><br>&#123;<br>    <span class="hljs-comment">//通过static_cast将string&amp;强制转换为string&amp;&amp;</span><br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir">std::move(<span class="hljs-keyword">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp;&amp;)<br>此时：T的类型为<span class="hljs-keyword">string</span> <br>	remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp;&amp; t) <span class="hljs-comment">//t为右值</span><br>&#123;<br>	<span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t);  <span class="hljs-comment">//返回一个右值引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>完美转发</strong></p>
<ul>
<li>定义：<ul>
<li>在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征）， 将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发</li>
<li>过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义)</li>
</ul>
</li>
<li>使用场景：<ul>
<li>需要将一组参数原封不动地传递给另一个函数，左值&#x2F;右值、const&#x2F;non-const属性在传递过程中不能改变</li>
</ul>
</li>
<li>使用方法：<ul>
<li>在模板参数列表中使用T&amp;&amp;（通用引用）</li>
<li>使用std::forward()转发变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="15-无锁队列"><a href="#15-无锁队列" class="headerlink" title="15.无锁队列"></a>15.无锁队列</h2><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/quantfabric/2588193">C++性能优化-无锁队列</a></p>
<h1 id="四、STL模板库"><a href="#四、STL模板库" class="headerlink" title="四、STL模板库"></a>四、STL模板库</h1><h2 id="1-STL中的swap函数"><a href="#1-STL中的swap函数" class="headerlink" title="1.STL中的swap函数"></a>1.STL中的swap函数</h2><ul>
<li>除了数组，其他容器在交换后本质上是将内存地址进行了交换，而元素本身在内存中的位置是没有变化</li>
<li>swap在交换的时候并不是完全将2个容器的元素互换，而是交换了2个容器内的内存地址</li>
</ul>
<h2 id="2-STL中的哈希表扩容"><a href="#2-STL中的哈希表扩容" class="headerlink" title="2.STL中的哈希表扩容"></a>2.STL中的哈希表扩容</h2><ul>
<li><strong>哈希表概述</strong><ul>
<li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预</li>
<li><strong>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</strong></li>
</ul>
</li>
<li><strong>哈希表扩容</strong><ul>
<li>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置</li>
<li><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>这里需要知道STL中的swap底层，其实扩容也是vector扩容<ul>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到sqrt(n)范围内的数) </li>
<li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换两个桶的地址)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-STL迭代器失效的几种情况总结"><a href="#3-STL迭代器失效的几种情况总结" class="headerlink" title="3.STL迭代器失效的几种情况总结"></a>3.STL迭代器失效的几种情况总结</h2><ul>
<li><p><strong>迭代器的失效问题：</strong>对容器的操作影响了元素的存放位置，称为迭代器失效</p>
</li>
<li><p><strong>失效情况</strong></p>
<ul>
<li>当容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li>
<li>当容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li>
<li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了</li>
</ul>
</li>
<li><p><strong>序列式容器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	vector&lt;<span class="hljs-type">int</span>&gt; q&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br>	<span class="hljs-comment">// 在这里想把大于2的元素都删除</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br>		<span class="hljs-keyword">if</span> (*it &gt; <span class="hljs-number">2</span>)<br>			q.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 这里就会发生迭代器失效</span><br>	&#125;<br>	<span class="hljs-comment">// 打印结果</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br>		cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	cout &lt;&lt; endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>迭代器失效的原因是：因为 vetor、deque 使用了连续分配的内存，<code>erase</code>操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效</p>
</li>
<li><p>解决方法是利用<code>erase</code>方法可以返回下一个有效的 iterator，所以代码做如下修改即可：</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在这里想把大于<span class="hljs-number">2</span>的元素都删除<br><span class="hljs-keyword">for</span>(auto it=q.begin();it!=q.end();)<br>&#123;<br>    <span class="hljs-keyword">if</span>(*it&gt;<span class="hljs-number">2</span>)<br>    &#123;<br>    	it=q.erase(it); <span class="hljs-regexp">//</span> 这里会返回指向下一个元素的迭代器，因此不需要再自加了<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    	it++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>链表式容器</strong></p>
<ul>
<li>对于链表式容器(如 list)，删除当前的 iterator，仅仅会使当前的 iterator 失效，这是因为 list 之类的容器，<strong>使用了链表来实现，插入、删除一个结点不会对其他结点造成影响</strong></li>
<li>只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator</li>
</ul>
<p><strong>方式一：递增当前 iterator</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); it != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*iter)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      cont.<span class="hljs-built_in">erase</span>(iter++);<br>   <span class="hljs-keyword">else</span><br>      iter++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方式二：通过 erase 获得下一个有效的 iterator</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); iter != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*it)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      iter = cont.<span class="hljs-built_in">erase</span>(iter);  <span class="hljs-comment">//erase删除元素，返回下一个迭代器</span><br>   <span class="hljs-keyword">else</span><br>      ++iter;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>关联式容器</strong></p>
<ul>
<li>对于关联容器(如 map, set,multimap,multiset)，删除当前的 iterator，仅仅会使当前的 iterator 失效，只要在 erase 时，递增当前 iterator 即可</li>
<li>这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响</li>
<li><strong>erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以只能采用<code>erase(iter++)</code>的方式删除迭代器</strong></li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">for</span> (iter = dataMap.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; iter != dataMap.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; )<br>&#123;<br>         <span class="hljs-built_in">int</span> nKey = iter-&gt;first;<br>         <span class="hljs-built_in">string</span> strValue = iter-&gt;second;<br><br>         <span class="hljs-keyword">if</span> (nKey % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>         &#123;<br>               dataMap.erase(iter++);<br>               auto a = iter;<br>         &#125;<span class="hljs-keyword">else</span><br>     		 &#123;<br>          iter++;<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>dataMap.erase(iter++); <strong>这句话分三步走，先把 iter 传值到 erase 里面，然后 iter 自增，然后执行 erase，所以 iter 在失效前已经自增了</strong></li>
<li>map 是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系</li>
</ul>
</li>
</ul>
<h2 id="4-迭代器：-it、it-哪个好，为什么"><a href="#4-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.迭代器：++it、it++哪个好，为什么"></a>4.迭代器：++it、it++哪个好，为什么</h2><ol>
<li>前置返回一个引用，后置返回一个对象</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span> <span class="hljs-comment">// ++i实现代码为：</span><br>int&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>  *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br></code></pre></td></tr></table></figure>

<ol start="2">
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2.</span> <span class="hljs-comment">//i++实现代码为：                 </span><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)                 <br>&#123;<br>   <span class="hljs-type">int</span> temp = *<span class="hljs-keyword">this</span>;                   <br>   ++*<span class="hljs-keyword">this</span>;                       <br>   <span class="hljs-keyword">return</span> temp;                  <br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="5-STL中的二级空间配置器"><a href="#5-STL中的二级空间配置器" class="headerlink" title="5.STL中的二级空间配置器"></a>5.STL中的二级空间配置器</h2><p><strong>为什么需要二级空间配置器：</strong></p>
<ul>
<li><p>我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间</p>
</li>
<li><p>每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率</p>
</li>
<li><p>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，当开辟内存&lt;&#x3D;128bytes时，即视为开辟小块内存，则调用二级空间配置器</p>
</li>
<li><p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认选择的为二级空间配置器。 如果大于128字节再转去一级配置器器</p>
</li>
</ul>
<p><strong>一级配置器</strong></p>
<ul>
<li><p>一级空间配置器中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：</p>
<p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p>
<p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p>
<p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208202051612.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>二级配置器</strong></p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208202052325.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><p>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p>
</li>
<li><p>对应的free_list为空，先看其内存池是不是空时，如果内存池不为空： </p>
<p>（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出</p>
<p>（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中</p>
<p>（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。 3、内存池为空，申请内存 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中</p>
<p>（4）malloc没有成功 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了</p>
</li>
<li><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p>
</li>
</ul>
<p><strong>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</strong></p>
<ol>
<li><p>因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p>
</li>
<li><p>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器</li>
<li>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块</li>
<li>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空</li>
<li>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存</li>
</ul>
<h2 id="6-vector中resize-和reserve-的区别"><a href="#6-vector中resize-和reserve-的区别" class="headerlink" title="6.vector中resize()和reserve()的区别"></a>6.vector中resize()和reserve()的区别</h2><p><strong>一、reserve()避免多次不必要的扩容</strong></p>
<ul>
<li>capacity()：告诉我们当前 vector 容器总共可以容纳多少个元素。如果想知道当前 vector 容器有多少未被使用的存储空间，可以通过 capacity()-size() 得知。注意，如果 size() 和 capacity() 返回的值相同，则表明当前 vector 容器中没有可用存储空间了，这意味着，下一次向 vector 容器中添加新元素，将导致 vector 容器扩容</li>
<li>size()：告诉我们当前 vector 容器中已经存有多少个元素，但仅通过此方法，无法得知 vector 容器有多少存储空间</li>
<li>reserve(n)：强制 vector 容器的容量至少为 n。注意，如果 n 比当前 vector 容器的容量小，则该方法什么也不会做；反之如果 n 比当前 vector 容器的容量大，则 vector 容器就会扩容</li>
<li><strong>reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素</strong><ul>
<li><strong>如果n大于vector当前的容量，reserve才会对vector进行扩容，不同的编译器实现的扩容方式不一样，VS2015为1.5倍扩容，GCC以2倍扩容</strong></li>
<li><strong>其他情况下都不会重新分配vector的存储空间</strong></li>
<li>reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()&#x2F;insert()函数</li>
<li>reserve()函数预分配出的空间没有被初始化，所以不可访问</li>
<li><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/JMW1407/article/details/108166322">vector如何避免不必要的扩容</a></strong></li>
</ul>
</li>
</ul>
<p><strong>二、resize()是改变容器的大小，且创建对象</strong></p>
<ul>
<li><p><strong>使用</strong></p>
<ul>
<li>resize(n) <ul>
<li>调整容器的长度大小，使其能容纳n个元素。如果n小于容器的当前的size，则删除多出来的元素。否则，添加采用值初始化的元素</li>
</ul>
</li>
<li>resize(n，t)<ul>
<li>多一个参数t，将所有新添加的元素初始化为t</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征</strong></p>
<ul>
<li>resize()函数和容器的size息息相关。调用resize(n)后，容器的size即为n。至于是否影响capacity，取决于调整后的容器的size是否大于capacity<ul>
<li>比原来的变小之后，后面的会被截断</li>
<li>比原来的变大之后，后面的会被填充新的东西，不同的编译器可能会不同。也可以自己指定后面填充的内容</li>
</ul>
</li>
<li>resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再调用push_back()函数，是加在这个新的空间后面的。</li>
</ul>
</li>
</ul>
<p><strong>三、resize()和reserve()区别</strong></p>
<ul>
<li>vector的reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size</li>
<li>reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()&#x2F;insert()函数</li>
<li>resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再调用push_back()函数，是加在这个新的空间后面的</li>
<li>两个函数的参数形式也有区别的，reserve函数之后一个参数，即需要预留的容器的空间；resize函数可以有两个参数，第一个参数是容器新的大小，第二个参数是要加入容器中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数</li>
</ul>
<h2 id="7-vector中push-back-时间复杂度"><a href="#7-vector中push-back-时间复杂度" class="headerlink" title="7.vector中push_back()时间复杂度"></a>7.vector中push_back()时间复杂度</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6901.html">C++ vector（STL vector）底层实现机制</a></p>
<ul>
<li><p><strong>实现过程：</strong></p>
<ul>
<li><p>该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 <strong>finish</strong>，使 <strong>vector</strong>变大。如果没有备用空间了，就扩充空间，重新配置、移动数据，释放原空间</p>
</li>
<li><p>其中判断是否有备用空间,就是判断  <strong>finish</strong>是否与 <strong>end_of_storage</strong> 相等。如果 <strong>finish !&#x3D; end_of_storage</strong>，说明还有备用空间，否则已无备用空间</p>
</li>
<li><p>当执行 <strong>push_back</strong> 操作，该 <strong>vector</strong> 需要分配更多空间时，它的容量(<strong>capacity</strong>)会增大到原来的 <strong>m</strong> 倍。现在我们来<strong>均摊分析方法</strong>来计算 <strong>push_back</strong> 操作的时间复杂度</p>
</li>
<li><p>假定有 <strong>n</strong> 个元素,倍增因子为 <strong>m。</strong>那么完成这 <strong>n</strong> 个元素往一个 <strong>vector</strong> 中的<strong>push_back</strong>操作，需要重新分配内存的次数大约为 <strong>logm(n)<strong>，第 <strong>i</strong> 次重新分配将会导致复制 <strong>m^i</strong> (也就是当前的</strong>vector.size()</strong> 大小)个旧空间中元素，因此 <strong>n</strong> 次 <strong>push_back</strong>操作所花费的总时间约为 <strong>n*m&#x2F;(m - 1)</strong>:</p>
<p><a target="_blank" rel="noopener" href="http://photo.blog.sina.com.cn/showpic.html#blogid=&url=http://album.sina.com.cn/pic/002YFX8Agy719PTVHqZ3d"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202208291549311.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
</li>
<li><p><strong>时间复杂度计算：</strong></p>
<ul>
<li><strong>很明显这是一个等比数列。那么 n 个元素，n 次操作，每一次操作需要花费时间为 m &#x2F; (m - 1)，这是一个常量</strong></li>
<li>所以，我们采用<strong>均摊分析</strong>的方法可知，<strong>vector</strong> 中 <strong>push_back</strong> 操作的时间复杂度为常量时间</li>
</ul>
</li>
</ul>
<h2 id="8-红黑树原理"><a href="#8-红黑树原理" class="headerlink" title="8.红黑树原理"></a>8.红黑树原理</h2><h3 id="8-1-二叉查找树"><a href="#8-1-二叉查找树" class="headerlink" title="8.1.二叉查找树"></a>8.1.二叉查找树</h3><p><strong>删除某节点</strong></p>
<p>假设要删除的为节点 p，则对于二叉查找树来说，需要根据节点 p 所在不同的位置作不同的操作，有以下 3 种可能</p>
<ol>
<li><p>节点 p 为叶子节点，此时只需要删除该节点，并修改其双亲节点的指针即可；</p>
</li>
<li><p>节点 p 只有左子树或者只有右子树，此时只需要将其左子树或者右子树直接变为节点 p 双亲节点的左子树即可；</p>
</li>
<li><p>节点 p 左右子树都有，此时有两种处理方式：</p>
<p>1）令节点 p 的左子树为其双亲节点的左子树；节点 p 的右子树为其自身直接前驱节点的右子树，如图1所示</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204011124009.png" srcset="/img/loading.gif" lazyload alt="图1"></p>
<p align='center'>图1</p>

<ol start="2">
<li>用节点 p 的直接前驱（或直接后继）来代替节点 p，同时在二叉查找树中对其直接前驱（或直接后继）做删除操作。如图2为使用直接前驱代替节点 p</li>
</ol>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339227.png" srcset="/img/loading.gif" lazyload alt="图2"></p>
<p align='center'>图2</p></li>
</ol>
<h3 id="8-2-红黑树"><a href="#8-2-红黑树" class="headerlink" title="8.2.红黑树"></a>8.2.红黑树</h3><p>红黑树本身就是一颗<strong>二叉查找树</strong>，树中没有一条路径比其他任何路径长出两倍，接近平衡状态。</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031339243.png" srcset="/img/loading.gif" lazyload alt="红黑树"></p>
<ul>
<li><p>每个节点是黑色或者红色</p>
</li>
<li><p>根节点是黑色</p>
</li>
<li><p>所有nil叶子节点为黑色</p>
</li>
<li><p>红色节点的两个孩子节点均为黑色 </p>
</li>
<li><p>对于任一节点而言，其到叶节点树尾端nil指针的每一条路径都包含相同数目的黑节点</p>
</li>
<li><p>一颗含有n个节点的红黑树的高度至多为2log(n+1)</p>
</li>
<li><p>节点的黑高度：从该节点到其子孙节点路径中包含的黑节点数</p>
</li>
<li><p>红黑树是相对接近平衡的二叉树，在二叉查找树的基础上增加了自动维持平衡的性质，插入、搜索、删除的效率都比较高</p>
</li>
</ul>
<blockquote>
<p>正是因为上述性质，使得一颗n个节点的红黑树始终保持logn的高度</p>
</blockquote>
<h4 id="8-2-1红黑树的旋转"><a href="#8-2-1红黑树的旋转" class="headerlink" title="8.2.1红黑树的旋转"></a>8.2.1红黑树的旋转</h4><p>当使用红黑树进行插入或者删除节点的操作时，可能会破坏红黑树的 5 条性质，从而变成了一棵普通树，此时就可以通过对树中的某些子树进行旋转，从而使整棵树重新变为一棵红黑树。</p>
<p>旋转操作分为左旋和右旋，同二叉排序树转平衡二叉树的旋转原理完全相同。例如图3表示的是对一棵二叉查找树中局部子树进行左旋和右旋操作：</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350020.png" srcset="/img/loading.gif" lazyload alt="图3"></p>
<p align='center'>图3</p>

<ul>
<li><p><strong>左旋</strong>：如图3所示，左旋时 y 节点变为该部分子树的根节点，同时 x 节点（连同其左子树 a）移动至 y 节点的左孩子。若 y 节点有左孩子 b，由于 x 节点需占用其位置，所以调整至 x 节点的右孩子处</p>
</li>
<li><p><strong>右旋</strong>：如图3所示，同左旋是同样的道理，x 节点变为根节点，同时 y 节点连同其右子树 c 作为 x 节点的右子树，原 x 节点的右子树 b 变为 y 节点的左子树</p>
</li>
</ul>
<h4 id="8-2-2红黑树的插入新节点"><a href="#8-2-2红黑树的插入新节点" class="headerlink" title="8.2.2红黑树的插入新节点"></a>8.2.2红黑树的插入新节点</h4><p><strong>当创建一个红黑树或者向已有红黑树中插入新的数据时，只需要按部就班地执行以下 3 步：</strong></p>
<p>​	一、由于红黑树本身是一棵二叉查找树，所以在插入新的节点时，完全按照二叉查找树插入节点的方法，找到新节点插入的位置</p>
<p>​	二、将新插入的节点节点初始化，颜色设置为红色后插入到指定位置；（将新节点初始化为红色插入后，不会破坏红黑树第 5 条的性质）</p>
<p>​	三、由于插入新的节点，可能会破坏红黑树第 4 条的性质（若其父节点颜色为红色，就破坏了红黑树的性质），此时需要调整二叉查找树，想办法通过旋转以及修改树中节点的颜色，使其重新成为红黑树</p>
<p><strong>插入节点的第 1 步和第 2 步都非常简单，关键在于最后一步对树的调整！在红黑树中插入节点时，根据插入位置的不同可分为以下 3 种情况：</strong></p>
<ol>
<li><p>插入位置为整棵树的树根。处理办法：只需要将插入节点的颜色改为黑色即可。</p>
</li>
<li><p>插入位置的双亲节点的颜色为黑色。处理方法：此种情况不需要做任何工作，新插入的颜色为红色的节点不会破坏红黑树的性质。</p>
</li>
<li><p><strong>插入位置的双亲节点的颜色为红色。处理方法：由于插入节点颜色为红色，其双亲节点也为红色，破坏了红黑树第 4 条性质，此时需要结合其祖父节点和祖父节点的另一个孩子节点（父节点的兄弟节点，此处称为“叔叔节点”）的状态，分为 3 种情况讨论:</strong></p>
<ul>
<li><p>一、当前节点的父节点是红色，且“叔叔节点”也是红色：破坏了红黑树的第 4 条性质，解决方案为：将父节点颜色改为黑色；将叔叔节点颜色改为黑色；将祖父节点颜色改为红色；下一步将祖父节点认做当前节点，继续判断，处理结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031350203.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><strong>分析</strong>：此种情况下，由于父节点和当前节点颜色都是红色，所以为了不产生冲突，将父节点的颜色改为黑色。但是虽避免了破坏第 4 条，但是却导致该条路径上的黑高度增加了 1 ，破坏了第 5 条性质。但是在将祖父节点颜色改为红色、叔叔节点颜色改为黑色后，该部分子树没有破坏第 5 条性质。但是由于将祖父节点的颜色改变，还需判断是否破坏了上层树的结构，所以需要将祖父节点看做当前节点，继续判断。</p>
<ul>
<li><p>二、当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的右孩子。解决方案：将父节点作为当前节点做左旋操作。</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356676.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><strong>分析</strong>：在进行以父节点为当前节点的左旋操作后，此种情况就转变成了第 3 种情况，处理过程跟第 3 种情况同步进行。</p>
<ul>
<li><p>三、当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的左孩子。解决方案：将父节点颜色改为黑色，祖父节点颜色改为红色，从祖父节点处进行右旋处理。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356010.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><strong>分析</strong>：在此种情况下，由于当前节点 F 和父节点 S 颜色都为红色，违背了红黑树的性质 4，此时可以将 S 颜色改为黑色，有违反了性质 5，因为所有 通过 S 的路径其黑高度都增加了 1 ，所以需要将其祖父节点颜色设为红色后紧接一个右旋，这样这部分子树有成为了红黑树。（上图中的右图虽看似不是红黑树，但是只是整棵树的一部分，以 S 为根节点的子树一定是一棵红黑树）</p>
</li>
</ol>
<h4 id="8-2-3红黑树删除节点"><a href="#8-2-3红黑树删除节点" class="headerlink" title="8.2.3红黑树删除节点"></a>8.2.3红黑树删除节点</h4><p>在二叉查找树删除节点时，分为 3 种情况：</p>
<ol>
<li><p>若该删除节点本身是叶子节点，则可以直接删除；</p>
</li>
<li><p>若只有一个孩子节点（左孩子或者右孩子），则直接让其孩子节点顶替该删除节点；</p>
</li>
<li><p>若有两个孩子节点，则找到该节点的右子树中值最小的叶子节点来顶替该节点，然后删除这个值最小的叶子节点。</p>
</li>
</ol>
<hr>
<p>在红黑树中删除节点，思路更简单，只需要完成 2 步操作：</p>
<ol>
<li>将红黑树按照二叉查找树删除节点的方法删除指定节点；</li>
<li>重新调整删除节点后的树，使之重新成为红黑树；（还是通过旋转和重新着色的方式进行调整）</li>
</ol>
<hr>
<p><strong>以上情况最终都需要删除某个节点，此时需要判断删除该节点是否会破坏红黑树的性质。判断的依据是：</strong></p>
<ol>
<li><p>如果删除节点的颜色为红色，则不会破坏；</p>
</li>
<li><p><strong>如果删除节点的颜色为黑色，则肯定会破坏红黑树的第 5 条性质，此时就需要对树进行调整，调整方案分 4 种情况讨论：</strong></p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202204031356849.png" srcset="/img/loading.gif" lazyload></p>
<p>1） 删除节点的兄弟节点颜色是红色，调整措施为：将兄弟节点颜色改为黑色，父亲节点改为红色，以父亲节点来进行左旋操作，同时更新删除节点的兄弟节	   点（左旋后兄弟节点发生了变化），如下图所示</p>
<p>2） 删除节点的兄弟节点及其孩子全部都是黑色的，调整措施为：将删除节点的兄弟节点设为红色，同时设置删除节点的父节点标记为新的节点，继续判断</p>
<p>3） 删除节点的兄弟节点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟节点设为红色，兄弟节点的左孩子节点设为黑色，以兄弟节点为准进	   行右旋操作，最终更新删除节点的兄弟节点；</p>
<p>4） 删除节点的兄弟节点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除节点的父节点的颜色赋值给其兄弟节点，然后再设置父节	   点颜色为黑色，兄弟节点的右孩子节点为黑色，根据其父节点做左旋操作，最后设置替换删除节点的节点为根节点；</p>
</li>
</ol>
<h3 id="8-3-红黑树的应用"><a href="#8-3-红黑树的应用" class="headerlink" title="8.3.红黑树的应用"></a>8.3.红黑树的应用</h3><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。<br><strong>例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的，而 JDK8 中 HashMap 当链表长度大于 8 时也会转化为红黑树</strong></p>
<h3 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4.总结"></a>8.4.总结</h3><ul>
<li><p>红黑树，虽隶属于二叉查找树，但是二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为<code>O(lgn)</code>。当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高</p>
</li>
<li><p>同平衡二叉树相比较，红黑树没有像平衡二叉树对平衡性要求的那么苛刻，虽然两者的时间复杂度相同，但是红黑树在实际测算中的速度要更胜一筹！平衡二叉树的时间复杂度是<code>O(logn)</code>，红黑树的时间复杂度为<code>O(lgn)</code>，两者都表示的都是时间复杂度为对数关系（lg 函数为底是 10 的对数，用于表示时间复杂度时可以忽略）</p>
</li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PersonalSummary/">#PersonalSummary</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++面经-个人总结</div>
      <div>http://example.com/2022/07/09/C++-面经-个人总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fyy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/09/Mysql%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="Mysql面经-个人总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql面经-个人总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="计算机网络面经-个人总结">
                        <span class="hidden-mobile">计算机网络面经-个人总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
