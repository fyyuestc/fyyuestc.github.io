

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fyy">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、C++基础1.数组和指针的区别 概念不同  指针相当于一个变量，它存放的是数据在内存中的地址 数组是用于储存多个相同类型数据的集合   赋值不同  同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝   访问数据不同  指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容 数组是直接访问   sizeof意义不同  数组所占存储空间的内存：sizeof（数组名）">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面经-个人总结">
<meta property="og:url" content="http://example.com/2022/07/09/C++-%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="UESTC-Fyy">
<meta property="og:description" content="一、C++基础1.数组和指针的区别 概念不同  指针相当于一个变量，它存放的是数据在内存中的地址 数组是用于储存多个相同类型数据的集合   赋值不同  同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝   访问数据不同  指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容 数组是直接访问   sizeof意义不同  数组所占存储空间的内存：sizeof（数组名）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png">
<meta property="og:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png">
<meta property="article:published_time" content="2022-07-09T07:15:45.000Z">
<meta property="article:modified_time" content="2022-08-10T06:45:24.409Z">
<meta property="article:author" content="Fyy">
<meta property="article:tag" content="PersonalSummary">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png">
  
  
  <title>C++面经-个人总结 - UESTC-Fyy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DKnIWAmLCrVnCLIBVwd8hotg-gzGzoHsz","app_key":"9xmUpEdyRJB2o9bIKREcXk3j","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>UESTC-Fyy-Master</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++面经-个人总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-09 15:15" pubdate>
          2022年7月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          35k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          294 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++面经-个人总结</h1>
            
            <div class="markdown-body">
              
              <h1 id="一、C-基础"><a href="#一、C-基础" class="headerlink" title="一、C++基础"></a>一、C++基础</h1><h2 id="1-数组和指针的区别"><a href="#1-数组和指针的区别" class="headerlink" title="1.数组和指针的区别"></a>1.数组和指针的区别</h2><ul>
<li><strong>概念不同</strong> <ul>
<li>指针相当于一个变量，它存放的是数据在内存中的地址</li>
<li>数组是用于储存多个相同类型数据的集合</li>
</ul>
</li>
<li><strong>赋值不同</strong> <ul>
<li>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li>
</ul>
</li>
<li><strong>访问数据不同</strong> <ul>
<li>指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容</li>
<li>数组是直接访问</li>
</ul>
</li>
<li><strong>sizeof意义不同</strong> <ul>
<li>数组所占存储空间的内存：sizeof（数组名） ,数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） </li>
<li>在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li>
</ul>
</li>
<li><strong>指针和数组名异同</strong> <ul>
<li>指针和数组名都可以表示地址，但指针是变量，可以修改</li>
<li>数组名是常量，不可修改赋值</li>
</ul>
</li>
<li><strong>传参：</strong> 数组传参时会退化成指针 <ul>
<li>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。 </li>
<li>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</li>
</ul>
</li>
</ul>
<h2 id="2-指针数组和数组指针"><a href="#2-指针数组和数组指针" class="headerlink" title="2.指针数组和数组指针"></a>2.指针数组和数组指针</h2><ul>
<li><strong>指针数组：</strong>它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8]<ul>
<li><ol>
<li>优先级问题：[]的优先级比高 </li>
<li>说明arr是一个数组，而int*是数组里面的内容 </li>
<li>这句话的意思就是：arr是一个含有8和int*的数组</li>
</ol>
</li>
</ul>
</li>
<li><strong>数组指针：</strong>它实际上是一个指针，该指针指向一个数组。 int (*arr)[8]<ul>
<li><ol>
<li>由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来 </li>
<li>arr先和*结合，说明p是一个指针变量 </li>
<li>这句话的意思就是：指针arr指向一个大小为8个整型的数组</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="3-字符数组和字符串常量"><a href="#3-字符数组和字符串常量" class="headerlink" title="3.字符数组和字符串常量"></a>3.字符数组和字符串常量</h2><ul>
<li><strong>字符数组：</strong>char arr[] &#x3D; “hello”;<ul>
<li>此处的赋值是将常量区的字符串”hello”拷贝到了堆栈区的数arr的空间了</li>
<li>数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值</li>
<li>另外此时的数组名arr是堆栈区中的”hello”的首地址</li>
</ul>
</li>
<li><strong>字符串常量：</strong>char *arr2 &#x3D; “hello”;<ul>
<li>指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值</li>
</ul>
</li>
</ul>
<h2 id="4-引用和指针的区别"><a href="#4-引用和指针的区别" class="headerlink" title="4.引用和指针的区别"></a>4.引用和指针的区别</h2><ul>
<li><strong>指针有内存分配，而引用只是一个别名</strong> <ul>
<li>引用声明时必须初始化，从而指向一个已经存在的对象</li>
</ul>
</li>
<li><strong>引用可以看做常量指针，指针是一个存储地址的变量</strong> <ul>
<li>指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变</li>
<li>这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变</li>
</ul>
</li>
<li><strong>引用创建时必须初始化，且不为空，指针创建时可以为空</strong> <ul>
<li>不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高</li>
<li>因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空</li>
</ul>
</li>
<li><strong>指针和引用的自增运算符意义不同</strong> <ul>
<li>指针是对内存地址的自增，引用是对值的自增</li>
</ul>
</li>
<li><strong>sizeof的意义不同</strong> <ul>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小</li>
</ul>
</li>
<li><strong>没有引用常量，有指针常量</strong> <ul>
<li>没有int&amp; const p,有int* const p. 常量指针和常量引用是存在的，const int *p和cosnt int &amp;p，都表示指向的对象为常量常量引用形参的好处：<ul>
<li>（1）使用引用作为形参，不会产生新的变量，减少形参和实参传递的开销</li>
<li>（2）使用引用可能会导致实参随着形参的改变而改变。声明为const之后就会消除这种副作用</li>
</ul>
</li>
</ul>
</li>
<li><strong>参数传递</strong> <ul>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象</li>
</ul>
</li>
<li><strong>多级指针，一级引用</strong> <ul>
<li>指针可以有多级指针（**p），而引用只有一级</li>
</ul>
</li>
</ul>
<h2 id="5-函数指针与指针函数"><a href="#5-函数指针与指针函数" class="headerlink" title="5.函数指针与指针函数"></a>5.函数指针与指针函数</h2><ul>
<li>指针函数<code>int* f(int x, int y)</code>本质是函数，返回值为指针，函数指针<code>int (*f)(int x)</code>本质是指针，指向函数的指针</li>
<li>通常我们可以将指针指向某类型的变量，称为类型指针（如，整型指针）。若将一个指针指向函数，则称为函数指针</li>
<li>函数名代表函数的入口地址，同样的，我们可以通过根据该地址进行函数调用，而非直接调用函数名</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test001</span>()</span>&#123;<br>    printf(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br>    <span class="hljs-keyword">void</span>(*myfunc)() = test001;<span class="hljs-comment">//将函数写成函数指针</span><br>    myfunc(); <span class="hljs-comment">//调用函数指针 hello world</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>test001的函数名与myfunc函数指针都是一样的，即都是函数指针。test001函数名是一个函数指针常量，而myfunc是一个函数指针变量，这是它们的关系</p>
<ul>
<li>函数指针多用于回调函数，回调函数最大的优势在于灵活操作，可以实现用户定制的函数，降低耦合性，实现多样性，如STL中</li>
</ul>
<h2 id="6-C-中class和struct的区别"><a href="#6-C-中class和struct的区别" class="headerlink" title="6.C++中class和struct的区别"></a>6.C++中class和struct的区别</h2><ul>
<li><p>C中的strcut不能有函数，但C++中可以</p>
</li>
<li><p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它能包含<strong>成员函数，能继承与实现多态</strong></p>
</li>
<li><p><strong>默认的继承访问权限</strong> </p>
<ul>
<li>struct是public的，class是private的 class B : public A就是为了指明是public继承，而不是用默认的private继承，若class B : A则是private继承</li>
</ul>
</li>
<li><p><strong>定义模板参数</strong> </p>
<ul>
<li>class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数</li>
</ul>
</li>
</ul>
<h2 id="7-new-x2F-delete和malloc-x2F-free的区别"><a href="#7-new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="7.new&#x2F;delete和malloc&#x2F;free的区别"></a>7.new&#x2F;delete和malloc&#x2F;free的区别</h2><ul>
<li><p><strong>主要区别</strong></p>
<ul>
<li>calloc在返回指向内存的指针之前把它初始化为0，calloc的参数包括所需的元素的数量和每个元素的字节数</li>
</ul>
</li>
<li><p><strong>属性不同</strong> </p>
<ul>
<li>new&#x2F;delete是C++关键字，需要编译器支持。malloc&#x2F;free是库函数，需要头文件支持C</li>
</ul>
</li>
<li><p><strong>申请的内存所在位置</strong> </p>
<ul>
<li>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存</li>
</ul>
</li>
<li><p>自由存储区是C++的抽象概念，堆是操作系统中的术语，自由存储区可以是堆，也可以是静态存储区，取决于operator new的实现细节</p>
<ul>
<li>基本上所有的C++编译器默认用堆来实现自由存储区，即new运算符会按照malloc的方式来实现</li>
</ul>
</li>
<li><p><strong>返回类型安全性</strong> </p>
<ul>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</li>
<li>malloc内存分配成功则是返回void*类型，需要通过强制类型转换将空类型指针转换成我们需要的类型</li>
</ul>
</li>
<li><p><strong>内存分配失败时的返回值</strong></p>
<ul>
<li>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL</li>
</ul>
</li>
<li><p><strong>是否需要指定内存大小</strong> </p>
<ul>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算<ul>
<li>int *pi&#x3D;new int;	&#x2F;&#x2F;在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi</li>
<li>int *pi&#x3D;new int();	&#x2F;&#x2F;对指针pi指向的地址的值进行了初始化为0 </li>
<li>int *pi&#x3D;new int(1024);	&#x2F;&#x2F;初始化为1024</li>
</ul>
</li>
<li>malloc则需要显式地指出所需内存的大小<ul>
<li>int *p&#x3D;(int *)malloc(100);	&#x2F;&#x2F;指向整型的指针p指向一个大小为100字节的内存的地址 </li>
<li>int *p&#x3D;(int *)malloc(25 * sizeof(int));	&#x2F;&#x2F;指向整型的指针p指向一个25个int整型空间的地址</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数组分配内存（与前一个特点类似）</strong></p>
<ul>
<li>new中分配内存对于变量和数组不同，malloc分配内存则相同 </li>
<li>int *pi&#x3D;new int[];	&#x2F;&#x2F;指针pi所指向的数组未初始化 </li>
<li>int *pi&#x3D;new int[n];	&#x2F;&#x2F;指针pi指向长度为n的数组，未初始化 </li>
<li>int *pi&#x3D;new int;	&#x2F;&#x2F;指针pi所指向的地址初始化为0</li>
</ul>
</li>
<li><p><strong>是否调用构造函数&#x2F;析构函数</strong> </p>
<ul>
<li>new会先调用operator_ new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_ delete函数释放内存（通常底层使用free实现）</li>
<li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作</li>
</ul>
</li>
<li><p><strong>能否重载</strong> </p>
<ul>
<li>opeartor_new&#x2F;operator_delete允许重载,malloc&#x2F;free不允许重载</li>
</ul>
</li>
<li><p><strong>已分配内存的扩充</strong> </p>
<ul>
<li>malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</li>
</ul>
</li>
<li><p><strong>能否相互调用</strong></p>
<ul>
<li>operator_new &#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new</li>
</ul>
</li>
</ul>
<h2 id="8-new-x2F-delete运算符的原理"><a href="#8-new-x2F-delete运算符的原理" class="headerlink" title="8.new&#x2F;delete运算符的原理"></a>8.new&#x2F;delete运算符的原理</h2><ul>
<li><strong>内存分配</strong><ul>
<li>调用相应的 operator new(size_t) 函数，动态分配内存</li>
<li>如果 operator new(size_t) 不能成功获得内存，则调用 new_handler()函数用于处理new失败问题</li>
<li>如果没有设置 new_handler() 函数或者 new_handler() 未能分配足够内存，则抛出 std::bad_alloc 异常</li>
</ul>
</li>
<li><strong>构造函数</strong><ul>
<li>在分配到的动态内存块上 初始化相应类型的对象（构造函数）并返回其首地址</li>
<li>如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void *, void *) 函数释放已经分配到的内存</li>
</ul>
</li>
<li><strong>delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同</strong></li>
</ul>
<h2 id="9-malloc的内存分配机制"><a href="#9-malloc的内存分配机制" class="headerlink" title="9.malloc的内存分配机制"></a>9.malloc的内存分配机制</h2><p><strong>malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存？</strong></p>
<ul>
<li>首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存</li>
<li>如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中</li>
</ul>
<h2 id="10-堆和栈的区别"><a href="#10-堆和栈的区别" class="headerlink" title="10.堆和栈的区别"></a>10.堆和栈的区别</h2><ul>
<li>管理方式不同<ul>
<li>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak</li>
</ul>
</li>
<li>空间大小不同<ul>
<li>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M</li>
</ul>
</li>
<li>能否产生碎片不同<ul>
<li>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</li>
<li>对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</li>
</ul>
</li>
<li>生长方向不同<ul>
<li>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长</li>
</ul>
</li>
</ul>
<h2 id="11-const关键字"><a href="#11-const关键字" class="headerlink" title="11.const关键字"></a>11.const关键字</h2><ul>
<li><strong>修饰变量：</strong>说明该变量不可以被改变</li>
<li><strong>修饰指针：</strong>分为指向常量的指针和指针常量；int *const p和const int *p</li>
<li><strong>常量引用：</strong>经常用于形参类型，即避免了拷贝，又避免了函数对值的修改</li>
<li><strong>修饰成员函数：</strong>说明该成员函数内不能修改成员变量，本质是const this指针</li>
</ul>
<h2 id="12-static关键字"><a href="#12-static关键字" class="headerlink" title="12.static关键字"></a>12.static关键字</h2><ul>
<li><strong>修饰普通变量：</strong> 修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0<ul>
<li><strong>全局变量作用域：</strong>全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾</li>
<li><strong>局部变量作用域：</strong>仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变</li>
</ul>
</li>
<li><strong>修饰普通函数：</strong>其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li><strong>修饰类成员变量和成员函数：</strong> 它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li>
</ul>
<h2 id="13-extern关键字"><a href="#13-extern关键字" class="headerlink" title="13.extern关键字"></a>13.extern关键字</h2><p>extern关键字主要修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用</p>
<ul>
<li><strong>修饰变量或函数</strong><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
</ul>
</li>
<li><strong>extern “C”</strong><ul>
<li>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题<ul>
<li><ol>
<li>在c头文件中通过#ifdef __cplusplus extern “C” { #endif来定义</li>
<li>在对应的c文件中实现 </li>
<li>在cpp文件中通过“extern “C” 函数名”调用，或者包含c头文件 </li>
<li><strong>注意：</strong> extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间，但若需要调用的函数太多，还是直接包含头文件吧</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-volatile关键字"><a href="#14-volatile关键字" class="headerlink" title="14.volatile关键字"></a>14.volatile关键字</h2><ul>
<li><strong>不可优化性：</strong> volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化</li>
<li><strong>易变性：</strong> volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
</ul>
<h2 id="15-explicit关键字"><a href="#15-explicit关键字" class="headerlink" title="15.explicit关键字"></a>15.explicit关键字</h2><p>explicit关键字的作用就是<strong>防止对象间实现&#x3D;赋值</strong>，<strong>防止类构造函数的隐式自动转换</strong>，类构造函数默认情况下即声明为implicit(隐式)，另外<strong>explicit只用于单参数的构造函数</strong>，或者除了第一个参数以外的其他参数都有默认值</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换</li>
</ul>
<h2 id="16-C-从代码到可执行"><a href="#16-C-从代码到可执行" class="headerlink" title="16.C++从代码到可执行"></a>16.C++从代码到可执行</h2><p><strong>一、预编译</strong></p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p>
<ol>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li>
<li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</li>
</ol>
<p><strong>二、编译</strong></p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ol>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li>
</ol>
<p><strong>三、汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p>
<p><strong>四、链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ul>
<li><p><strong>静态链接</strong></p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li>
<li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</li>
</ul>
</li>
<li><p><strong>动态链接</strong></p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
</ul>
</li>
</ul>
<h2 id="17-hello-c程序的编译过程"><a href="#17-hello-c程序的编译过程" class="headerlink" title="17.hello.c程序的编译过程"></a>17.hello.c程序的编译过程</h2><p>以下是一个 hello.c 程序：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;

int main()
&#123;
    printf(&quot;hello, world\n&quot;);
    return 0;
&#125;
</code></pre>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<pre><code class="hljs">    gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：</p>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<p><strong>静态链接</strong><br>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>目标文件</strong></p>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<p><strong>动态链接</strong><br>静态库有以下两个问题：</p>
<ul>
<li><p>当静态库更新时那么整个程序都要重新进行链接；</p>
</li>
<li><p>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</p>
</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</p>
<ol>
<li><p>预处理<br>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。</p>
</li>
<li><p>编译阶段<br>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p>
</li>
<li><p>汇编过程<br>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p>
</li>
<li><p>链接阶段<br>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p>
</li>
</ol>
<h1 id="二、C-面向对象"><a href="#二、C-面向对象" class="headerlink" title="二、C++面向对象"></a>二、C++面向对象</h1><h2 id="1-内存字节对齐"><a href="#1-内存字节对齐" class="headerlink" title="1.内存字节对齐"></a>1.内存字节对齐</h2><ul>
<li><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">struct A&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">short</span> c;<br>&#125;;<br>- <span class="hljs-type">char</span>占一个字节，起始偏移为零，<span class="hljs-type">int</span>占四个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以应该偏移量为<span class="hljs-number">4</span>，所以应该在<span class="hljs-type">char</span>后面加上三个字节，不存放任何东西，<span class="hljs-type">short</span>占两个字节，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>)=<span class="hljs-number">2</span>;所以偏移量是<span class="hljs-number">2</span>的倍数，而<span class="hljs-type">short</span>偏移量是<span class="hljs-number">8</span>，是<span class="hljs-number">2</span>的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为<span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span><br><br>- 此时一共占了<span class="hljs-number">10</span>个字节，但是还有结构体本身的对齐，<span class="hljs-built_in">min</span>(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)=<span class="hljs-number">4</span>；所以总体应该是<span class="hljs-number">4</span>的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 <span class="hljs-number">0</span>xxx|<span class="hljs-number">0000</span>|<span class="hljs-number">00</span>xx，一共占据了<span class="hljs-number">12</span>个字节<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>内存对齐规则</strong><ul>
<li>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数</li>
<li>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)</li>
</ul>
</li>
<li><strong>需要对齐的原因</strong><ul>
<li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li>
<li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li>
</ul>
</li>
</ul>
<h2 id="2-双冒号、using和namespace"><a href="#2-双冒号、using和namespace" class="headerlink" title="2.双冒号、using和namespace"></a>2.双冒号、using和namespace</h2><ul>
<li><strong>namespace主要用来解决命名冲突的问题</strong><ul>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放函数，变量、结构体和类</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li>
</ul>
</li>
<li><strong>双冒号::作用域运算符</strong><ul>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ul>
</li>
<li><strong>using分为using声明和using编译指令</strong><ul>
<li><code>using std::cout; //声明</code></li>
<li><code>using namespace std; //编译指令</code></li>
<li>尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</li>
</ul>
</li>
</ul>
<h2 id="3-内联函数和函数重载"><a href="#3-内联函数和函数重载" class="headerlink" title="3.内联函数和函数重载"></a>3.内联函数和函数重载</h2><ul>
<li><strong>内联函数</strong><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性</li>
<li>不能包含循环、递归、switch 等复杂操作</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数</li>
</ul>
</li>
<li><strong>C++的函数名称可以重复，称为函数重载</strong><ul>
<li>其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中</li>
<li>可以根据函数参数的个数、类型（const也可以作为重载条件）、顺序不同进行函数重载，但<strong>不能用函数返回值进行重载</strong></li>
<li>当函数重载遇到函数默认参数时，要注意二义性</li>
</ul>
</li>
</ul>
<h2 id="4-虚函数可以是内联函数吗"><a href="#4-虚函数可以是内联函数吗" class="headerlink" title="4.虚函数可以是内联函数吗"></a>4.虚函数可以是内联函数吗</h2><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li>
<li>内联是在编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联</li>
<li><strong>inline virtual 唯一可以内联的时候是</strong>：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</li>
</ul>
<h2 id="5-构造函数和析构函数"><a href="#5-构造函数和析构函数" class="headerlink" title="5.构造函数和析构函数"></a>5.构造函数和析构函数</h2><ul>
<li>构造函数和析构函数，分别对应变量的初始化和清理，变量没有初始化，使用后果未知；没有清理，则会内存管理出现安全问题。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数</li>
</ul>
<blockquote>
<ul>
<li>构造函数：与类名相同，没有返回值，不写void，<strong>可以发生重载</strong>，可以有参数，编译器自动调用，只调用一次。</li>
<li>析构函数：~类名，没有返回值，不写void，<strong>不可以发生重载</strong>，不可以有参数，编译器自动调用，只调用一次。</li>
</ul>
</blockquote>
<ul>
<li>构造函数<ul>
<li>系统会默认给一个类提供三个函数：默认构造函数（无参，函数体为空）、默认拷贝构造和析构函数（无参，函数体为空），其中默认拷贝构造可以实现简单的值拷贝</li>
<li>提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数；若自己定义了有参构造，还想要无参构造函数，就必须再自定义无参构造函数</li>
</ul>
</li>
<li>析构函数<ul>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="6-拷贝初始化和直接初始化"><a href="#6-拷贝初始化和直接初始化" class="headerlink" title="6.拷贝初始化和直接初始化"></a>6.拷贝初始化和直接初始化</h2><ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;I am a string&quot;</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数   </span><br></code></pre></td></tr></table></figure>

<ul>
<li>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了（语句1和语句3等价），但是需要辨别两种情况。<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<h2 id="6-初始化和赋值的区别"><a href="#6-初始化和赋值的区别" class="headerlink" title="6.初始化和赋值的区别"></a>6.初始化和赋值的区别</h2><ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b)&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;;<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>拷贝构造函数与赋值函数的区别</strong></p>
<ul>
<li>拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。</li>
<li>一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</li>
<li>实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）</li>
<li>如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码。如：</li>
</ul>
<h2 id="6-拷贝构造函数与深浅拷贝"><a href="#6-拷贝构造函数与深浅拷贝" class="headerlink" title="6.拷贝构造函数与深浅拷贝"></a>6.拷贝构造函数与深浅拷贝</h2><p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象</p>
<ul>
<li><strong>拷贝构造函数的使用时机</strong><ul>
<li>使用已经创建好的对象初始化新对象 <code>A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符</code></li>
<li>以值传递的方式来给函数参数传值</li>
<li>以值方式返回局部对象（不常用，一般不返回局部对象）</li>
</ul>
</li>
<li><strong>深拷贝和浅拷贝</strong>只有当对象的成员属性在堆区开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求<ul>
<li><strong>浅拷贝</strong>：使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉</li>
<li><strong>浅拷贝的问题</strong>：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。<strong>当数据成员中没有指针时，浅拷贝是可行的</strong>。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了所以，这时，必须采用深拷贝</li>
<li><strong>深拷贝</strong>：自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。<strong>需要注意自定义析构函数中应该释放掉申请的内存</strong></li>
</ul>
</li>
</ul>
<p>我们在定义类或者结构体，这些结构的时候，<strong>最后都重写拷贝函数，避免浅拷贝</strong>这类不易发现但后果严重的错误产生</p>
<h2 id="7-拷贝构造函数和移动构造函数的区别"><a href="#7-拷贝构造函数和移动构造函数的区别" class="headerlink" title="7.拷贝构造函数和移动构造函数的区别"></a>7.拷贝构造函数和移动构造函数的区别</h2><ul>
<li>拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间</li>
<li>移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间</li>
</ul>
<h2 id="7-什么情况下会调用拷贝构造函数"><a href="#7-什么情况下会调用拷贝构造函数" class="headerlink" title="7.什么情况下会调用拷贝构造函数"></a>7.什么情况下会调用拷贝构造函数</h2><ul>
<li>用类的一个实例化对象去初始化另一个对象的时候</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li>
</ul>
<p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p>
<p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p>
<p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p>
<h2 id="8-只在堆上-x2F-栈上创建对象"><a href="#8-只在堆上-x2F-栈上创建对象" class="headerlink" title="8.只在堆上&#x2F;栈上创建对象"></a>8.只在堆上&#x2F;栈上创建对象</h2><ul>
<li><p><strong>只能在堆上生成对象：将析构函数设置为私有</strong> </p>
<ul>
<li><strong>原因：</strong>C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象</li>
</ul>
</li>
<li><p><strong>只能在栈上生成对象：将new 和 delete 重载为私有</strong></p>
<ul>
<li><strong>原因：</strong>在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象</li>
</ul>
</li>
</ul>
<h2 id="9-this指针"><a href="#9-this指针" class="headerlink" title="9.this指针"></a>9.this指针</h2><ul>
<li><p><strong>为什么会有this指针</strong>：</p>
<ul>
<li>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针</li>
</ul>
</li>
<li><p><strong>this指针的作用：</strong></p>
<ul>
<li>this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。this指针指向被调用的成员函数所属的对象（谁调用成员函数，this指向谁），this表示对象本身，<strong>非静态成员函数中才有this，静态成员函数内部没有</strong></li>
</ul>
</li>
<li><p>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）</p>
<ul>
<li>对非静态成员函数默认添加了this指针，类型为classname *const this</li>
<li><strong>this指针只能在成员函数中使用，在全局函数、静态成员函数中不能使用this指针。因此，获得一个对象后，不能通过对象使用this指针，但在成员函数中，可以知道this指针位置，也可以直接使用它</strong></li>
</ul>
</li>
<li><p><strong>this指针使用：</strong></p>
<ul>
<li>当形参与成员变量名相同时，用this指针来区分</li>
<li>为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，&#x2F;*this表示对象本身</li>
</ul>
</li>
<li><p><strong>this指针在成员函数的开始执行前构造，在成员函数的执行结束后清除</strong></p>
</li>
<li><p><strong>this指针会因编译器不同而有不同的放置位置，可能是栈，也可能是寄存器，甚至全局变量</strong></p>
</li>
</ul>
<h2 id="10-delete-this合法吗？"><a href="#10-delete-this合法吗？" class="headerlink" title="10.delete this合法吗？"></a>10.delete this合法吗？</h2><p><strong>合法，但有前提：</strong></p>
<blockquote>
<p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p>
</blockquote>
<ul>
<li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ul>
<p><strong>在类的析构函数中调用delete this会发生什么？</strong></p>
<ul>
<li>会导致堆栈溢出</li>
<li>原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</li>
</ul>
<h2 id="11-静态成员变量和静态成员函数"><a href="#11-静态成员变量和静态成员函数" class="headerlink" title="11.静态成员变量和静态成员函数"></a>11.静态成员变量和静态成员函数</h2><p>若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。<strong>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区</strong></p>
<ul>
<li><strong>静态成员变量</strong><ul>
<li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）</li>
<li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限</li>
<li>非静态成员类外不能初始化</li>
<li>静态成员数据是共享的</li>
</ul>
</li>
<li><strong>静态成员函数</strong><ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量</li>
<li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针</li>
</ul>
</li>
</ul>
<h2 id="12-初始化列表的好处和使用条件"><a href="#12-初始化列表的好处和使用条件" class="headerlink" title="12.初始化列表的好处和使用条件"></a>12.初始化列表的好处和使用条件</h2><ul>
<li><p><strong>初始化列表的使用条件</strong></p>
<ul>
<li>const类型的数据</li>
<li>引用类型的数据</li>
</ul>
</li>
<li><p><strong>好处</strong></p>
<ul>
<li>初始化是直接初始化成员</li>
<li>赋值是初始化再赋值</li>
</ul>
</li>
<li><p><strong>不能通过初始化列表初始化静态成员变量</strong>，静态成员变量最好类内声明，类外初始化.静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用域相同的情况下会导致重名的问题</p>
</li>
</ul>
<h2 id="13-运算符重载及-重载实现"><a href="#13-运算符重载及-重载实现" class="headerlink" title="13.运算符重载及++重载实现"></a>13.运算符重载及++重载实现</h2><ul>
<li><p><strong>运算符重载基本属性</strong></p>
<ul>
<li><p>运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型</p>
</li>
<li><p>运算符重载的实质是函数重载，可以重载为普通成员函数，也可以重载为成员函数</p>
</li>
<li><p>运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址</p>
</li>
</ul>
</li>
<li><p><strong>运算符重载总结</strong></p>
<ul>
<li><p>重载运算符()，[] ，-&gt;， &#x3D;的时候，运算符重载函数必须声明为类的成员函数</p>
</li>
<li><p>重载运算符&lt;&lt;，&gt;&gt;的时候，运算符只能通过全局函数配合友元函数进行重载</p>
</li>
<li><p>不要重载&amp;&amp;和||运算符，因为无法实现短路原则</p>
</li>
</ul>
</li>
<li><p><strong>i++和++i实现</strong></p>
<p>C++内置类型的后置++返回的是变量的拷贝，也就是不可修改的值；前置++返回的是变量的引用，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//++i</span><br><span class="hljs-type">int</span>&amp;  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    *<span class="hljs-keyword">this</span> +=<span class="hljs-number">1</span>；<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>；<br>&#125;<br><br><span class="hljs-comment">//i++，注意后置++有占位参数以区分跟前置++不同</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  <span class="hljs-type">int</span>::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>    <span class="hljs-type">int</span> oldValue = *<span class="hljs-keyword">this</span>；<br>    ++（*<span class="hljs-keyword">this</span>）；<br>    <span class="hljs-keyword">return</span> oldValue；<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-继承方式、对象模型、同名处理"><a href="#14-继承方式、对象模型、同名处理" class="headerlink" title="14.继承方式、对象模型、同名处理"></a>14.继承方式、对象模型、同名处理</h2><p><strong>继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法</strong></p>
<ul>
<li><p><strong>继承方式</strong></p>
<ul>
<li><p>公有继承：保持父类中的访问属性</p>
</li>
<li><p>私有继承：将父类中的所有访问属性改为private</p>
</li>
<li><p>保护继承：除父类中的私有属性，其他改为保护属性</p>
</li>
</ul>
</li>
<li><p><strong>继承的对象模型</strong></p>
<ul>
<li><p>子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出</p>
</li>
<li><p>子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反</p>
<ul>
<li>由于继承中父类和子类的构造、析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造</li>
</ul>
</li>
<li><p>子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数</p>
</li>
</ul>
</li>
<li><p><strong>继承中的同名处理</strong></p>
<ul>
<li><p>父类和子类<strong>成员属性</strong>同名，用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域</p>
</li>
<li><p>父类和子类<strong>成员函数</strong>同名，子类函数不会覆盖父类的成员，只是隐藏起来，用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域</p>
</li>
<li><p>若子类中没有与父类同名的成员函数，子类声明对象后，可以直接调用父类成员函数</p>
</li>
</ul>
</li>
</ul>
<h2 id="15-多继承和菱形继承"><a href="#15-多继承和菱形继承" class="headerlink" title="15.多继承和菱形继承"></a>15.多继承和菱形继承</h2><ul>
<li><strong>多继承</strong></li>
</ul>
<blockquote>
<p>多继承会产生二义性的问题。如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类</p>
</blockquote>
<ul>
<li><strong>菱形继承</strong></li>
</ul>
<blockquote>
<p>两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼</p>
</blockquote>
<ul>
<li><p><strong>菱形继承会产生问题</strong></p>
<ul>
<li><strong>浪费空间：</strong>羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可</li>
</ul>
</li>
<li><p><strong>二义性：从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题</strong></p>
<ul>
<li>羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过carmel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致</li>
</ul>
</li>
<li><p><strong>解决菱形继承的问题</strong></p>
<p><strong>使用虚继承</strong>，在<strong>继承方式前加virtual</strong>，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age</span><br>&#125;<br>- 此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据<br>- Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）<br>- Sheep的虚指针指向下面Sheep的虚基类表<span class="hljs-symbol">vbtale@</span>Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为<span class="hljs-number">20</span>，即Sheep的虚指针地址偏移<span class="hljs-number">20</span>指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素<br>- Son中包含了两个指针和四个<span class="hljs-built_in">int</span>类型，所以大小为<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>虚继承</strong><ul>
<li><p>一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类</p>
</li>
<li><p><strong>每个虚继承的子类（虚基类本身没有）都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），虚基类指针属于对象，虚基类表属于类</strong></p>
</li>
<li><p>当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
</li>
<li><p>虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址(虚基类指针)之间的偏移量,以此来访问虚基类数据</p>
</li>
<li><p>虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间</p>
</li>
<li><p>虚基类表本质是一个<strong>整型数组</strong></p>
</li>
<li><p><strong>虚函数属于对象，不属于类，而静态函数属于类</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Sheep:<span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_sheep;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Camel</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Animal</span>&#123;<br>    <span class="hljs-built_in">int</span> m_camel;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Son</span> :<span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Sheep, <span class="hljs-symbol">virtual</span></span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Camel</span>&#123;<br>    <span class="hljs-built_in">int</span> m_son<br>&#125;;<br><span class="hljs-built_in">void</span> test01()&#123;<br>    Son son;<br>    son.m_Age = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; <span class="hljs-comment">//m_Age</span><br>    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  <span class="hljs-comment">//sheep-Vbptr,m_sheep,m_Age</span><br>    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  <span class="hljs-comment">//camel-Vbptr,m_camel,m_Age</span><br>    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    <span class="hljs-comment">//son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,</span><br>&#125;<br>- 注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表<br></code></pre></td></tr></table></figure>

<h2 id="16-重载、覆盖、重写"><a href="#16-重载、覆盖、重写" class="headerlink" title="16.重载、覆盖、重写"></a>16.重载、覆盖、重写</h2><ul>
<li><strong>重载(overload)：</strong>是函数名相同，参数列表不同。重载只是在同一个类的内部存在，但是不能靠返回类型来判断</li>
<li><strong>覆盖(override)：</strong>子类重新定义父类中有相同名称和参数的虚函数。两者的函数特征相同<ul>
<li>被重写的函数不能是static的。必须是virtual的</li>
<li>重写函数必须有相同的类型，名称和参数列表</li>
<li>重写函数的访问权限可以不同。尽管virtual是private的，子类中重写改写为public,protected也是可以的</li>
</ul>
</li>
<li><strong>重写(overwrite)：</strong>也叫做隐藏。子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域</li>
</ul>
<h2 id="17-多态实现的基础"><a href="#17-多态实现的基础" class="headerlink" title="17.多态实现的基础"></a>17.多态实现的基础</h2><ul>
<li><strong>继承</strong></li>
<li><strong>虚函数覆盖</strong></li>
<li><strong>父类指针或引用指向子类对象访问虚函数</strong></li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Animal&#123;<br>public:<br>    virtual  void speak()&#123; <span class="hljs-regexp">//</span>在父类中声明虚函数，可以实现多态，动态联编<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">0</span>;<br>&#125;;<br><br>class Sheep :public Animal&#123;<br>public:<br>    void speak()&#123; <span class="hljs-regexp">//</span>发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sheep speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    int m_age = <span class="hljs-number">1</span>;<br>&#125;;<br><br>void doSpeak(Animal &amp;animal)&#123;<br>    animal.speak();<br>&#125;<br><br>void test01()&#123;<br>    <span class="hljs-regexp">//</span>传入子类对象调用子类成员函数<br>    Sheep sheep;<br>    doSpeak(sheep); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接调用子类成员函数<br>    sheep.speak();  <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象通过作用域调用父类成员函数<br>    sheep.Animal::speak();  <span class="hljs-regexp">//</span>animal speak;<br><br>    <span class="hljs-regexp">//</span>基类成员不能转换为子类成员，即不能向下转换<br>    <span class="hljs-regexp">//</span>Animal *animal0 = new Animal();<br>    <span class="hljs-regexp">//</span>Sheep * sheep0 = animal0;<br>    <span class="hljs-regexp">//</span>sheep0-&gt;speak();<br><br>    <span class="hljs-regexp">//</span>同样不能向下转换<br>    <span class="hljs-regexp">//</span>Animal animal0;<br>    <span class="hljs-regexp">//</span>Sheep sheep0 = animal0;<br><br>    <span class="hljs-regexp">//</span>父类指针指向子类对象<br>    Sheep *sheep1 = new Sheep();<br>    Animal *animal1 = sheep1;<br>    animal1-&gt;speak(); <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>父类引用指向子类对象<br>    Sheep sheep2;<br>    Animal &amp;animal2 = sheep2;<br>    animal2.speak();    <span class="hljs-regexp">//</span>sheep speak;<br><br>    <span class="hljs-regexp">//</span>子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则<br>    Sheep sheep0;<br>    Animal animal0 = sheep0;<br>    animal0.speak();    <span class="hljs-regexp">//</span>animal speak;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>静态多态（运算符重载、函数重载）</strong></li>
<li><strong>动态多态（继承、虚函数）</strong></li>
</ul>
<blockquote>
<p>两者主要的区别：函数地址是早绑定（静态联编）还是晚绑定（动态联编）。即，在编译阶段确定好地址还是在运行时才确定地址</p>
</blockquote>
<h2 id="18-虚函数指针和虚函数表"><a href="#18-虚函数指针和虚函数表" class="headerlink" title="18.虚函数指针和虚函数表"></a>18.虚函数指针和虚函数表</h2><ul>
<li>前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，然后对虚函数重写</li>
<li>虚函数重写（覆盖）的实质就是重写父类虚函数表中的父类虚函数地址</li>
<li><strong>实现多态的流程：虚函数指针-&gt;虚函数表-&gt;函数指针-&gt;入口地址，虚函数表（vftable）属于类，或者说这个类的所有对象共享一个虚函数表；而虚函数指针（vfptr）属于单个对象</strong></li>
<li>在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表</li>
<li><strong>虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序</strong></li>
<li>编译器根本不会去区别，传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数<ul>
<li>如果是虚函数，就根据不同对象的vptr指针找属于自己的函数：父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数</li>
<li>即：vptr-&gt;虚函数表-&gt;函数的入口弟子，从而实现了迟绑定（在运行的时候，才会去判断）</li>
</ul>
</li>
</ul>
<h2 id="19-构造函数能否实现多态-x2F-虚函数指针什么时候初始化"><a href="#19-构造函数能否实现多态-x2F-虚函数指针什么时候初始化" class="headerlink" title="19.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化"></a>19.构造函数能否实现多态&#x2F;虚函数指针什么时候初始化</h2><p><strong>两个问题本质是一样的，构造函数不能实现多态</strong></p>
<ul>
<li>对象在创建时,由编译器对VPTR指针进行初始化，只有当对象的构造完全结束后VPTR的指向才最终确定</li>
<li>子类中虚函数指针的初始化过程 当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时Vptr又被赋值指向子类的虚函数表</li>
<li><strong>构造函数不能是虚函数，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针</strong></li>
</ul>
<h2 id="20-抽象类和纯虚函数"><a href="#20-抽象类和纯虚函数" class="headerlink" title="20.抽象类和纯虚函数"></a>20.抽象类和纯虚函数</h2><p>在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求</p>
<ul>
<li><strong>纯虚函数的语法格式：<code>virtual 返回值类型 函数名 () = 0;</code>只需要将函数体完全替换为 &#x3D;0即可，纯虚函数必须在子类中进行实现，在子类外实现是无效的</strong></li>
<li>注意<ul>
<li>如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象</li>
<li><strong>如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象但纯虚析构函数例外，因为子类不会继承父类的析构函数</strong></li>
</ul>
</li>
</ul>
<h2 id="21-虚析构和纯虚析构"><a href="#21-虚析构和纯虚析构" class="headerlink" title="21.虚析构和纯虚析构"></a>21.虚析构和纯虚析构</h2><ul>
<li><p><strong>内存泄漏：当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</strong></p>
<ul>
<li>仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数-&gt;子类构造函数-&gt;子类析构函数-&gt;父类析构函数</li>
<li>当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，如果父类的析构函数不被声明为虚函数，则编译器实施的是静态绑定。销毁的调用流程为：父类构造函数-&gt;子类构造函数-&gt;父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题</li>
</ul>
</li>
<li><p><strong>内存泄漏的解决方法</strong></p>
<ul>
<li><strong>将父类中的析构函数设置为虚函数，设置后会先调用子类析构函数，再调用父类析构函数</strong></li>
</ul>
</li>
<li><p><strong>纯虚析构</strong></p>
<ul>
<li>纯虚析构需要类内声明，类外实现</li>
<li>纯虚析构也是虚函数，该类也为抽象类</li>
<li><strong>子类不会继承父类的析构函数，当父类纯虚析构没有实现时，子类不是抽象类，可以创建创建对象</strong></li>
</ul>
</li>
<li><p><strong>C++默认的析构函数不是虚函数：因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存</strong></p>
</li>
</ul>
<h2 id="22-类模版和函数模版"><a href="#22-类模版和函数模版" class="headerlink" title="22.类模版和函数模版"></a>22.类模版和函数模版</h2><p><strong>通过template或template实现，主要用于数据的类型参数化，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的</strong></p>
<ul>
<li><p>类模板和函数模板定义</p>
<ul>
<li><p>template声明下面是函数定义，则为函数模板，否则为类模板</p>
</li>
<li><p>注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板(类模板同理)</p>
</li>
</ul>
</li>
<li><p>类模板与函数模板的区别</p>
<ul>
<li>类模板不支持自动类型推导</li>
<li>数据类型可以有默认参数</li>
</ul>
</li>
</ul>
<h1 id="三、C-高级特性"><a href="#三、C-高级特性" class="headerlink" title="三、C++高级特性"></a>三、C++高级特性</h1><h2 id="1-构造函数可以抛出异常吗，有什么问题？"><a href="#1-构造函数可以抛出异常吗，有什么问题？" class="headerlink" title="1.构造函数可以抛出异常吗，有什么问题？"></a>1.构造函数可以抛出异常吗，有什么问题？</h2><p><strong>构造函数中应该避免抛出异常</strong></p>
<ul>
<li><p>构造函数中抛出异常后，对象的析构函数将不会被执行</p>
</li>
<li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露</p>
</li>
<li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构</p>
</li>
</ul>
<h2 id="2-初始化列表的异常怎么捕获？"><a href="#2-初始化列表的异常怎么捕获？" class="headerlink" title="2.初始化列表的异常怎么捕获？"></a>2.初始化列表的异常怎么捕获？</h2><ul>
<li>初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题</li>
<li>函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常</li>
</ul>
<h2 id="3-析构函数可以抛出异常吗，有什么问题？"><a href="#3-析构函数可以抛出异常吗，有什么问题？" class="headerlink" title="3.析构函数可以抛出异常吗，有什么问题？"></a>3.析构函数可以抛出异常吗，有什么问题？</h2><p><strong>析构函数不应该抛出异常</strong></p>
<ul>
<li><p><strong>其他正常，仅析构函数异常</strong>。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题</p>
</li>
<li><p><strong>其他异常，且析构函数异常</strong>。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题</p>
</li>
</ul>
<h2 id="4-析构函数如何处理异常"><a href="#4-析构函数如何处理异常" class="headerlink" title="4.析构函数如何处理异常"></a>4.析构函数如何处理异常</h2><ul>
<li>若析构函数抛出异常，调用std::abort()来终止程序</li>
<li>在析构函数中catch捕获异常并作处理，吞下异常</li>
<li>如果客户需要对某个操作函数运次期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中</li>
</ul>
<h2 id="10-CPP11新特性"><a href="#10-CPP11新特性" class="headerlink" title="10.CPP11新特性"></a>10.CPP11新特性</h2><ul>
<li><strong>nullptr常量</strong><ul>
<li>C++中NULL仅仅是define NULL 0 的一个宏定义，因此，有时候会产生歧义<ul>
<li>比如f（char*）和f（int），参数传NULL的话到底该调用哪个？</li>
<li>事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题</li>
</ul>
</li>
<li>nullptr是一个空指针，可以被转换成其他任意指针的类型</li>
</ul>
</li>
<li><strong>auto类型指示符</strong><ul>
<li>让编译器替我们去分析表达式所属的类型，直接推导</li>
<li>尤其是STL中map的迭代器这种很长的类型，适合用auto</li>
</ul>
</li>
<li><strong>decltype类型指示符</strong><ul>
<li>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关</li>
<li><code>delctype (f()) sum = x;</code> 并不实际调用函数f()，只是使用f()的返回值当做sum的类型</li>
<li><code>delctype (i) sum = x;</code>和<code>delctype ((i)) sum = x;</code> 其中i为int类型，前面的为int类型，后面的为int&amp;引用</li>
</ul>
</li>
<li><strong>范围for语句</strong><ul>
<li>多与auto配合使用</li>
</ul>
</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">string <span class="hljs-built_in">str</span>(&quot;somthing&quot;);<br><span class="hljs-built_in">for</span>(auto i:str) <span class="hljs-comment">//对于str中的每个字符，i类型为char</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">for</span>(auto &amp;i:str) <span class="hljs-comment">//对于若要改变每个字符的值，需要加引用</span><br>    cout &lt;&lt; c &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>定义双层vector</strong><ul>
<li><code>vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0))</code> 创建m行n列的二维数组，全部初始化为0</li>
</ul>
</li>
<li><strong>lambda表达式</strong><ul>
<li>用于实现匿名函数，匿名函数只有函数体，没有函数名</li>
</ul>
</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">[capture list] (params list) <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">exception</span><span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//1</span><br>[capture list] (params list) <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-keyword">function</span> body&#125;;  <span class="hljs-comment">//省略mutable，表示const不可修改</span><br>[capture list] (params list) &#123;<span class="hljs-keyword">function</span> body&#125;;       <span class="hljs-comment">//省略返回类型，按照函数体返回值决定返回类型</span><br>[capture list] &#123;<span class="hljs-keyword">function</span> body&#125;;     <span class="hljs-comment">//省略参数列表，无参函数</span><br>参数capture list：捕获外部变量列表 <br>params list：形参列表 <br><span class="hljs-keyword">mutable</span>指示符：用来说用是否可以修改捕获的变量 <br><span class="hljs-keyword">exception</span>：异常设定 <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>：返回类型 <br><span class="hljs-keyword">function</span> body：函数体			<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//示例</span><br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">(vec.begin()</span></span>, vec<span class="hljs-selector-class">.end</span>(), <span class="hljs-selector-attr">[]</span>(int <span class="hljs-selector-tag">a</span>, int b)-&gt;bool&#123;return <span class="hljs-selector-tag">a</span> &lt; b&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>智能指针</strong><ul>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>unique_ptr</li>
</ul>
</li>
<li><strong>右值引用</strong><ul>
<li>左值引用，必须引用左值 <code>int a = 0; int &amp;b = a</code></li>
<li>右值引用可以引用结果 <code>int &amp;&amp; i = 0</code></li>
</ul>
</li>
</ul>
<h2 id="5-auto、decltype的用法"><a href="#5-auto、decltype的用法" class="headerlink" title="5.auto、decltype的用法"></a>5.auto、decltype的用法</h2><p><strong>1）auto</strong></p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p>
<p>举个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//普通；类型</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">auto</span> c = a + b;<span class="hljs-comment">// c为int型</span><br><br><span class="hljs-comment">//const类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">auto</span> j = i; <span class="hljs-comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="hljs-built_in">auto</span> k = &amp;i; <span class="hljs-comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">auto</span> l = i; <span class="hljs-comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><br><span class="hljs-comment">//引用和指针类型</span><br><span class="hljs-built_in">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span>&amp; y = x;<br><span class="hljs-built_in">auto</span> z = y; <span class="hljs-comment">//z是int型不是int&amp; 型</span><br><span class="hljs-built_in">auto</span>&amp; p1 = y; <span class="hljs-comment">//p1是int&amp;型</span><br><span class="hljs-built_in">auto</span> p2 = &amp;x; <span class="hljs-comment">//p2是指针类型int*</span><br></code></pre></td></tr></table></figure>

<p>2）decltype</p>
<p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">int <span class="hljs-keyword">func</span>() &#123;return <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-regexp">//</span>普通类型<br>decltype(<span class="hljs-keyword">func</span>()) sum = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> sum的类型是函数<span class="hljs-keyword">func</span>()的返回值的类型int, 但是这时不会实际调用函数<span class="hljs-keyword">func</span>()<br>int a = <span class="hljs-number">0</span>;<br>decltype(a) b = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span> a的类型是int, 所以b的类型也是int<br><br><span class="hljs-regexp">//</span>不论是顶层const还是底层const, decltype都会保留   <br>const int c = <span class="hljs-number">3</span>;<br>decltype(c) d = c; <span class="hljs-regexp">//</span> d的类型和c是一样的, 都是顶层const<br>int e = <span class="hljs-number">4</span>;<br>const int* f = &amp;e; <span class="hljs-regexp">//</span> f是底层const<br>decltype(f) g = f; <span class="hljs-regexp">//</span> g也是底层const<br><br><span class="hljs-regexp">//</span>引用与指针类型<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 如果表达式是引用类型, 那么decltype的类型也是引用<br>const int i = <span class="hljs-number">3</span>, &amp;j = i;<br>decltype(j) k = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> k的类型是 const int&amp;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:<br>int i = <span class="hljs-number">3</span>, &amp;r = i;<br>decltype(r + <span class="hljs-number">0</span>) t = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> 此时是int类型<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>. 对指针的解引用操作返回的是引用类型<br>int i = <span class="hljs-number">3</span>, j = <span class="hljs-number">6</span>, *p = &amp;i;<br>decltype(*p) c = j; <span class="hljs-regexp">//</span> c是int&amp;类型, c和j绑定在一起<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了<br>int i = <span class="hljs-number">3</span>;<br>decltype((i)) j = i; <span class="hljs-regexp">//</span> 此时j的类型是int&amp;类型, j和i绑定在了一起<br></code></pre></td></tr></table></figure>

<h2 id="6-C-中NULL和nullptr的区别"><a href="#6-C-中NULL和nullptr的区别" class="headerlink" title="6.C++中NULL和nullptr的区别"></a>6.C++中NULL和nullptr的区别</h2><ul>
<li><strong>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void)0,而在C++语言中，NULL则被定义为整数0</strong></li>
<li><strong>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误</strong></li>
</ul>
<h2 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5.智能指针"></a>5.智能指针</h2><ul>
<li><p><strong>原始指针在引入了异常机制后容易发生内存泄漏、二次释放等问题</strong></p>
</li>
<li><p>C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针</p>
</li>
<li><p><strong>shared_ptr共享的智能指针</strong></p>
<ul>
<li><p>share_ptr的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;	<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>shared_ptr常用操作</strong></p>
<ul>
<li>&#96;&#96;&#96;<br>make_shared<T>(args) &#x2F;&#x2F; 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象<br>shared_ptr<T> p(q) &#x2F;&#x2F; p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*<br>p &#x3D; q &#x2F;&#x2F; p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放<br>p.unique() &#x2F;&#x2F; 若p.use_count()为1，返回true；否则返回false<br>p.use_count() &#x2F;&#x2F; 返回与p共享对象的智能指针数量；可能很慢，主要用于调试<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- **shared_ptr的其他方法**<br><br>  - ```<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span> () //若<span class="hljs-selector-tag">p</span>是唯一指向其对象的shared_ptr，reset会释放此对象。<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>) //若传递了可选的参数内置指针<span class="hljs-selector-tag">q</span>，会令<span class="hljs-selector-tag">P</span>指向<span class="hljs-selector-tag">q</span>，否则会将<span class="hljs-selector-tag">P</span>置为空。<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(<span class="hljs-selector-tag">q</span>, d) //若还传递了参数d,将会调用d而不是delete 来释放<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>weak_ptr弱引用的智能指针</strong></p>
<ul>
<li><p><code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏</p>
</li>
<li><p>要想解决上面循环引用的问题，只能引入新的智能指针<code>std::weak_ptr</code>。<code>std::weak_ptr</code>有什么特点呢？与<code>std::shared_ptr</code>最大的差别是在赋值的时候，不会引起智能指针计数增加</p>
<ul>
<li><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作，可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加</li>
<li>同样，在<code>weak_ptr</code>析构时也不会导致引用计数的减少，它只是一个静静地观察者。<code>weak_ptr</code>没有重载<code>operator*</code>和<code>-&gt;</code>，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因</li>
<li>如要操作资源，则必须使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象，从而操作资源</li>
</ul>
</li>
<li><p>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它：</p>
<ul>
<li>&#96;&#96;&#96;<br>auto p &#x3D; make_shared<int>(42);<br>weak_ptr<int> wp(p); &#x2F;&#x2F; wp弱共享p; p的引用计数未改变<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- **weak_ptr常用操作**<br><br>  - ```<br>    weak_ptr&lt;T&gt; w;	<span class="hljs-regexp">//</span> 空weak_ptr可以指向类型为T的对象<br>    weak_ptr&lt;T&gt; w(shared_ptr p);	<span class="hljs-regexp">//</span> 与p指向相同对象的weak_ptr, T必须能转换为sp指向的类型<br>    w = p;	<span class="hljs-regexp">//</span> p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象<br>    w.reset();	<span class="hljs-regexp">//</span> weak_ptr置为空<br>    w.use_count();	<span class="hljs-regexp">//</span> 与w共享对象的shared_ptr的计数<br>    w.expired();	<span class="hljs-regexp">//</span> w.use_count()为<span class="hljs-number">0</span>则返回true，否则返回false<br>    w.lock();	<span class="hljs-regexp">//</span> w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>unique_ptr的基本使用</strong></p>
<ul>
<li><p><code>unique_ptr</code>相对于其他两个智能指针更加简单，它和<code>shared_ptr</code>使用差不多，但是功能更为单一，它是一个独占型的智能指针，不允许其他的智能指针共享其内部的指针，更像原生的指针（但更为安全，能够自己释放内存）。<strong>不允许赋值和拷贝操作，只能够移动</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">0</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1; <span class="hljs-comment">// 错误，不能复制</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// 可以移动</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>性能与安全的权衡</strong></p>
<ul>
<li><code>shared_ptr</code>的大小是原始指针的两倍，因为它的内部有一个原始指针指向资源，同时有个指针指向引用计数</li>
<li>引用计数的内存必须动态分配。虽然一点可以使用<code>make_shared()</code>来避免，但也存在一些情况下不能够使用<code>make_shared()</code></li>
<li>增加和减小引用计数必须是原子操作，因为可能会有读写操作在不同的线程中同时发生。比如在一个线程里有一个指向一块资源的<code>shared_ptr</code>可能调用了析构（因此所指向的资源的引用计数减一），同时，在另一线程里，指向相同对象的一个<code>shared_ptr</code>可能执行了拷贝操作（因此，引用计数加一）。原子操作一般会比非原子操作慢。但是为了线程安全，又不得不这么做，这就给单线程使用环境带来了不必要的困扰</li>
</ul>
</li>
</ul>
<h2 id="6-野指针"><a href="#6-野指针" class="headerlink" title="6.野指针"></a>6.野指针</h2><p><strong>野指针指向一个已删除的对象或 申请访问受限内存区域的指针</strong></p>
<p><strong>产生原因：</strong></p>
<ul>
<li>指针变量未初始化</li>
<li>指针释放未置空</li>
<li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</li>
</ul>
<h2 id="7-强制转换"><a href="#7-强制转换" class="headerlink" title="7.强制转换"></a>7.强制转换</h2><p><strong>C++中强制转换为static_cast, dynamic_cast,const_cast, reinterpret_cast</strong></p>
<ul>
<li><strong>static_cast</strong><ul>
<li>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li>
<li>static_cast &lt; type-id &gt; (expression)</li>
<li>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
</li>
</ul>
</li>
<li><strong>dynamic_cast</strong><ul>
<li>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li>
<li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</li>
<li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</li>
<li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</li>
</ul>
</li>
<li><strong>const_cast</strong><ul>
<li>用于删除 const、volatile特性</li>
<li>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
</li>
</ul>
</li>
<li><strong>reinterpret_cast</strong><ul>
<li>reinterpret_cast<type-id> (expression)</li>
<li>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</li>
<li>几乎什么都可以转,不能丢掉 const、volatile特性</li>
</ul>
</li>
</ul>
<h2 id="8-RTTI"><a href="#8-RTTI" class="headerlink" title="8.RTTI"></a>8.RTTI</h2><p><strong>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid</strong></p>
<ul>
<li><p>dynamic_cast 动态类型转换</p>
</li>
<li><p>typeid typeid 运算符允许在运行时确定对象的类型，获取对象的实际类型</p>
</li>
</ul>
<h2 id="9-RAII"><a href="#9-RAII" class="headerlink" title="9.RAII"></a>9.RAII</h2><p><strong>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”</strong></p>
<ul>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li>
</ul>
<h2 id="11-右值引用"><a href="#11-右值引用" class="headerlink" title="11.右值引用"></a>11.右值引用</h2><ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>左值：存储在内存中，有明确存储地址(可寻址)的数据</li>
<li>右值：可以提供数据值的数据(不一定可以寻址，如寄存器中的数据)</li>
</ul>
</li>
<li><p><strong>判断某个表达式是左值还是右值</strong></p>
<ul>
<li>可位于&#x3D;左侧的表达式就是左值；反之，只能位于&#x3D;右侧的表达式就是右值</li>
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值</li>
</ul>
</li>
<li><p><strong>右值引用：</strong></p>
<ul>
<li><strong>右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</strong></li>
<li>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>&amp; b = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//左值引用</span><br><span class="hljs-built_in">int</span>&amp; e = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，左值引用不能使用右值初始化</span><br><span class="hljs-built_in">int</span>&amp;&amp; d = <span class="hljs-built_in">num</span>; <span class="hljs-comment">//错误，右值引用不能使用左值初始化 </span><br><span class="hljs-built_in">int</span>&amp;&amp; a = <span class="hljs-number">10</span>; <span class="hljs-comment">//右值引用</span><br><span class="hljs-built_in">int</span>&amp;&amp; c = <span class="hljs-built_in">num</span> + <span class="hljs-number">40</span>; <span class="hljs-comment">//右值引用</span><br>a = <span class="hljs-number">100</span>; <span class="hljs-comment">//右值引用可以对右值进行修改</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>右值引用的特点</strong></p>
<ul>
<li>通过右值引用的声明，右值的生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值变量将会一直存活下去</li>
</ul>
</li>
<li><p><strong>移动语义</strong></p>
<ul>
<li><p><strong>定义：</strong>即从右值中直接拿数据过来初始化或修改左值，而不需要重新构造一个临时左值后再析构右值，减少了两个对象交互时不必要的拷贝构造</p>
</li>
<li><p><strong>可解决的问题：</strong></p>
<ul>
<li>用右值参数</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//在实现转移语义之前</span><br><span class="hljs-comment">//const &amp;的形参接收了右值参数，但是调用了额外的拷贝构造函数，生成了一个临时变量，销毁临时变量还调用了一次析构函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//在实现转移语义之后</span><br><span class="hljs-comment">//会调用1次移动构造函数</span><br>MyString a = new MyString(b + <span class="hljs-string">&quot;abc&quot;</span>);<br>MyString(MsString &amp;&amp; <span class="hljs-built_in">str</span>)&#123;<br>	<span class="hljs-variable">_len</span> = <span class="hljs-built_in">str</span>.len;<br>	<span class="hljs-variable">_data</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span>;	<span class="hljs-comment">//从右值中获取数据</span><br>	<span class="hljs-built_in">str</span>.len = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> = NULL;	<span class="hljs-comment">//销毁右值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对象存入容器<ul>
<li>void push_back(const T&amp; value)</li>
<li>void push_back(T &amp;&amp; value)</li>
<li>使用push_back()需要调用拷贝构造函数和移动构造函数</li>
<li>而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造函数和移动构造函数，效率更高</li>
</ul>
</li>
<li>vector增长扩容<ul>
<li>移动语义之前是复制并删除，之后只需要移动即可</li>
<li>vector添加元素在空间不够的时候需要重新分配，此时对于原来已有的元素会调用对象类的move constructor，而如果对象类没有定义移动构造，则会使用copy constructor</li>
<li>所以给类添加移动构造函数可以在很多时候提高效率，因为没有它只能用拷贝构造来替代，而编译器又不会自动合成一个</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::move函数</strong></p>
<ul>
<li>将左值转变为右值</li>
<li>只有右值引用的类型在后面加上&amp;&amp;仍然是右值引用</li>
<li>其余的在后面加&amp;或者&amp;&amp;都是左值引用</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">string</span> s(<span class="hljs-string">&quot;hello&quot;</span>);<br>std::move(s) =&gt; std::move(<span class="hljs-keyword">string</span>&amp; &amp;&amp;) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp; )<br>此时：T的类型为<span class="hljs-keyword">string</span>&amp;<br>	remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例化如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp; t) <span class="hljs-comment">//t为左值，移动后不能在使用t</span><br>&#123;<br>    <span class="hljs-comment">//通过static_cast将string&amp;强制转换为string&amp;&amp;</span><br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir">std::move(<span class="hljs-keyword">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)) =&gt; 折叠后 std::move(<span class="hljs-keyword">string</span>&amp;&amp;)<br>此时：T的类型为<span class="hljs-keyword">string</span> <br>     remove_reference&lt;T&gt;::type为<span class="hljs-keyword">string</span> <br>整个std::move被实例如下<br><span class="hljs-keyword">string</span>&amp;&amp; move(<span class="hljs-keyword">string</span>&amp;&amp; t) <span class="hljs-comment">//t为右值</span><br>&#123;<br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-keyword">string</span>&amp;&amp;&gt;(t);  <span class="hljs-comment">//返回一个右值引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>完美转发</strong></p>
<ul>
<li>使用场景：需要将一组参数原封不动地传递给另一个函数，左值&#x2F;右值、const&#x2F;non-const属性在传递过程中不能改变</li>
<li>使用方法：<ul>
<li>在模板参数列表中使用T&amp;&amp;（通用引用）</li>
<li>使用std::forward()转发变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四、STL模板库"><a href="#四、STL模板库" class="headerlink" title="四、STL模板库"></a>四、STL模板库</h1><h2 id="1-STL中的swap函数"><a href="#1-STL中的swap函数" class="headerlink" title="1.STL中的swap函数"></a>1.STL中的swap函数</h2><ul>
<li>除了数组，其他容器在交换后本质上是将内存地址进行了交换，而元素本身在内存中的位置是没有变化</li>
<li>swap在交换的时候并不是完全将2个容器的元素互换，而是交换了2个容器内的内存地址</li>
</ul>
<h2 id="2-STL中的哈希表扩容"><a href="#2-STL中的哈希表扩容" class="headerlink" title="2.STL中的哈希表扩容"></a>2.STL中的哈希表扩容</h2><ul>
<li><strong>哈希表概述</strong><ul>
<li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预</li>
<li><strong>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</strong></li>
</ul>
</li>
<li><strong>哈希表扩容</strong><ul>
<li>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置</li>
<li><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>这里需要知道STL中的swap底层，其实扩容也是vector扩容<ul>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到sqrt(n)范围内的数) </li>
<li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换两个桶的地址)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-STL迭代器失效的几种情况总结"><a href="#3-STL迭代器失效的几种情况总结" class="headerlink" title="3.STL迭代器失效的几种情况总结"></a>3.STL迭代器失效的几种情况总结</h2><ul>
<li><p><strong>迭代器的失效问题：</strong>对容器的操作影响了元素的存放位置，称为迭代器失效</p>
</li>
<li><p><strong>失效情况</strong></p>
<ul>
<li>当容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li>
<li>当容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效</li>
<li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了</li>
</ul>
</li>
<li><p><strong>序列式容器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	vector&lt;<span class="hljs-type">int</span>&gt; q&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br>	<span class="hljs-comment">// 在这里想把大于2的元素都删除</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br>		<span class="hljs-keyword">if</span> (*it &gt; <span class="hljs-number">2</span>)<br>			q.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 这里就会发生迭代器失效</span><br>	&#125;<br>	<span class="hljs-comment">// 打印结果</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++) &#123;<br>		cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	cout &lt;&lt; endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>迭代器失效的原因是：因为 vetor、deque 使用了连续分配的内存，<code>erase</code>操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效</p>
</li>
<li><p>解决方法是利用<code>erase</code>方法可以返回下一个有效的 iterator，所以代码做如下修改即可：</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在这里想把大于<span class="hljs-number">2</span>的元素都删除<br><span class="hljs-keyword">for</span>(auto it=q.begin();it!=q.end();)<br>&#123;<br>    <span class="hljs-keyword">if</span>(*it&gt;<span class="hljs-number">2</span>)<br>    &#123;<br>    	it=q.erase(it); <span class="hljs-regexp">//</span> 这里会返回指向下一个元素的迭代器，因此不需要再自加了<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    	it++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>链表式容器</strong></p>
<ul>
<li>对于链表式容器(如 list)，删除当前的 iterator，仅仅会使当前的 iterator 失效，这是因为 list 之类的容器，<strong>使用了链表来实现，插入、删除一个结点不会对其他结点造成影响</strong></li>
<li>只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator</li>
</ul>
<p><strong>方式一：递增当前 iterator</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); it != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*iter)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      cont.<span class="hljs-built_in">erase</span>(iter++);<br>   <span class="hljs-keyword">else</span><br>      iter++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方式二：通过 erase 获得下一个有效的 iterator</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (iter = cont.<span class="hljs-built_in">begin</span>(); iter != cont.<span class="hljs-built_in">end</span>();)<br>&#123;<br>   (*it)-&gt;<span class="hljs-built_in">doSomething</span>();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldDelete</span>(*iter))<br>      iter = cont.<span class="hljs-built_in">erase</span>(iter);  <span class="hljs-comment">//erase删除元素，返回下一个迭代器</span><br>   <span class="hljs-keyword">else</span><br>      ++iter;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>关联式容器</strong></p>
<ul>
<li>对于关联容器(如 map, set,multimap,multiset)，删除当前的 iterator，仅仅会使当前的 iterator 失效，只要在 erase 时，递增当前 iterator 即可</li>
<li>这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响</li>
<li><strong>erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用<code>erase(iter++)</code>的方式删除迭代器</strong></li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">for</span> (iter = dataMap.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; iter != dataMap.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; )<br>&#123;<br>         <span class="hljs-built_in">int</span> nKey = iter-&gt;first;<br>         <span class="hljs-built_in">string</span> strValue = iter-&gt;second;<br><br>         <span class="hljs-keyword">if</span> (nKey % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>         &#123;<br>               dataMap.erase(iter++);<br>               auto a = iter;<br>         &#125;<span class="hljs-keyword">else</span><br>     		 &#123;<br>          iter++;<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>dataMap.erase(iter++); <strong>这句话分三步走，先把 iter 传值到 erase 里面，然后 iter 自增，然后执行 erase，所以 iter 在失效前已经自增了</strong></li>
<li>map 是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系</li>
</ul>
</li>
</ul>
<h2 id="4-迭代器：-it、it-哪个好，为什么"><a href="#4-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.迭代器：++it、it++哪个好，为什么"></a>4.迭代器：++it、it++哪个好，为什么</h2><ol>
<li>前置返回一个引用，后置返回一个对象</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span> <span class="hljs-comment">// ++i实现代码为：</span><br>int&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>  *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br></code></pre></td></tr></table></figure>

<ol start="2">
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2.</span> <span class="hljs-comment">//i++实现代码为：                 </span><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)                 <br>&#123;<br>   <span class="hljs-type">int</span> temp = *<span class="hljs-keyword">this</span>;                   <br>   ++*<span class="hljs-keyword">this</span>;                       <br>   <span class="hljs-keyword">return</span> temp;                  <br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="5-STL中的allocator、deallocator"><a href="#5-STL中的allocator、deallocator" class="headerlink" title="5.STL中的allocator、deallocator"></a>5.STL中的allocator、deallocator</h2><ul>
<li><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器</p>
</li>
<li><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块</p>
</li>
<li><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空</p>
</li>
<li><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存</p>
</li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PersonalSummary/">#PersonalSummary</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++面经-个人总结</div>
      <div>http://example.com/2022/07/09/C++-面经-个人总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fyy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/09/Mysql%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="Mysql面经-个人总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql面经-个人总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="计算机网络面经-个人总结">
                        <span class="hidden-mobile">计算机网络面经-个人总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
