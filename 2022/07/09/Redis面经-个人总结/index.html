

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fyy">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、数据结构与对象1.Redis数据类型和应用场景Redis五大数据类型，string，hash，list，set，zset  string（字符串） 一个字符串类型的值能存储最大容量是512M set&#x2F;get 设置&#x2F;获取   setex setex k4 10 v4 设置过期时间10s，然后给k4赋值为v4   setnx setnx k1 v11 若k1存在，则不覆盖，否则">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis面经-个人总结">
<meta property="og:url" content="http://example.com/2022/07/09/Redis%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="UESTC-Fyy">
<meta property="og:description" content="一、数据结构与对象1.Redis数据类型和应用场景Redis五大数据类型，string，hash，list，set，zset  string（字符串） 一个字符串类型的值能存储最大容量是512M set&#x2F;get 设置&#x2F;获取   setex setex k4 10 v4 设置过期时间10s，然后给k4赋值为v4   setnx setnx k1 v11 若k1存在，则不覆盖，否则">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221546516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221548702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221551991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221611239.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221612054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621765.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621841.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626574.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221627969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221631030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221221742.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222039.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222729.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221223195.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520828.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520842.awebp">
<meta property="article:published_time" content="2022-07-09T07:15:59.000Z">
<meta property="article:modified_time" content="2022-08-12T05:46:52.132Z">
<meta property="article:author" content="Fyy">
<meta property="article:tag" content="PersonalSummary">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221546516.png">
  
  
  <title>Redis面经-个人总结 - UESTC-Fyy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DKnIWAmLCrVnCLIBVwd8hotg-gzGzoHsz","app_key":"9xmUpEdyRJB2o9bIKREcXk3j","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>UESTC-Fyy-Master</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis面经-个人总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-09 15:15" pubdate>
          2022年7月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          168 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis面经-个人总结</h1>
            
            <div class="markdown-body">
              
              <h1 id="一、数据结构与对象"><a href="#一、数据结构与对象" class="headerlink" title="一、数据结构与对象"></a>一、数据结构与对象</h1><h2 id="1-Redis数据类型和应用场景"><a href="#1-Redis数据类型和应用场景" class="headerlink" title="1.Redis数据类型和应用场景"></a>1.Redis数据类型和应用场景</h2><p><strong>Redis五大数据类型，string，hash，list，set，zset</strong></p>
<ul>
<li><strong>string（字符串）</strong><ul>
<li><strong>一个字符串类型的值能存储最大容量是512M</strong></li>
<li>set&#x2F;get<ul>
<li>设置&#x2F;获取</li>
</ul>
</li>
<li>setex<ul>
<li>setex k4 10 v4</li>
<li>设置过期时间10s，然后给k4赋值为v4</li>
</ul>
</li>
<li>setnx<ul>
<li>setnx k1 v11</li>
<li>若k1存在，则不覆盖，否则，建立k1，并赋值v11</li>
</ul>
</li>
<li>mset&#x2F;get</li>
</ul>
</li>
<li><strong>hash（哈希）</strong></li>
<li><strong>list（列表）</strong><ul>
<li>lpush&#x2F;rpush<ul>
<li>从左边&#x2F;右边压入</li>
</ul>
</li>
<li>lrange<ul>
<li>指定范围，从左边获取</li>
</ul>
</li>
<li>lpop&#x2F;rpop<ul>
<li>从左边&#x2F;右边弹出</li>
</ul>
</li>
</ul>
</li>
<li><strong>set（集合）</strong></li>
<li><strong>zset（有序集合）</strong><ul>
<li>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构</li>
</ul>
</li>
</ul>
<h1 id="二、单机数据库的实现"><a href="#二、单机数据库的实现" class="headerlink" title="二、单机数据库的实现"></a>二、单机数据库的实现</h1><h2 id="1-Redis优缺点"><a href="#1-Redis优缺点" class="headerlink" title="1.Redis优缺点"></a>1.Redis优缺点</h2><ul>
<li><strong>CAP原理</strong><ul>
<li>C：Consistency 强一致性</li>
<li>A：Availability 可用性</li>
<li>P：Partition tolerance 分区容错性</li>
</ul>
</li>
<li><strong>分布式和集群</strong><ul>
<li><strong>分布式：</strong>不同的多台服务器上部署不同的服务器模块，它们之间通过RPC来通信和调用</li>
<li><strong>集群：</strong>不同的多台服务器上部署者相同的服务器模块，通过分布式调度软件统一调度</li>
</ul>
</li>
<li><strong>相对于memcache的不同</strong><ul>
<li>Redis支持数据持久化，可以将内存中的数据保存到磁盘中，重启时再次加载到内存中</li>
<li>Redis支持丰富的数据结构，list，set，hash，zset</li>
<li>Redis是单进程单线程，Memcached是单进程多线程</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>Redis主要消耗内存资源，数据库容量受到<strong>物理内存的限制</strong>，不能用作海量数据的高性能读写</li>
<li>因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上</li>
</ul>
</li>
</ul>
<h2 id="2-Redis线程模型"><a href="#2-Redis线程模型" class="headerlink" title="2.Redis线程模型"></a>2.Redis线程模型</h2><ul>
<li>单线程模型处理客户端请求</li>
<li>封装epoll函数实现读写事件的响应</li>
<li><strong>单线程效率高的原因</strong><ul>
<li>纯内存操作</li>
<li>核心是基于非阻塞的IO多路复用机制</li>
<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题</li>
</ul>
</li>
</ul>
<h2 id="3-Redis持久化机制RDB和AOF"><a href="#3-Redis持久化机制RDB和AOF" class="headerlink" title="3.Redis持久化机制RDB和AOF"></a>3.Redis持久化机制RDB和AOF</h2><ul>
<li><p><strong>默认机制</strong></p>
<ul>
<li>默认是RDB持久</li>
<li>redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化，RDB是数据，AOF是写命令</li>
<li>同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整</li>
</ul>
</li>
<li><p><strong>RDB</strong><br>RDB（Redis Database）持久化机制，<strong>是对redis中的数据执行周期性的持久化</strong>，生成dump.rdb文件</p>
<ul>
<li><strong>snapshot快照</strong><ul>
<li>在指定时间间隔将内存的数据集快照写入磁盘，恢复时将快照直接读入内存</li>
<li>默认rdb参数，可以通过save 秒数 次数来修改rdb参数<ul>
<li>1分钟改1万次</li>
<li>5分钟改10次</li>
<li>15分钟改1次</li>
</ul>
</li>
</ul>
</li>
<li><strong>当执行save，bgsave，flushall，shutdown命令时，也会生成快照文件dump.rdb，其中flushall会生成空的dump文件</strong></li>
<li><strong>save和bgsave</strong><ul>
<li>save立即保存，不会等待RDB参数，另外save只保存，其他不管，因此会阻塞</li>
<li>bgsave下Redis会在后台异步进行快照操作，同时相应客户端请求</li>
</ul>
</li>
<li><strong>恢复</strong><ul>
<li>redis启动时，会自动加载dump.rdb文件，将快照加载到内存中</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备<ul>
<li>我们知道RDB每次生成的新dump文件都会覆盖旧文件，如果想保存每个时刻写入的快照文件，可以另外修改代码，按时间生成的dump文件，并传到备份机器</li>
</ul>
</li>
<li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>
<li>大规模数据比AOF快，直接将数据恢复到内存中，想对于AOF回放要快</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>一定时间间隔做一次持久化，若redis意外宕机，则会丢失最后一次快照的修改</li>
<li>每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>AOF</strong><br>AOF（Append Only File）<strong>机制对每条写命令作为日志</strong>，以 append-only（追加） 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集，生成appendonly.aof文件</p>
<ul>
<li><strong>追加方式</strong><ul>
<li><strong>everysec</strong><ul>
<li>异步持久化，默认是每秒进行记录，最多丢失一秒的数据</li>
</ul>
</li>
<li><strong>always</strong><ul>
<li>同步持久化，每次修改都会同步，redis性能会大大降低</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复</strong><ul>
<li><strong>正常恢复</strong><ul>
<li>启动appendonly yes</li>
<li>将数据aof复制到对应目录</li>
<li>重新启动redis</li>
</ul>
</li>
<li><strong>异常恢复</strong><ul>
<li>redis-check-aof –fix appendonly.aof</li>
<li>dump也可以这样修复</li>
</ul>
</li>
</ul>
</li>
<li><strong>rewrite</strong><ul>
<li>AOF会越来越大，文件会越来越大，redis默认每个文件64M，当超过上一个文件大小一倍时，启动重写</li>
<li>在rewrite log的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来</li>
<li>在创建新日志文件的时候，老的日志文件还是照常写入</li>
<li>每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建</li>
<li>当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据</li>
<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合<strong>做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>类似 AOF 这种较为复杂的基于命令日志 &#x2F; merge &#x2F; 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug</li>
<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-Redis过期策略和缓存淘汰策略"><a href="#4-Redis过期策略和缓存淘汰策略" class="headerlink" title="4.Redis过期策略和缓存淘汰策略"></a>4.Redis过期策略和缓存淘汰策略</h2><ul>
<li><strong>过期策略</strong><br><strong>redis 过期策略是：定期删除+惰性删除</strong><ul>
<li><strong>定期删除</strong><ul>
<li>redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</li>
</ul>
</li>
<li><strong>惰性删除</strong><ul>
<li>在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西</li>
</ul>
</li>
</ul>
</li>
<li><strong>淘汰策略</strong><ul>
<li><strong>noeviction：</strong>当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>
<li><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，<strong>在键空间中</strong>，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random：</strong>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉</li>
<li><strong>volatile-lr：</strong>当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间中</strong>，移除最近最少使用的 key（这个一般不太合适）</li>
<li><strong>volatile-random：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</li>
<li><strong>volatile-ttl：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li>
</ul>
</li>
</ul>
<h1 id="三、多机数据库的实现"><a href="#三、多机数据库的实现" class="headerlink" title="三、多机数据库的实现"></a>三、多机数据库的实现</h1><h2 id="1-Redis主从复制-哨兵，如何保证redis的高并发和高可用？"><a href="#1-Redis主从复制-哨兵，如何保证redis的高并发和高可用？" class="headerlink" title="1.Redis主从复制+哨兵，如何保证redis的高并发和高可用？"></a>1.Redis主从复制+哨兵，如何保证redis的高并发和高可用？</h2><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS</p>
<h3 id="1-1主从架构"><a href="#1-1主从架构" class="headerlink" title="1.1主从架构"></a>1.1<strong>主从架构</strong></h3><p>单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221546516.png" srcset="/img/loading.gif" lazyload alt="Redis-master-slave"></a></p>
<p>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h4 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a><strong>Redis replication 的核心机制</strong></h4><ul>
<li><p>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量</p>
</li>
<li><p>一个 master node 是可以配置多个 slave node </p>
</li>
<li><p>slave node 也可以连接其他的 slave node</p>
</li>
<li><p>slave node 做复制的时候，不会 block master node 的正常工作</p>
</li>
<li><p>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</p>
</li>
<li><p>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量</p>
</li>
<li><p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了</p>
</li>
<li><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空</p>
</li>
</ul>
<h4 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据</p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave-replication.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221548702.png" srcset="/img/loading.gif" lazyload alt="Redis-master-slave-replication"></a></p>
<ul>
<li><strong>主从复制的断点续传</strong></li>
</ul>
<p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p>
<p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> </p>
<blockquote>
<p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分</p>
</blockquote>
<ul>
<li><strong>无磁盘化复制</strong></li>
</ul>
<p>master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">repl-<span class="hljs-keyword">diskless-sync </span>yes<br><br><span class="hljs-comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br>repl-<span class="hljs-keyword">diskless-sync-delay </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>过期 key 处理</strong></li>
</ul>
<p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave</p>
<h4 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a><strong>复制的完整流程</strong></h4><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始</p>
<p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node</p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-master-slave-replication-detail.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221551991.png" srcset="/img/loading.gif" lazyload alt="Redis-master-slave-replication-detail"></a></p>
<ul>
<li><p><strong>全量复制</strong></p>
<ul>
<li><p>master 执行 bgsave ，在本地生成一份 rdb 快照文件</p>
</li>
<li><p>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</p>
</li>
<li><p>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node</p>
</li>
<li><p>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败</p>
</li>
<li><p>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时<strong>基于旧的数据版本</strong>对外提供服务</p>
</li>
<li><p>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">client</span>-output-buffer-limit slave <span class="hljs-number">256</span>MB <span class="hljs-number">64</span>MB <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>增量复制</strong></p>
<ul>
<li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制</p>
</li>
<li><p>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB</p>
</li>
<li><p>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的</p>
</li>
</ul>
</li>
<li><p><strong>heartbeat</strong></p>
<ul>
<li><p>主从节点互相都会发送 heartbeat 信息</p>
</li>
<li><p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat</p>
</li>
</ul>
</li>
<li><p><strong>异步复制</strong></p>
<ul>
<li>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node</li>
</ul>
</li>
</ul>
<h4 id="Redis-如何才能做到高可用"><a href="#Redis-如何才能做到高可用" class="headerlink" title="Redis 如何才能做到高可用"></a>Redis 如何才能做到高可用</h4><ul>
<li><p>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的</p>
</li>
<li><p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务</p>
</li>
<li><p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了</p>
</li>
<li><p>Redis 的高可用架构，叫做 <code>failover</code> <strong>故障转移</strong>，也可以叫做主备切换</p>
</li>
<li><p>master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用</p>
</li>
</ul>
<h3 id="1-2Redis哨兵集群实现高可用"><a href="#1-2Redis哨兵集群实现高可用" class="headerlink" title="1.2Redis哨兵集群实现高可用"></a>1.2Redis哨兵集群实现高可用</h3><h4 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h4><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li><strong>集群监控：</strong>负责监控 Redis master 和 slave 进程是否正常工作</li>
<li><strong>消息通知：</strong>如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li>
<li><strong>故障转移：</strong>如果 master node 挂掉了，会自动转移到 slave node 上</li>
<li><strong>配置中心：</strong>如果故障转移发生了，通知 client 客户端新的 master 地址</li>
</ul>
<p>哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了</li>
</ul>
<h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性</li>
<li>哨兵 + Redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 Redis 集群的高可用性</li>
<li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练</li>
</ul>
<p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum &#x3D; 1</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+         +----+<br>|<span class="hljs-string"> M1 </span>|<span class="hljs-string">---------</span>|<span class="hljs-string"> R1 </span>|<br>|<span class="hljs-string"> S1 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> S2 </span>|<br>+----+         +----+<br></code></pre></td></tr></table></figure>

<p>配置 <code>quorum=1</code> ，如果 master 宕机， s1 和 s2 中只要有 1 个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 majority，也就是大多数哨兵都是运行的</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2 个哨兵，<span class="hljs-attribute">majority</span>=2<br>3 个哨兵，<span class="hljs-attribute">majority</span>=2<br>4 个哨兵，<span class="hljs-attribute">majority</span>=2<br>5 个哨兵，<span class="hljs-attribute">majority</span>=3<br><span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行</p>
<p>经典的 3 节点哨兵集群是这样的：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">       +----+<br>       |<span class="hljs-string"> M1 </span>|<br>       |<span class="hljs-string"> S1 </span>|<br>       +----+<br>          |<span class="hljs-string"></span><br><span class="hljs-string">+----+    </span>|<span class="hljs-string">    +----+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> R2 </span>|<span class="hljs-string">----+----</span>|<span class="hljs-string"> R3 </span>|<br>|<span class="hljs-string"> S2 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> S3 </span>|<br>+----+         +----+<br></code></pre></td></tr></table></figure>

<p>配置 <code>quorum=2</code> ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移</p>
<h4 id="Redis-哨兵主备切换的数据丢失问题"><a href="#Redis-哨兵主备切换的数据丢失问题" class="headerlink" title="Redis 哨兵主备切换的数据丢失问题"></a>Redis 哨兵主备切换的数据丢失问题</h4><p><strong>导致数据丢失的两种情况</strong></p>
<p>主备切换的过程，可能会导致数据丢失：</p>
<ul>
<li><strong>异步复制导致的数据丢失</strong></li>
</ul>
<p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221611239.png" srcset="/img/loading.gif" lazyload alt="image-20220722161104063"></p>
<ul>
<li><strong>脑裂导致的数据丢失</strong></li>
</ul>
<p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong></p>
<p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221612054.png" srcset="/img/loading.gif" lazyload alt="image-20220722161245020"></p>
<p><strong>数据丢失问题的解决方案</strong></p>
<p>进行如下配置：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒</p>
<p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了</p>
<ul>
<li>减少异步复制数据的丢失</li>
</ul>
<p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内</p>
<ul>
<li>减少脑裂的数据丢失</li>
</ul>
<p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据</p>
<h4 id="sdown-和-odown-转换机制"><a href="#sdown-和-odown-转换机制" class="headerlink" title="sdown 和 odown 转换机制"></a>sdown 和 odown 转换机制</h4><ul>
<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>
<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>
</ul>
<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了</p>
<h4 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h4><ul>
<li><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在</p>
</li>
<li><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置</p>
</li>
<li><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在</p>
</li>
<li><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步</p>
</li>
</ul>
<h4 id="slave-配置的自动纠正"><a href="#slave-配置的自动纠正" class="headerlink" title="slave 配置的自动纠正"></a>slave 配置的自动纠正</h4><ul>
<li>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上</li>
</ul>
<h4 id="slave-gt-master-选举算法"><a href="#slave-gt-master-选举算法" class="headerlink" title="slave-&gt;master 选举算法"></a>slave-&gt;master 选举算法</h4><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p>
<ul>
<li>跟 master 断开连接的时长</li>
<li>slave 优先级</li>
<li>复制 offset</li>
<li>run id</li>
</ul>
<p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">(down-<span class="hljs-keyword">after</span>-<span class="hljs-built_in">milliseconds</span> * <span class="hljs-number">10</span>) + milliseconds_since_master_is_in_SDOWN_state<br></code></pre></td></tr></table></figure>

<p>接下来会对 slave 进行排序：</p>
<ul>
<li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高</li>
<li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高</li>
<li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave</li>
</ul>
<h4 id="quorum-和-majority"><a href="#quorum-和-majority" class="headerlink" title="quorum 和 majority"></a>quorum 和 majority</h4><ul>
<li><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换</p>
</li>
<li><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换</p>
</li>
<li><p>但是如果 quorum &gt;&#x3D; majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换</p>
</li>
</ul>
<h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><ul>
<li><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置</p>
</li>
<li><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的</p>
</li>
<li><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号</p>
</li>
</ul>
<h4 id="configuration-传播"><a href="#configuration-传播" class="headerlink" title="configuration 传播"></a>configuration 传播</h4><ul>
<li><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制</p>
</li>
<li><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的</p>
</li>
</ul>
<h2 id="2-Redis集群"><a href="#2-Redis集群" class="headerlink" title="2.Redis集群"></a>2.Redis集群</h2><h3 id="2-1Redis-cluster-介绍"><a href="#2-1Redis-cluster-介绍" class="headerlink" title="2.1Redis cluster 介绍"></a>2.1Redis cluster 介绍</h3><ul>
<li>自动将数据进行分片，每个 master 上放一部分数据</li>
<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>
</ul>
<p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p>
<h3 id="2-2节点间的内部通信机制"><a href="#2-2节点间的内部通信机制" class="headerlink" title="2.2节点间的内部通信机制"></a>2.2节点间的内部通信机制</h3><h4 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a><strong>基本通信原理</strong></h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信</p>
<p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护</p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/zookeeper-centralized-storage.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621765.png" srcset="/img/loading.gif" lazyload alt="zookeeper-centralized-storage"></a></p>
<p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更</p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-gossip.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221621841.png" srcset="/img/loading.gif" lazyload alt="Redis-gossip"></a></p>
<p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力</p>
<p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后</p>
<ul>
<li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> </li>
<li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等</li>
</ul>
<h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a><strong>gossip 协议</strong></h4><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等</p>
<ul>
<li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Redis-trib.rb add-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure>

<p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群</p>
<ul>
<li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据</li>
<li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新</li>
<li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦</li>
</ul>
<h4 id="ping-消息深入"><a href="#ping-消息深入" class="headerlink" title="ping 消息深入"></a>ping 消息深入</h4><ul>
<li><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担</p>
</li>
<li><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率</p>
</li>
<li><p>每次 ping，会带上自己节点的信息，还有就是带上 1&#x2F;10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息</p>
</li>
</ul>
<h3 id="2-3分布式寻址算法"><a href="#2-3分布式寻址算法" class="headerlink" title="2.3分布式寻址算法"></a>2.3分布式寻址算法</h3><ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>Redis cluster 的 hash slot 算法</li>
</ul>
<h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库</p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/hash.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626574.png" srcset="/img/loading.gif" lazyload alt="hash"></a></p>
<h4 id="一致性-hash-算法"><a href="#一致性-hash-算法" class="headerlink" title="一致性 hash 算法"></a>一致性 hash 算法</h4><ul>
<li><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置</p>
</li>
<li><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置</p>
</li>
<li><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理</p>
</li>
<li><p>然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/consistent-hashing-algorithm.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221626821.png" srcset="/img/loading.gif" lazyload alt="consistent-hashing-algorithm"></a></p>
<h4 id="Redis-cluster-的-hash-slot-算法"><a href="#Redis-cluster-的-hash-slot-算法" class="headerlink" title="Redis cluster 的 hash slot 算法"></a>Redis cluster 的 hash slot 算法</h4><ul>
<li><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot</p>
</li>
<li><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现</p>
</li>
<li><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/hash-slot.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221627969.png" srcset="/img/loading.gif" lazyload alt="hash-slot"></a></p>
<h3 id="2-4Redis-cluster-的高可用与主备切换原理"><a href="#2-4Redis-cluster-的高可用与主备切换原理" class="headerlink" title="2.4Redis cluster 的高可用与主备切换原理"></a>2.4Redis cluster 的高可用与主备切换原理</h3><p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的</p>
<h4 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h4><ul>
<li><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code> ，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code> ，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown</p>
</li>
<li><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code> ，那么就被认为 <code>pfail</code> </p>
</li>
<li><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中， <code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code></p>
</li>
</ul>
<h4 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h4><ul>
<li><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node</p>
</li>
<li><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code> ，那么就<strong>没有资格</strong>切换成 <code>master</code></p>
</li>
</ul>
<h4 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h4><ul>
<li><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举</p>
</li>
<li><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node <code>（N/2 + 1）</code> 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master</p>
</li>
<li><p>从节点执行主备切换，从节点切换为主节点</p>
</li>
</ul>
<h4 id="与哨兵比较"><a href="#与哨兵比较" class="headerlink" title="与哨兵比较"></a>与哨兵比较</h4><ul>
<li>整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能</li>
</ul>
<h2 id="3-分布式算法一致性哈希"><a href="#3-分布式算法一致性哈希" class="headerlink" title="3.分布式算法一致性哈希"></a>3.分布式算法一致性哈希</h2><ul>
<li><strong>普通哈希</strong><ul>
<li>原始的做法是对缓存项的键进行哈希，将hash后的结果对<strong>缓存服务器的数量</strong>进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上</li>
<li><strong>缺点</strong><ul>
<li>当服务器数量发生变化的时候，所有缓存在一定时间内是失效的，重新哈希，跟服务器结点的数量有关</li>
<li>当应用无法从缓存中获取数据时，则会向后端服务器请求数据，造成了缓存的雪崩，整个系统很有可能被压垮</li>
</ul>
</li>
</ul>
</li>
<li><strong>一致性哈希</strong><ul>
<li><strong>环形hash空间的概念</strong><ul>
<li>通常hash算法都是将value映射在一个32位的key值当中，那么把数据首尾相接就会形成一个圆形，取值范围为0 ~ 2^32-1，这个圆环就是环形hash空间</li>
</ul>
</li>
<li><strong>一致性哈希步骤</strong><ul>
<li>首先求出服务器（节点）的哈希值，并将其配置到0～2^32-1的圆（continuum）上</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上</li>
<li>然后从数据映射到的位置开始<strong>顺时针查找</strong>，将数据保存到找到的第一个服务器上。如果超过232-1仍然找不到服务器，就会保存到第一台服务器上。(0和232重合，超过后就顺序找到第一台了)</li>
</ul>
</li>
<li><strong>当发生服务器结点变化</strong><ul>
<li>一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</li>
<li>一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚拟结点</strong><br>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题<ul>
<li><strong>rehash实现虚拟结点进行平衡</strong><ul>
<li>对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点</li>
<li>数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上，这样就解决了服务节点少时数据倾斜的问题</li>
<li>在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-Redis和Mysql缓存和数据库的双写一致性"><a href="#4-Redis和Mysql缓存和数据库的双写一致性" class="headerlink" title="4.Redis和Mysql缓存和数据库的双写一致性"></a>4.Redis和Mysql缓存和数据库的双写一致性</h2><ul>
<li><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去</p>
</li>
<li><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求</p>
</li>
</ul>
<h3 id="4-1Cache-Aside-Pattern"><a href="#4-1Cache-Aside-Pattern" class="headerlink" title="4.1Cache Aside Pattern"></a>4.1Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应</li>
<li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong></li>
</ul>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ul>
<li><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值</p>
</li>
<li><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的</p>
</li>
<li><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p>
</li>
<li><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。<strong>用到缓存才去算缓存</strong></p>
</li>
<li><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工</p>
</li>
</ul>
<h3 id="4-2最初级的缓存不一致问题及解决方案"><a href="#4-2最初级的缓存不一致问题及解决方案" class="headerlink" title="4.2最初级的缓存不一致问题及解决方案"></a>4.2最初级的缓存不一致问题及解决方案</h3><p><strong>问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/redis-junior-inconsistent.png"><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221631030.png" srcset="/img/loading.gif" lazyload alt="redis-junior-inconsistent"></a></p>
<ul>
<li><p>解决思路 1：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中</p>
</li>
<li><p>解决思路 2：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后</p>
</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">public void <span class="hljs-built_in">set</span>(key, value) &#123;<br>    <span class="hljs-built_in">putToDb</span>(key, value);<br>    <span class="hljs-built_in">deleteFromRedis</span>(key);<br><br>    <span class="hljs-comment">// ... a few seconds later</span><br>    <span class="hljs-built_in">deleteFromRedis</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>删除的动作，可以有多种选择，比如：1. 使用 <code>DelayQueue</code>，会随着 JVM 进程的死亡，丢失更新的风险；2. 放在 <code>MQ</code>，但编码复杂度为增加。总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案</li>
</ul>
<h3 id="4-3比较复杂的数据不一致问题分析"><a href="#4-3比较复杂的数据不一致问题分析" class="headerlink" title="4.3比较复杂的数据不一致问题分析"></a>4.3比较复杂的数据不一致问题分析</h3><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p>
<p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong></p>
<p><strong>解决方案如下：</strong></p>
<ul>
<li><p>更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中</p>
</li>
<li><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成</p>
</li>
<li><p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可</p>
</li>
<li><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中</p>
</li>
<li><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</p>
</li>
<li><p><strong>高并发的场景下，该解决方案要注意的问题：</strong></p>
</li>
<li><p><strong>读请求长时阻塞</strong></p>
</li>
</ul>
<p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回</p>
<p>该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的</p>
<p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 &#x3D; 1000ms &#x3D; 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong></p>
<p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的</p>
<p><strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少</p>
<p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了</p>
<p>我们来<strong>实际粗略测算一下</strong></p>
<p>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了</p>
<p>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列</p>
<ul>
<li><strong>读请求并发量过高</strong></li>
</ul>
<p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值</p>
<p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大</p>
<ul>
<li><strong>多服务实例部署的请求路由</strong></li>
</ul>
<p>可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong></p>
<p>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等</p>
<ul>
<li><strong>热点商品的路由问题，导致请求的倾斜</strong></li>
</ul>
<p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些</p>
<h2 id="5-缓存雪崩和缓存穿透及解决方案"><a href="#5-缓存雪崩和缓存穿透及解决方案" class="headerlink" title="5.缓存雪崩和缓存穿透及解决方案"></a>5.缓存雪崩和缓存穿透及解决方案</h2><ul>
<li><p><strong>缓存雪崩</strong><br>缓存宕机，此时所有请求落到数据库上，由于高并发的请求，导致数据库宕机，发生缓存血崩</p>
<ul>
<li><strong>解决方案</strong><ul>
<li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃</li>
<li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死</li>
<li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据</li>
</ul>
</li>
<li><strong>请求流程</strong><ul>
<li>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中</li>
<li>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次</li>
</ul>
</li>
<li><strong>好处</strong><ul>
<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过</li>
<li>只要数据库不死，就是说，对用户来说，部分请求都是可以被处理的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓存穿透</strong><br>发来的请求或恶意攻击，此时的数据在缓存和数据库中都没有，因此全部在数据库中查询，导致缓存穿透；若每次都有大量穿透，直接查数据库，则数据库宕机</p>
<ul>
<li><strong>解决方案</strong><ul>
<li>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set key UNKNOWN</li>
<li>然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓存击穿</strong><br>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库</p>
<ul>
<li><strong>解决方案</strong><ul>
<li>将热点key设置为永不过期</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-Redis常见问题及解决方案"><a href="#6-Redis常见问题及解决方案" class="headerlink" title="6.Redis常见问题及解决方案"></a>6.Redis常见问题及解决方案</h2><ul>
<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变</li>
</ul>
<h1 id="四、独立功能的实现"><a href="#四、独立功能的实现" class="headerlink" title="四、独立功能的实现"></a>四、独立功能的实现</h1><h2 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1.Redis事务"></a>1.Redis事务</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>概念：</strong> 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</p>
<p><strong>Redis部分支持事务，不支持的是：强一致性</strong></p>
<p><strong>能干嘛：</strong> 一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>MULTI</code>：开启一个事务，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中</li>
<li><code>EXEC</code>：执行队列中所有的命令</li>
<li><code>DISCARD</code>：清空事务队列,并放弃执行事务</li>
<li><code>UNWATCH</code>：取消 <code>WATCH</code> 命令对所有 key 的监视</li>
<li><code>WATCH key1 key2 ...</code>	：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</li>
</ul>
<h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><ul>
<li><strong>正常执行：</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221221742.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
<ul>
<li><strong>放弃事务：</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222039.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
<ul>
<li><strong>全体连坐：</strong></li>
</ul>
<p>一个指令语法错误，EXEC执行报错</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221222729.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
<ul>
<li><p><strong>部分支持事务：</strong></p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221223195.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
</li>
<li><p><strong>WACTCH监控：先监控，后开启事务</strong></p>
<p>缓存的数据，谁都可以拿，可以改，所以必须打标记来监控行为。这里涉及到锁的问题：悲观锁&#x2F;乐观锁&#x2F;CAS(Check And Set)</p>
<ul>
<li><code>悲观锁(Pessimistic Lock)</code>： 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li>
<li><code>乐观锁(Optimistic Lock)</code>： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下，在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量</li>
<li>乐观锁策略（常用）：提交版本必须大于记录当前版本才能执行更新。这样既不影响并发性，有可以满足需求</li>
</ul>
</li>
<li><p><strong>案例演示</strong></p>
<ul>
<li><p>正常情况：无加塞篡改</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520828.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
</li>
<li><p>有加塞篡改的情况</p>
<p><img src="https://raw.githubusercontent.com/fyyuestc/Images/main/img/202207221520842.awebp" srcset="/img/loading.gif" lazyload alt="image"></p>
</li>
</ul>
<p>在 WATCH 监控后，有人修改了balance，会导致事务会被打断，必须更新最新值，才能成功执行事务，类似于乐观锁的版本号机制</p>
</li>
</ul>
<h3 id="三、事务三阶段"><a href="#三、事务三阶段" class="headerlink" title="三、事务三阶段"></a>三、事务三阶段</h3><p>1、<strong>开启：</strong>以MULTI开始一个事务</p>
<p>2<strong>、入队：</strong>将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p>
<p>3、<strong>执行：</strong>由EXEC命令触发事务</p>
<h3 id="四、事务三特性"><a href="#四、事务三特性" class="headerlink" title="四、事务三特性"></a>四、事务三特性</h3><p>1、<strong>单独的隔离操作：</strong>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p>
<p>2、<strong>没有隔离级别的概念：</strong>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p>
<p>3、<strong>（重点）不保证原子性：</strong>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚，这也就是：<code>Redis</code>部分支持事务</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Redis/" class="category-chain-item">Redis</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PersonalSummary/">#PersonalSummary</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis面经-个人总结</div>
      <div>http://example.com/2022/07/09/Redis面经-个人总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fyy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="分布式面经-个人总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式面经-个人总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/09/Mysql%E9%9D%A2%E7%BB%8F-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="Mysql面经-个人总结">
                        <span class="hidden-mobile">Mysql面经-个人总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
